{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LASER documentation","text":"<p>LASER (Light Agent Spatial modeling for ERadication) is a high-performance, stochastic agent-based simulation framework for modeling the spread of infectious diseases. It supports spatial structure, age demographics, and modular disease logic using Python-based components.</p> <p>The LASER framework is designed to be flexible and is composed of modular components that can be used to create custom epidemiological models. For those who want to explore disease dynamics without the need to code from scratch, the framework includes epidemiological components that are designed model diseases with non-vector transmission dynamics. These modules can be used to create anything from simple compartmental models to more complex agent-based models with spatial dynamics. The framework is open-source, so for those who want to contribute to code, contributions are welcome!</p>"},{"location":"#installation","title":"Installation","text":"<p>LASER is distributed as a Python package. The recommended install path for most users is through the high-level <code>laser-generic</code> package, which includes the core engine and all epidemiological modeling tools.</p>"},{"location":"#recommended-for-most-users","title":"\u2705 Recommended for most users","text":"<p>To install LASER, run:</p> <pre><code>uv pip install laser-generic\n</code></pre> <p>This installs:</p> <ul> <li><code>laser-generic</code>: modeling framework and components (e.g., SIR, SEIR, demography, mobility)</li> <li><code>laser-core</code>: the basic data structures used by <code>laser-generic</code></li> </ul> <p>Once installed, you can start using LASER (importing components and composing a model) with:</p> <pre><code>from laser.generic.model import Model\nfrom laser.generic.models.components import Susceptible\netc.\n</code></pre>"},{"location":"#for-engine-developers","title":"\ud83d\udee0\ufe0f For engine developers","text":"<p>If you are developing or modifying the model code, you can install the low-level engine directly:</p> <pre><code>uv pip install laser-core\n</code></pre> <p>This is not required for modelers using the LASER framework via <code>laser-generic</code>.</p>"},{"location":"#verify-the-install","title":"Verify the install","text":"<p>Check your install with:</p> <pre><code>python -c \"import laser.generic; print('LASER is ready.')\"\n</code></pre>"},{"location":"#why-uv","title":"Why <code>uv</code>?","text":"<p><code>uv</code> is a modern Python package manager that is:</p> <ul> <li>Much faster than pip</li> <li>Fully compatible with <code>pip install</code></li> <li>Drop-in replacement for Python environments</li> </ul> <p>To install <code>uv</code>:</p> <pre><code>pip install uv\n</code></pre>"},{"location":"#learn-more","title":"Learn more","text":"<ul> <li> <p> Get started</p> <p>Create and run simulations.</p> <p> Get started modeling</p> </li> <li> <p> Reference</p> <p>Full details on all classes and functions.</p> <p> API reference</p> </li> <li> <p> Tutorials</p> <p>An interactive tour of key features.</p> <p> Tutorials</p> </li> <li> <p> What's new</p> <p>See what's in the latest releases.</p> <p> What's new</p> </li> </ul>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Christopher Lorton - Tech Lead, Author, Maintainer</li> <li>Kevin McCarthy - Research Lead, Author</li> <li>Paul Saxman - Author, Maintainer</li> <li>Jonathan Bloedow - Author</li> <li>Katherine Rosenfeld - Author</li> </ul>"},{"location":"code_of_conduct/","title":"LASER Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We pledge to make our community welcoming, safe, and equitable for all.</p> <p>We are committed to fostering an environment that respects and promotes the dignity, rights, and contributions of all individuals, regardless of characteristics including race, ethnicity, caste, color, age, physical characteristics, neurodiversity, disability, sex or gender, gender identity or expression, sexual orientation, language, philosophy or religion, national or social origin, socio-economic position, level of education, or other status. The same privileges of participation are extended to everyone who participates in good faith and in accordance with this Covenant.</p>"},{"location":"code_of_conduct/#encouraged-behaviors","title":"Encouraged Behaviors","text":"<p>While acknowledging differences in social norms, we all strive to meet our community's expectations for positive behavior. We also understand that our words and actions may be interpreted differently than we intend based on culture, background, or native language.</p> <p>With these considerations in mind, we agree to behave mindfully toward each other and act in ways that center our shared values, including:</p> <ol> <li>Respecting the purpose of our community, our activities, and our ways of gathering.</li> <li>Engaging kindly and honestly with others.</li> <li>Respecting different viewpoints and experiences.</li> <li>Taking responsibility for our actions and contributions.</li> <li>Gracefully giving and accepting constructive feedback.</li> <li>Committing to repairing harm when it occurs.</li> <li>Behaving in other ways that promote and sustain the well-being of our community.</li> </ol>"},{"location":"code_of_conduct/#restricted-behaviors","title":"Restricted Behaviors","text":"<p>We agree to restrict the following behaviors in our community. Instances, threats, and promotion of these behaviors are violations of this Code of Conduct.</p> <ol> <li>Harassment. Violating explicitly expressed boundaries or engaging in unnecessary personal attention after any clear request to stop.</li> <li>Character attacks. Making insulting, demeaning, or pejorative comments directed at a community member or group of people.</li> <li>Stereotyping or discrimination. Characterizing anyone\u2019s personality or behavior on the basis of immutable identities or traits.</li> <li>Sexualization. Behaving in a way that would generally be considered inappropriately intimate in the context or purpose of the community.</li> <li>Violating confidentiality. Sharing or acting on someone's personal or private information without their permission.</li> <li>Endangerment. Causing, encouraging, or threatening violence or other harm toward any person or group.</li> <li>Behaving in other ways that threaten the well-being of our community.</li> </ol>"},{"location":"code_of_conduct/#other-restrictions","title":"Other Restrictions","text":"<ol> <li>Misleading identity. Impersonating someone else for any reason, or pretending to be someone else to evade enforcement actions.</li> <li>Failing to credit sources. Not properly crediting the sources of content you contribute.</li> <li>Promotional materials. Sharing marketing or other commercial content in a way that is outside the norms of the community.</li> <li>Irresponsible communication. Failing to responsibly present content which includes, links or describes any other restricted behaviors.</li> </ol>"},{"location":"code_of_conduct/#reporting-an-issue","title":"Reporting an Issue","text":"<p>Tensions can occur between community members even when they are trying their best to collaborate. Not every conflict represents a code of conduct violation, and this Code of Conduct reinforces encouraged behaviors and norms that can help avoid conflicts and minimize harm.</p> <p>When an incident does occur, it is important to report it promptly. To report a possible violation, please email the community moderators, Christopher Lorton and Paul Saxman with as much detail as possible.</p> <p>Community Moderators take reports of violations seriously and will make every effort to respond in a timely manner. They will investigate all reports of code of conduct violations, reviewing messages, logs, and recordings, or interviewing witnesses and other participants. Community Moderators will keep investigation and enforcement actions as transparent as possible while prioritizing safety and confidentiality. In order to honor these values, enforcement actions are carried out in private wwith the involved parties, but communicating to the whole community may be part of a mutually agreed upon resolution.</p>"},{"location":"code_of_conduct/#addressing-and-repairing-harm","title":"Addressing and Repairing Harm","text":"<p>If an investigation by the Community Moderators finds that this Code of Conduct has been violated, the following enforcement ladder may be used to determine how best to repair harm, based on the incident's impact on the individuals involved and the community as a whole. Depending on the severity of a violation, lower rungs on the ladder may be skipped.</p> <p>1) Warning    1) Event: A violation involving a single incident or series of incidents.    2) Consequence: A private, written warning from the Community Moderators.    3) Repair: Examples of repair include a private written apology, acknowledgement of responsibility, and seeking clarification on expectations. 2) Temporarily Limited Activities    1) Event: A repeated incidence of a violation that previously resulted in a warning, or the first incidence of a more serious violation.    2) Consequence: A private, written warning with a time-limited cooldown period designed to underscore the seriousness of the situation and give the community members involved time to process the incident. The cooldown period may be limited to particular communication channels or interactions with particular community members.    3) Repair: Examples of repair may include making an apology, using the cooldown period to reflect on actions and impact, and being thoughtful about re-entering community spaces after the period is over. 3) Temporary Suspension    1) Event: A pattern of repeated violation which the Community Moderators have tried to address with warnings, or a single serious violation.    2) Consequence: A private written warning with conditions for return from suspension. In general, temporary suspensions give the person being suspended time to reflect upon their behavior and possible corrective actions.    3) Repair: Examples of repair include respecting the spirit of the suspension, meeting the specified conditions for return, and being thoughtful about how to reintegrate with the community when the suspension is lifted. 4) Permanent Ban    1) Event: A pattern of repeated code of conduct violations that other steps on the ladder have failed to resolve, or a violation so serious that the Community Moderators determine there is no way to keep the community safe with this person as a member.    2) Consequence: Access to all community spaces, tools, and communication channels is removed. In general, permanent bans should be rarely used, should have strong reasoning behind them, and should only be resorted to if working through other remedies has failed to change the behavior.    3) Repair: There is no possible repair in cases of this severity.</p> <p>This enforcement ladder is intended as a guideline. It does not limit the ability of Community Managers to use their discretion and judgment, in keeping with the best interests of our community.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public or other spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 3.0, permanently available at https://www.contributor-covenant.org/version/3/0/.</p> <p>Contributor Covenant is stewarded by the Organization for Ethical Source and licensed under CC BY-SA 4.0. To view a copy of this license, visit https://creativecommons.org/licenses/by-sa/4.0/</p>"},{"location":"contribute/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given where it's due.</p> <p>A few things to note before you begin:</p> <ul> <li>The LASER team is committed to maintaining a welcoming community. We ask that all contributors adhere to our Code of Conduct.</li> <li>Code contributions should follow the Google Python Style Guide.</li> <li>When reporting a bug please include details, such as your operating system and the exact steps to reproduce the issue.</li> <li>LASER could always use more documentation, whether as part of the official LASER docs, in docstrings, or even on the web in blog posts, articles, and such.</li> <li>The best way to send feedback on LASER is to file an issue.</li> </ul> <p>If you have any questions, please reach out to the LASER moderators, Christopher Lorton and Paul Saxman.</p>"},{"location":"contribute/#contributing-code","title":"Contributing code","text":"<p>For contriburing code to LASER, you'll need to set up a local development environment:</p> <ol> <li> <p>Fork <code>laser-generic</code> (look for the \"Fork\" button).</p> </li> <li> <p>Create a local clone of your fork:</p> </li> </ol> <pre><code>git clone git@github.com:YOUR_GITHUB_NAME/laser-generic.git\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <ol> <li> <p>Make your changes locally.</p> </li> <li> <p>When you're done making changes run all the checks and docs builder with one command:</p> </li> </ol> <pre><code>tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contribute/#pull-request-guidelines","title":"Pull request guidelines","text":"<p>If you need some code review or feedback while you're developing the code just make the pull request.</p> <p>For merging, you should:</p> <ol> <li>Include passing tests (run <code>tox</code>).</li> <li>Update documentation when there are new APIs, functionality, etc.</li> <li>Add a note to <code>CHANGELOG.md</code> about the changes.</li> <li>Add yourself to <code>AUTHORS.md</code>.</li> </ol>"},{"location":"contribute/#tips","title":"Tips","text":"<p>To run a subset of tests:</p> <pre><code>tox -e envname -- pytest -k test_myfeature\n</code></pre> <p>To run all the test environments in parallel:</p> <pre><code>tox -p auto\n</code></pre>"},{"location":"whatsnew/","title":"Changelog","text":""},{"location":"whatsnew/#000-2024-11-19","title":"0.0.0 (2024-11-19)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"get-started/","title":"Get started","text":"<p>LASER is intended for modeling diseases with straightforward and predictable transmission dynamics, such as influenza or measles.</p>"},{"location":"get-started/#installation","title":"Installation","text":"<p>See the Home page for installation instructions.</p>"},{"location":"get-started/#usage","title":"Usage","text":"<p>To use the project:</p> <pre><code>import laser.generic\nlaser.generic.compute(...)\n</code></pre>"},{"location":"get-started/#create-and-run-a-simulation","title":"Create and run a simulation","text":"<p>LASER is designed to be modular and flexible to accommodate a variety of modeling needs. The example below demonstrates how to construct and run a simple SIR model in LASER using the <code>laser-core</code> and <code>laser-generic</code> libraries. It features:</p> <ul> <li>One spatial node (<code>1x1</code> grid)</li> <li>Poisson-distributed infectious periods</li> <li>Correct S \u2192 I \u2192 R transitions</li> <li>CSV output and plotting</li> </ul>"},{"location":"get-started/#1-import-dependencies","title":"1. Import dependencies","text":"<pre><code>import numpy as np\nimport pandas as pd\n\nfrom laser.core import PropertySet\nfrom laser.core.distributions import poisson\n\nfrom laser.generic.model import Model\nfrom laser.generic import SIR\n</code></pre>"},{"location":"get-started/#2-define-the-parameters","title":"2. Define the parameters","text":"<p>We configure simulation-wide parameters using a <code>PropertySet</code>, including:</p> <ul> <li>Simulation length (<code>nticks</code>)</li> <li>Infection rate (<code>beta</code>)</li> <li>Average infectious period</li> <li>Number of initial infections</li> <li>RNG seed</li> </ul> <pre><code>params = PropertySet({\n    \"nticks\": 160,\n    \"beta\": 0.8,                    # Per-day infection rate\n    \"mean_infectious_period\": 7.0,  # Average duration of infectiousness\n    \"initial_infected\": 10,\n    \"seed\": 123,\n})\n</code></pre>"},{"location":"get-started/#3-define-the-scenario-single-patch","title":"3. Define the scenario (single patch)","text":"<p>Always use the <code>grid()</code> utility to create a scenario so that it's compliant with expectations downstream in the Model class. Here we use it even to create a 1x1 spatial node (\"patch\") with 50,000 people. The population is then split into S, I, and R:</p> <pre><code>from laser.core.utils import grid\nscenario = grid(\n    M=1,\n    N=1,\n    population_fn=lambda r, c: 50_000\n)\n\nscenario[\"I\"] = params.initial_infected\nscenario[\"S\"] = scenario[\"population\"] - params.initial_infected\nscenario[\"R\"] = 0\n</code></pre>"},{"location":"get-started/#4-build-the-model","title":"4. Build the model","text":"<p>Initialize the <code>Model</code> using the scenario and parameters. The <code>.people</code> frame is automatically constructed with internal state fields.</p> <pre><code>model = Model(scenario, params)\npeople = model.people  # Auto-generated LaserFrame for agents\n</code></pre>"},{"location":"get-started/#5-configure-the-infectious-duration-distribution","title":"5. Configure the infectious duration distribution","text":"<p>We define a Numba-wrapped Poisson distribution for the infectious period using LASER\u2019s distribution API.</p> <pre><code>infectious_duration = poisson(params.mean_infectious_period)\n</code></pre>"},{"location":"get-started/#6-attach-components","title":"6. Attach components","text":"<p>LASER models are built from modular components, each responsible for a specific part of the disease process. Components are executed once per timestep, in the order they are attached to the model.</p> <p>A standard SIR model is constructed from four conceptual steps:</p> <ul> <li>Tracking the number of susceptible agents (S)</li> <li>Modeling transmission from susceptible to infectious agents (S -&gt; I)</li> <li>Modeling infectiousness and recovery (I -&gt; R)</li> <li>Tracking the recovered population (R)</li> </ul> <p>Correct ordering matters: components that record state must wrap components that change state, otherwise population counts will be inconsistent.</p> <p>In this example, we attach the components directly from <code>laser.generic.components</code>, rather than using the <code>SIR</code> convenience submodule.</p> <pre><code>from laser.generic.components import (\n    Susceptible,\n    TransmissionSI,\n    InfectiousIR,\n    Recovered,\n)\n\nmodel.components = [\n    Susceptible(model),\n    TransmissionSI(model, infdurdist=infdist),\n    InfectiousIR(model, infdurdist=infdist),\n    Recovered(model),\n]\n</code></pre>"},{"location":"get-started/#susceptiblemodel","title":"<code>Susceptible(model)</code>","text":"<p>This component:</p> <ul> <li>Initializes agents' infection state to SUSCEPTIBLE (state code <code>0</code>)</li> <li>Records the number of susceptible agents per node at each timestep</li> <li>Does not modify state transitions on its own</li> </ul> <p>No parameters or distributions are required.</p> <p>This component exists purely to track and record the susceptible population.</p>"},{"location":"get-started/#transmissionsimodel-infdurdist","title":"<code>TransmissionSI(model, infdurdist=...)</code>","text":"<p>This component implements the S -&gt; I transition.</p> <p>For each timestep, it:</p> <ul> <li>Computes the force of infection:     $$     \\lambda = \\beta \\cdot \\frac{I}{N}     $$</li> <li>For each susceptible agent, performs a Bernoulli trial with probability:     $$     p = 1 - e^{-\\lambda}     $$</li> <li> <p>If infection occurs:</p> <ul> <li>The agent\u2019s state is set to INFECTIOUS - An infection duration is drawn from <code>infdurdist</code></li> <li>The duration is stored in the agent\u2019s <code>itimer</code> property</li> </ul> </li> </ul> <p>The <code>infdurdist</code> argument must be a Numba-compatible distribution function, for example:</p> <pre><code>from laser.core.distributions import poisson\ninfdist = poisson(mean_infectious_period)\n</code></pre> <p>This component is responsible only for new infections; recovery is handled separately.</p>"},{"location":"get-started/#infectiousirmodel-infdurdist","title":"<code>InfectiousIR(model, infdurdist=...)</code>","text":"<p>This component handles the I -&gt; R transition.</p> <p>It:</p> <ul> <li>Decrements each infectious agent\u2019s <code>itimer</code> each timestep</li> <li>Transitions agents to RECOVERED when their timer reaches zero</li> <li>Updates node-level counts for infectious and recovered populations</li> </ul> <p>This component must use the same <code>infdurdist</code> as <code>TransmissionSI</code>, because it relies on the infection timers set during transmission.</p>"},{"location":"get-started/#recoveredmodel","title":"<code>Recovered(model)</code>","text":"<p>This component:</p> <ul> <li>Tracks the number of recovered agents per node</li> <li>Updates recovered counts over time</li> <li>Does not initiate any transitions or timers</li> </ul> <p>No parameters are required.</p>"},{"location":"get-started/#important-note-on-ordering","title":"Important note on ordering","text":"<p>The recommended order is:</p> <ol> <li><code>Susceptible</code></li> <li><code>TransmissionSI</code></li> <li><code>InfectiousIR</code></li> <li><code>Recovered</code></li> </ol> <p>This ensures that:</p> <ul> <li>Population counts are recorded consistently</li> <li>State transitions occur before recovery is tallied</li> <li>The invariant <code>S + I + R = N</code> is preserved at each timestep</li> </ul>"},{"location":"get-started/#parameterization","title":"Parameterization","text":"<p>The keyword argument:</p> <pre><code>infdurdist=infectious_duration\n</code></pre> <p>is a Numba-wrapped distribution function. In this example, we use:</p> <pre><code>from laser.core.distributions import poisson\ninfectious_duration = poisson(7.0)\n</code></pre> <p>This means newly infected agents will remain infectious for a random number of days drawn from a Poisson distribution with mean 7.</p> <p>Alternative distributions available in <code>laser.core.distributions</code>:</p> <ul> <li><code>exponential(scale)</code></li> <li><code>gamma(shape, scale)</code></li> <li><code>lognormal(mean, sigma)</code></li> <li><code>constant_int(value)</code></li> <li><code>custom</code> (with tick/node-dependent logic)</li> </ul> <p>Note</p> <p>You must use a Numba-compatible function with signature <code>(tick: int, node: int) \u2192 float/int</code></p> <p>Note</p> <p>Order matters: make sure Susceptible and Recovered components wrap the transition steps.</p>"},{"location":"get-started/#optional-enhancements","title":"Optional Enhancements","text":"<ul> <li>You can replace <code>InfectiousIR</code> with <code>InfectiousIRS</code> for waning immunity (SIRS model).</li> <li>You can use <code>TransmissionSE</code> and <code>Exposed</code> components for SEIR models.</li> <li>Add importation (<code>Infect_Random_Agents</code>) or demography (<code>Births</code>, <code>Deaths</code>) as additional components.</li> </ul> <pre><code>from laser.generic.importation import Infect_Random_Agents\nmodel.components.append(Infect_Random_Agents(model))\n</code></pre>"},{"location":"get-started/#7-run-the-simulation","title":"7. Run the simulation","text":"<p>Run the simulation for the configured number of timesteps.</p> <pre><code>model.run()\n</code></pre>"},{"location":"get-started/#8-extract-sir-time-series","title":"8. Extract SIR time series","text":"<p>Extract patch-level S, I, R results as a Pandas DataFrame.</p> <pre><code>df = pd.DataFrame({\n    \"time\": np.arange(params.nticks + 1),\n    \"S\": model.nodes.S[:, 0],\n    \"I\": model.nodes.I[:, 0],\n    \"R\": model.nodes.R[:, 0],\n})\n\nprint(df.head())\nprint(\"Peak infectious:\", df[\"I\"].max())\n</code></pre>"},{"location":"get-started/#9-save-to-csv","title":"9. Save to CSV","text":"<p>Export the results to disk for downstream analysis or plotting.</p> <pre><code>df.to_csv(\"sir_timeseries.csv\", index=False)\nprint(\"Saved sir_timeseries.csv\")\n</code></pre>"},{"location":"get-started/#10-plot-results","title":"10. Plot results","text":"<p>Plot the trajectory of S, I, and R over time using <code>matplotlib</code>.</p> <pre><code>import matplotlib.pyplot as plt\n\nplt.plot(df[\"time\"], df[\"S\"], label=\"S\")\nplt.plot(df[\"time\"], df[\"I\"], label=\"I\")\nplt.plot(df[\"time\"], df[\"R\"], label=\"R\")\n\nplt.xlabel(\"Time\")\nplt.ylabel(\"Population\")\nplt.legend()\nplt.grid(True)\nplt.title(\"LASER SIR Example (1 node)\")\nplt.show()\n</code></pre>"},{"location":"get-started/#using-ai","title":"Using AI","text":"<p>For internal IDM users, you can use a pre-built AI interface, nicknamed JENNER-GPT, to create your simulations or ask questions about LASER. It is designed to know everything about LASER and can not only answer your general questions about the system, but also provide working code for components or for entire runnable scripts.</p>"},{"location":"get-started/#tutorials","title":"Tutorials","text":"<p>The Tutorials section begins with example code to demonstrate setting up simple SIR models and gradually adding complexity. For an interactive experience, begin with the first Jupyter notebook tutorial SI model with no demographics for a very simple implementation of the LASER model.</p>"},{"location":"get-started/calibration/","title":"Calibrate LASER models","text":"<p>LASER can be calibrated using Optuna. Calibration is a process of tuning model parameters to fit real-world data, to ensure that model output provides accurate insights. Calibration can also be used as a method to help debug your model, as an inability to recreate known phenomena can help pinpoint issues in model code. For more information on calibration, check out IDM's ModelingHub.</p>"},{"location":"get-started/calibration/#simple-local-calibration","title":"Simple local calibration","text":"<ol> <li> <p>Expose parameters in your model. Ensure your LASER model can load and apply parameters you wish to calibrate. These are typically passed through a <code>params</code> dictionary or a <code>PropertySet</code> and might include:</p> <ul> <li>Basic reproduction number (R0)</li> <li>Duration of infection</li> <li>Seeding prevalence</li> </ul> </li> <li> <p>Write post-processing code. Modify your model to save key outputs (e.g., number of infected individuals over time) to a CSV file. For example, use:</p> <p><code>save_results_to_csv(sim.results)</code></p> <p>This CSV will be used later by the objective function.</p> </li> <li> <p>Create the objective function. Write a Python script, usually named <code>objective.py</code>, containing a function like this:</p> <pre><code>def objective(trial):\n    # Load trial parameters\n    R0 = trial.suggest_float(\"R0\", 1.0, 3.5)\n\n    # Run model (via subprocess, or function call)\n    run_model(R0)\n\n    # Load model output and reference data\n    model_df = pd.read_csv(\"output.csv\")\n    ref_df = pd.read_csv(\"reference.csv\")\n\n    # Compare and return score\n    error = np.mean((model_df[\"I\"] - ref_df[\"I\"])**2)\n    return error\n</code></pre> <p>Tip: You can write unit tests for your objective function by mocking model outputs.</p> </li> <li> <p>Test the objective function standalone. Before integrating with Optuna, run your objective function directly to ensure it works:</p> <pre><code>from objective import objective\nfrom optuna.trial import FixedTrial\n\nscore = objective(FixedTrial({\"R0\": 2.5}))\nprint(f\"Test score: {score}\")\n</code></pre> <p>Expected result: A numeric score. If it crashes, check CSV paths and data types.</p> </li> <li> <p>Run simple calibration (SQLite, no Docker). Use the calib/worker.py helper to run a local test study with a small number of trials.</p> <p>Linux/macOS (Bash or similar):</p> <pre><code>export STORAGE_URL=sqlite:///example.db &amp;&amp; python3 calib/worker.py --num-trials=10\n</code></pre> <p>Windows (PowerShell):</p> <pre><code>$env:STORAGE_URL=\"sqlite:///example.db\"; python calib/worker.py --num-trials=10\n</code></pre> <p>This is helpful for debugging. Consider running a scaled-down version of your model to save time.</p> </li> </ol>"},{"location":"get-started/calibration/#local-dockerized-calibration","title":"Local Dockerized calibration","text":"<ol> <li> <p>Dockerize your model and objective. Use the provided <code>Dockerfile</code> to build a container that includes both your model and objective function. Do this from the main directory.</p> <p><code>docker build . -f calib/Dockerfile -t idm-docker-staging.packages.idmod.org/laser/laser-polio:latest</code></p> </li> <li> <p>Create Docker network. You\u2019ll need a shared network so your workers and database container can communicate:</p> <p><code>docker network create optuna-network</code></p> </li> <li> <p>Launch MySQL database container:</p> <pre><code>docker run -d --name optuna-mysql --network optuna-network -p 3306:3306 \\\n  -e MYSQL_ALLOW_EMPTY_PASSWORD=yes \\\n  -e MYSQL_DATABASE=optuna_db mysql:latest\n</code></pre> </li> <li> <p>Launch calibration worker:</p> <pre><code>docker run --rm --name calib_worker --network optuna-network \\\n  -e STORAGE_URL=\"mysql://root@optuna-mysql:3306/optuna_db\" \\\n  idm-docker-staging.packages.idmod.org/laser/laser-polio:latest \\\n  --study-name test_polio_calib --num-trials 1\n</code></pre> <p>If that works, you can change the study name or number of trials.</p> <p>Troubleshooting: If this fails, try running the worker interactively and debug inside:</p> <p><code>docker run -it --network optuna-network --entrypoint /bin/bash idm-docker-staging.packages.idmod.org/laser/laser-polio:latest</code></p> </li> <li> <p>Monitor calibration progress:</p> <p>Use Optuna CLI. You should be able to pip install optuna.</p> <pre><code>optuna trials \\\n  --study-name=test_polio_calib \\\n  --storage \"mysql+pymysql://root:@localhost:3306/optuna_db\"\n\noptuna best-trial \\\n  --study-name=test_polio_calib \\\n  --storage \"mysql+pymysql://root:@localhost:3306/optuna_db\"\n</code></pre> </li> </ol>"},{"location":"get-started/calibration/#cloud-calibration","title":"Cloud calibration","text":"<ol> <li> <p>Push Docker image to registry. If you\u2019ve built a new docker image, you\u2019ll want to push it so it\u2019s available to AKS:</p> <p><code>docker push idm-docker-staging.packages.idmod.org/laser/laser-polio:latest</code></p> </li> <li> <p>Cloud deployment. This step assumes you have secured access to an Azure Kubernetes Service (AKS) cluster. You may need to obtain or generate a new kube config file. Detailed instructions for that are not included here. This step assumes the cluster corresponding to your config is up and accessible.</p> <p><code>cd calib/cloud</code></p> <p>Edit <code>cloud_calib_config.py</code> to set the <code>storage_url</code> to:</p> <p><code>\"mysql+pymysql://optuna:superSecretPassword@localhost:3306/optunaDatabase\"</code></p> <p>Set the study name and number of trials per your preference. Detailed documentation of the other parameters is not included here.</p> <p>Launch multiple workers:</p> <p><code>python3 run_calib_workers.py</code></p> </li> <li> <p>View final results:</p> <p>Forward port to local machine. Note that is the first instruction to rely on installing <code>kubectl</code>. Open a bash shell if necessary.</p> <p><code>kubectl port-forward mysql-0 3306:3306 &amp;</code></p> <p>Use Optuna CLI to check results:</p> <pre><code>optuna trials \\\n  --study-name=test_polio_calib \\\n  --storage \"mysql+pymysql://optuna:superSecretPassword@localhost:3306/optunaDatabase\"\n\noptuna best-trial \\\n  --study-name=test_polio_calib \\\n  --storage \"mysql+pymysql://optuna:superSecretPassword@localhost:3306/optunaDatabase\"\n</code></pre> <p>Generate a report on disk about the study (can be run during study or at end).</p> <p><code>python3 report_calib_aks.py</code></p> <p>Launch Optuna dashboard:</p> <p><code>python -c \"import optuna_dashboard; optuna_dashboard.run_server('mysql+pymysql</code></p> </li> </ol>"},{"location":"get-started/optimization/","title":"Optimize LASER models","text":"<p>As an agent-based model, research using LASER will require thousands of simulation replicates. While the model is designed to perform well with large agent populations, there is still a need to utilize high compute power and to optimize model performance.</p> <p>When creating LASER models, knowing how to identify and fix performance bottlenecks can save compute time and speed results.</p>"},{"location":"get-started/optimization/#identify-bottlenecks","title":"Identify bottlenecks","text":"<p>Typically, we do not recommend running the code through a profiler, at least not initially. Instead, we take advantage of LASER\u2019s highly modular structure and AI-driven optimization.</p> <p>The first step is to add simple timing code that tracks the total time spent in each component over a realistic simulation. Then, plot a pie chart at the end to visualize where the most time is spent. A simple way to track execution time is using the <code>time package</code>.</p> Code example: Identify bottlenecks <pre><code>def run(self):\n    self.component_times = {component.__class__.__name__: 0 for component in self.components}\n    self.component_times[\"reporting\"] = 0\n    for tick in tqdm(range(self.pars.timesteps)):\n        for component in self.components:\n            start_time = time.time()  # Start timing for the component\n            component.step()\n            end_time = time.time()  # End timing for the component\n\n            # Accumulate the time taken for this component\n            elapsed_time = end_time - start_time\n            component_name = component.__class__.__name__\n</code></pre> <p>This often reveals the top one to three performance bottlenecks. Focus first on the biggest offender\u2014it provides the most opportunity for speedup. Often, the largest bottleneck is not what you might instinctively expect. Avoid optimizing a component only to find out it contributes just a small percentage of the total runtime. A modest improvement in the runtime of an \u201cexpensive\u201d component is often more effective than spending a lot of time on highly optimizing a component which only accounts for a small fraction of runtime. Also, make sure that your reporting code is being measured and reported, ideally in its own \u2018bucket\u2019. This may be easier or harder depending on how you are doing reporting. Since reporting usually involves counting over the entire population, it usually shows up as a hotspot sooner or later. Fortunately, it\u2019s usually fairly easy to speed up. Or even eliminate.</p>"},{"location":"get-started/optimization/#squash-save-and-load","title":"Squash, save, and load","text":"<p>As the number agents in your LASER population model grows (e.g., 1e8), it can become computationally expensive and unnecessary to repeatedly run the same initialization routine every sim. In many cases \u2014 particularly during model calibration \u2014 it is far more efficient to initialize the population once, save it, and then reload the initialized state for subsequent runs.</p> <p>This approach is especially useful when working with EULAs \u2013 Epidemiologically Uninteresting Light Agents. For example, it can be a very powerful optimization to compress all the agents who are already (permanently) recovered or immune in a measles or polio model into a number/bucket. In such models, the majority of the initial population may be in the \u201cRecovered\u201d state, potentially comprising 90% or more of all agents. If you are simulating 100 million agents, storing all of them can result in punitive memory usage.</p> <p>To address this, LASER supports a squashing process. Squashing involves defragmenting the data frame such that all epidemiologically active or \u201cinteresting\u201d agents (e.g., Susceptible or Infectious) are moved to the beginning of the array or table, and less relevant agents (e.g., Recovered) are moved to the end. Though please note that you should assume that squashed agent data is overwritten.</p> <p>Some notes about squashing:</p> <ul> <li>The population count is adjusted so that all for loops and step functions iterate only over the active population.</li> <li>This not only reduces memory usage but also improves performance by avoiding unnecessary computation over inactive agents.</li> </ul> <p>Some notes about using saved populations:</p> <ul> <li>You will want to be confident that the saved population is sufficiently randomized and representative of your overall population.</li> <li>If you are calibrating parameters used to create the initial population in the first place, you\u2019ll need to recreate those parts of the population after loading, diminishing the benefit of the save/load approach.</li> <li> <p>When saving a snapshot, note that only the active (unsquashed) portion of the population is saved. Upon reloading:</p> <ul> <li>Only this subset is allocated in memory.</li> <li>This prevents the performance penalty of managing large volumes of unused agent data.</li> </ul> </li> </ul> <p>Note</p> <p>Before squashing, you should count and record the number of recovered (or otherwise squashed) agents. This count should be stored in a summary variable \u2014- typically the R column of the results data frame. This ensures your model retains a complete epidemiological record even though the agents themselves are no longer instantiated.</p>"},{"location":"get-started/optimization/#procedure","title":"Procedure","text":"<ol> <li> <p>Add squashing:</p> <ul> <li>Add a <code>squash_recovered()</code> function. This should call <code>LaserFrame.squash(\u2026)</code> with a boolean mask that includes non-recovered agents (disease_state != 2). You may choose a different criterion, such as age-based squashing.</li> <li>Count your \u201csquashed away\u201d agents first. You must compute and store all statistics related to agents being squashed before the <code>squash()</code> call. After squashing, only the left-hand portion of the arrays (up to .count) remains valid.</li> <li>Seed infections after squashing. If your model seeds new infections (disease_state == 1), this must happen after squashing. Otherwise, infected agents may be inadvertently removed.</li> <li>Store the squashed-away totals by node. Before squashing, compute and record node-wise totals (e.g., recovered counts) in <code>results.R[0, :]</code> so this pre-squash information persists.</li> <li>(Optionally) simulate EULA effects once and save. If modeling aging or death among squashed agents, simulate this up front and store the full <code>[time, node]`` matrix (e.g.,</code>results.R[:, :]`). This avoids recomputation at runtime.</li> </ul> </li> <li> <p>Save function: implement a <code>save(path)</code> method:</p> <ul> <li>Use <code>LaserFrame.save_snapshot(path, results_r=..., pars=...)</code></li> <li>Include:<ul> <li>The squashed population (active agents only)</li> <li>The <code>results.R</code> matrix containing both pre-squash and live simulation values</li> <li>The full parameter set in a <code>PropertySet</code></li> </ul> </li> </ul> </li> <li> <p>Load function: implement a <code>load(path)</code> class method:</p> <ul> <li>Call <code>LaserFrame.load_snapshot(path)</code> to retrieve:<ul> <li>Population frame</li> <li>Results matrix</li> <li>Parameters</li> </ul> </li> <li>Set <code>.capacity = .count</code> if not doing births, else set capacity based on projected population growth from count.</li> <li>Reconstruct all components using <code>init_from_file()</code></li> </ul> <p>Warning</p> <p>When modeling vital dynamics, especially births, there is an additional step needed to ensure consistency after loading:</p> <p>Property initialization for unborn individuals must be repeated if your model pre-assigns properties up to <code>.capacity</code>. For example, if timers or demographic attributes (like <code>date_of_birth</code>) are pre-initialized at <code>t=0</code>, you must ensure this initialization is re-applied after loading, because only the <code>.count</code> population is reloaded, not the future <code>.capacity</code>.</p> <p>Failing to do so may result in improperly initialized agents being birthed after the snapshot load, which can lead to subtle or catastrophic model errors.</p> </li> <li> <p>Preserve EULA'd results:</p> <p>Use \"+=\" to track new recoveries alongside pre-squash R values. In <code>run()</code>, use additive updates so that pre-saved recovered agents are preserved:</p> <pre><code>self.results.R[t, nid] += ((self.population.node_id == nid) &amp;\n                       (self.population.disease_state == 2)).sum()\n</code></pre> <p>This ensures your output accounts for both squashed-away immunity and recoveries during the live simulation.</p> </li> </ol> Code example: Add squashing and snapshot support to SIR models <pre><code>import numpy as np\nimport click\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\nfrom laser.core import LaserFrame, PropertySet\n\nclass Transmission:\n    \"\"\"\n    A simple transmission component that spreads infection within each node.\n    \"\"\"\n    def __init__(self, population, pars):\n        self.population = population\n        self.pars = pars\n\n    def step(self):\n    \"\"\"\n    For each node in the population, calculate the number of new infections as a function of:\n    - the number of infected individuals,\n    - the number of susceptibles,\n    - adjustments for migration and seasonality,\n    - and individual-level heterogeneity.\n\n    Then, select new infections at random from among the susceptible individuals in each node,\n    and initiate infection in those individuals.\n    \"\"\"\n    pass  # Implementation omitted for documentation purposes\n\n    @classmethod\n    def init_from_file(cls, population, pars):\n        return cls(population, pars)\n\nclass Progression:\n    \"\"\"\n    A simple progression component that recovers infected individuals probabilistically.\n    \"\"\"\n    def __init__(self, population, pars):\n        self.population = population\n        self.pars = pars\n\n    def step(self):\n    \"\"\"\n    At each time step, update the disease state of infected individuals based on the model's\n    progression logic. This may be driven by probabilities, timers, or other intrahost dynamics.\n    \"\"\"\n    pass  # Implementation omitted for documentation\n\n    @classmethod\n    def init_from_file(cls, population, pars):\n        return cls(population, pars)\n\nclass RecoveredSquashModel:\n    \"\"\"\n    A simple multi-node SIR model demonstrating use of LASER's squash and snapshot mechanisms.\n    \"\"\"\n    def __init__(self, num_agents=100000, num_nodes=20, timesteps=365):\n        self.num_agents = num_agents\n        self.num_nodes = num_nodes\n        self.timesteps = timesteps\n        self.population = LaserFrame(capacity=num_agents, initial_count=num_agents)\n        self.population.add_scalar_property(\"node_id\", dtype=np.int32)\n        self.population.add_scalar_property(\"disease_state\", dtype=np.int8)  # 0=S, 1=I, 2=R\n\n        self.results = LaserFrame(capacity=self.num_nodes)\n        self.results.add_vector_property(\"S\", length=timesteps, dtype=np.int32)\n        self.results.add_vector_property(\"I\", length=timesteps, dtype=np.int32)\n        self.results.add_vector_property(\"R\", length=timesteps, dtype=np.int32)\n\n        self.pars = PropertySet({\n            \"r0\": 2.5,\n            \"migration_k\": 0.1,\n            \"seasonal_factor\": 0.8,\n            \"transmission_prob\": 0.2,\n            \"recovery_days\": 14\n        })\n\n        self.components = [\n            Transmission(self.population, self.pars),\n            Progression(self.population, self.pars)\n            # could add other components like vaccination\n        ]\n\n    def initialize(self):\n        np.random.seed(42)\n        self.population.node_id[:] = np.random.randint(0, self.num_nodes, size=self.num_agents)\n        recovered = np.random.rand(self.num_agents) &lt; 0.6\n        self.population.disease_state[:] = np.where(recovered, 2, 0)\n\n    def seed_infections(self):\n        susceptible = self.population.disease_state == 0\n        num_seed = max(1, int(0.001 * self.population.count))\n        seed_indices = np.random.choice(np.where(susceptible)[0], size=num_seed, replace=False)\n        self.population.disease_state[seed_indices] = 1\n\n    def squash_recovered(self):\n        \"\"\"\n        Removes all agents who are recovered (state 2).\n        This reduces memory footprint and speeds up simulation.\n        \"\"\"\n        keep = self.population.disease_state[:self.population.count] != 2\n        self.population.squash(keep)\n\n    def populate_results(self):\n        \"\"\"\n        Populate initial R values before squashing to reflect the pre-squash immunity landscape.\n        \"\"\"\n        for nid in range(self.num_nodes):\n            initial_r = ((self.population.disease_state == 2) &amp; (self.population.node_id == nid)).sum()\n            decay = np.linspace(initial_r, initial_r * 0.9, self.timesteps, dtype=int)\n            self.results.R[:, nid] = decay\n        print(\"Initial R counts per node:\", self.results.R[0, :])\n        print(\"Total initial R (summed):\", self.results.R[0, :].sum())\n\n    def run(self):\n        for t in range(self.timesteps):\n            for component in self.components:\n                component.step()\n            for nid in range(self.num_nodes):\n                self.results.S[t, nid] = ((self.population.node_id == nid) &amp; (self.population.disease_state == 0)).sum()\n                self.results.I[t, nid] = ((self.population.node_id == nid) &amp; (self.population.disease_state == 1)).sum()\n                self.results.R[t, nid] += ((self.population.node_id == nid) &amp; (self.population.disease_state == 2)).sum()\n\n    def save(self, path):\n        \"\"\"\n        Save the current model state to an HDF5 file, including population frame,\n        pre-squash results, and simulation parameters.\n        \"\"\"\n        self.population.save_snapshot(path, results_r=self.results.R, pars=self.pars)\n\n    @classmethod\n    def load(cls, path):\n        \"\"\"\n        Reload a model from an HDF5 snapshot. Note: reloaded population will have\n        only post-squash agents (e.g., susceptibles and infected).\n        \"\"\"\n        pop, results_r, pars = LaserFrame.load_snapshot(path)\n        model = cls(num_agents=pop.capacity, num_nodes=results_r.shape[1], timesteps=results_r.shape[0])\n        model.population = pop\n        model.results.R[:, :] = results_r\n        model.pars = PropertySet(pars)\n        model.pars[\"transmission_prob\"] /= 10  # example modification after reload\n        model.components = [\n            Transmission.init_from_file(model.population, model.pars),\n            Progression.init_from_file(model.population, model.pars)\n        ]\n        return model\n\n    def plot(self):\n        \"\"\"\n        Plot the time series of total S, I, and R across all nodes.\n        \"\"\"\n        # details omitted\n\n@click.command()\n@click.option(\"--init-pop-file\", type=click.Path(), default=None, help=\"Path to snapshot to resume from.\")\n@click.option(\"--output\", type=click.Path(), default=\"model_output.h5\")\ndef main(init_pop_file, output):\n    if init_pop_file:\n        model = RecoveredSquashModel.load(init_pop_file)\n        model.run()\n        model.plot()\n    else:\n        model = RecoveredSquashModel()\n        model.initialize()\n        model.seed_infections()\n        model.populate_results()\n        model.squash_recovered()\n        model.save(output)\n        print(f\"Initial population saved to {output}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"get-started/optimization/#leverage-ai","title":"Leverage AI","text":"<p>Once you have identified the slowest component, the easiest way to improve performance is by using ChatGPT. Try prompting with:</p> <p><code>\"This code is much too slow. (My arrays are all about 1e6 or 1e7 in size.)\"</code></p> <p>If your code consists mainly of for-loops without much NumPy, you can add:</p> <p><code>\"Is there anything we can vectorize better with NumPy?\"</code></p> <p>This approach can often transform a naive implementation into a highly optimized one.</p>"},{"location":"get-started/optimization/#implement-unit-tests","title":"Implement unit tests","text":"<p>Instead of testing performance within the full simulation, consider building unit tests. This ensures correctness while optimizing for speed.</p> <ul> <li>Use AI to generate unit tests that validate output against a known correct (but slower) version.</li> <li>Include performance benchmarks in the tests.</li> <li>Ensure large array sizes (e.g., 1 million+ elements) to get meaningful speed comparisons.</li> </ul>"},{"location":"get-started/optimization/#optimize-with-numpy-and-numba","title":"Optimize with NumPy and Numba","text":"<p>After achieving good performance with NumPy, consider trying Numba for further improvements.</p> <p>Even if you\u2019re new to Numba, ChatGPT can generate optimized solutions easily. Keep in mind:</p> <ul> <li>Numba moves back to explicit for-loops (unlike NumPy, which uses vectorization syntax).</li> <li>GPT\u2019s first solution may use <code>range</code> instead of <code>prange</code>. Prompt it with:     <code>\"Can we parallelize this with prange?\"</code></li> <li>If your code involves common counters, atomic operations may become a bottleneck. Ask GPT about:     <code>\"Can we use thread-local storage to avoid atomic operations?\"</code></li> <li>Numba may be slower than NumPy for small arrays (e.g., thousands or tens of thousands of elements). Test with at least 1 million elements.</li> </ul>"},{"location":"get-started/optimization/#c-and-openmp","title":"C and OpenMP","text":"<p>If the best Numba solution still isn\u2019t fast enough, consider compiled C.</p> <ul> <li>Use ctypes to call C functions from Python.</li> <li>Mention \u201cuse OpenMP\u201d in AI prompts if parallelization is possible.</li> <li>Ask: <code>\"Can you generate an OpenMP solution with the best pragmas?\"</code></li> <li>The more CPU cores available, the greater the potential speedup. That said, it\u2019s usually a case of diminishing returns as one goes from 8 cores to 16 and to 32. Our research shows that often you\u2019re better off running 4 sims across 8 cores each than running 1 sim on all 32 cores available. Also be aware that with both Numba and OpenMP you can constrain the number of cores used to less than the number available by setting the appropriate environment variable. (Numba environment variable = NUMBA_NUM_THREADS; OpenMP environment variable = OMP_NUM_THREADS)</li> </ul>"},{"location":"get-started/optimization/#additional-advice","title":"Additional advice","text":"<ul> <li> <p>Don\u2019t duplicate. Sometimes reporting will duplicate transmission code and need to be combined.</p> </li> <li> <p>Never append. There may be cases where you are collecting information as it happens without knowing ahead of time how many rows/entries/elements you\u2019ll need. This is easy in Python using list appending, for example, but that\u2019s a performance killer. Really try to find a way to figure out ahead of time how many entries there will be, and then allocate memory for that, and insert into the existing row.</p> </li> <li> <p>Some components have long timescales, like mortality. By default you are probably going to end up doing most component steps every timestep. You can probably get away with doing mortality updates, for example, far less often. You can experiment with weekly, fortnightly or monthly updates, depending on the timescale of the component you\u2019re optimizing. Just be sure to move everything forward by a week if you\u2019re only doing the update every week. And expect \u201cblocky\u201d plots. Note that there are fancier solutions like \u2018strided sharding\u2019 (details omitted).</p> </li> <li> <p>When prompting AI, use questions rather than directives. For example:</p> <p><code>\"Do you think it might be better to...?\"</code></p> <p>This prevents oversteering the AI into sub-optimal solutions.</p> </li> </ul>"},{"location":"reference/SUMMARY/","title":"API reference","text":"<ul> <li>laser.core</li> <li>laser.core.main</li> <li>laser.core.cli</li> <li>laser.core.demographics<ul> <li>laser.core.demographics.kmestimator</li> <li>laser.core.demographics.pyramid</li> <li>laser.core.demographics.spatialpops</li> </ul> </li> <li>laser.core.distributions</li> <li>laser.core.extension</li> <li>laser.core.laserframe</li> <li>laser.core.migration</li> <li>laser.core.propertyset</li> <li>laser.core.random</li> <li>laser.core.sortedqueue</li> <li>laser.core.utils</li> <li>laser.generic</li> <li>laser.generic.SEIR</li> <li>laser.generic.SEIRS</li> <li>laser.generic.SI</li> <li>laser.generic.SIR</li> <li>laser.generic.SIRS</li> <li>laser.generic.SIS</li> <li>laser.generic.components</li> <li>laser.generic.immunization</li> <li>laser.generic.importation</li> <li>laser.generic.model</li> <li>laser.generic.shared</li> <li>laser.generic.utils</li> <li>laser.generic.vitaldynamics</li> </ul>"},{"location":"reference/laser/","title":"laser","text":"<p>Root namespace for LASER packages.</p>"},{"location":"reference/laser/core/","title":"laser.core","text":""},{"location":"reference/laser/core/#laser.core","title":"<code>laser.core</code>","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame","title":"<code>laser.core.LaserFrame(capacity, initial_count=-1, **kwargs)</code>","text":"<p>The LaserFrame class, similar to a db table or a Pandas DataFrame, holds dynamically allocated data for agents (generally 1-D or scalar) or for nodes|patches (e.g., 1-D for scalar value per patch or 2-D for time-varying per patch).</p> <p>Initialize a LaserFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int</code> <p>The maximum capacity of the frame.             Must be a positive integer.</p> required <code>initial_count</code> <code>int</code> <p>The initial number of active elements in the frame.                  Must be a positive integer &lt;= capacity.</p> <code>-1</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to set as attributes of the object.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If capacity or initial_count is not a positive integer,         or if initial_count is greater than capacity.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.capacity","title":"<code>laser.core.LaserFrame.capacity</code>  <code>property</code>","text":"<p>Returns the capacity of the laser frame (total possible entries for dynamic properties).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The capacity of the laser frame.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.count","title":"<code>laser.core.LaserFrame.count</code>  <code>property</code>","text":"<p>Returns the current count (equivalent to len()).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current count value.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add","title":"<code>laser.core.LaserFrame.add(count)</code>","text":"<p>Adds the specified count to the current count of the LaserFrame.</p> <p>This method increments the internal count by the given count, ensuring that the total does not exceed the frame's capacity. If the addition would exceed the capacity, an assertion error is raised. This method is typically used to add new births during the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number to add to the current count.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: A tuple containing the [start index, end index) after the addition.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the resulting count exceeds the frame's capacity.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add_array_property","title":"<code>laser.core.LaserFrame.add_array_property(name, shape, dtype=np.uint32, default=0)</code>","text":"<p>Adds an array property to the object.</p> <p>This method initializes a new property with the given name as a multi-dimensional NumPy array.</p> <p>The array will have the given shape (note that there is no implied dimension of size self._capacity), datatype (default is np.uint32), and default value (default is 0).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the property to be added.</p> required <code>shape</code> <code>tuple</code> <p>The shape of the array.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data-type for the array, default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value to fill the array with, default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add_scalar_property","title":"<code>laser.core.LaserFrame.add_scalar_property(name, dtype=np.uint32, default=0)</code>","text":"<p>Add a scalar property to the class.</p> <p>This method initializes a new scalar property for the class instance. The property is stored as a 1-D NumPy array (scalar / entry) with a specified data type and default value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the scalar property to be added.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data type for the property. Default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value for the property. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add_vector_property","title":"<code>laser.core.LaserFrame.add_vector_property(name, length, dtype=np.uint32, default=0)</code>","text":"<p>Adds a vector property to the object.</p> <p>This method initializes a new property with the given name as a 2-D NumPy array (vector per entry).</p> <p>The array will have a shape of (length, self._capacity) and will be filled with the specified default value. The data type of the array elements is determined by the <code>dtype</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the property to be added.</p> required <code>length</code> <code>int</code> <p>The length of the vector.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data-type for the array, default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value to fill the array with, default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.describe","title":"<code>laser.core.LaserFrame.describe(target=None)</code>","text":"<p>Return a formatted string description of the laserframe object, including its attributes and their values.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>string</code> <p>Optional string for the report header (generally the name of the LaserFrame variable, e.g., \"People\". Unlike functions, we can't get the name of a variable automatically).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string describing the laserframe object, including its capacity, count, and  details of its scalar, vector, and other properties.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.load_snapshot","title":"<code>laser.core.LaserFrame.load_snapshot(path, n_ppl, cbr, nt)</code>  <code>classmethod</code>","text":"<p>Load a LaserFrame and optional extras from an HDF5 snapshot file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the HDF5 snapshot file.</p> required <code>n_ppl</code> <code>float or array - like</code> <p>Original total population (or per-node array) used to estimate births.</p> required <code>cbr</code> <code>float or array - like</code> <p>Crude birth rate (per 1000/year).</p> required <code>nt</code> <code>int</code> <p>Simulation duration (number of ticks).</p> required <p>Returns:</p> Name Type Description <code>frame</code> <code>LaserFrame</code> <p>Loaded LaserFrame object.</p> <code>results_r</code> <code>ndarray or None</code> <p>Optional 2D numpy array of recovered counts.</p> <code>pars</code> <code>dict or None</code> <p>Optional dictionary of parameters.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.save_snapshot","title":"<code>laser.core.LaserFrame.save_snapshot(path, results_r=None, pars=None)</code>","text":"<p>Save this LaserFrame and optional extras to an HDF5 snapshot file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Destination file path</p> required <code>results_r</code> <code>ndarray</code> <p>Optional 2D numpy array of recovered counts</p> <code>None</code> <code>pars</code> <code>PropertySet or dict</code> <p>Optional PropertySet or dict of parameters</p> <code>None</code>"},{"location":"reference/laser/core/#laser.core.LaserFrame.sort","title":"<code>laser.core.LaserFrame.sort(indices, verbose=False)</code>","text":"<p>Sorts the elements of the object's numpy arrays based on the provided indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>ndarray</code> <p>An array of indices used to sort the numpy arrays. Must be of integer type and have the same length as the frame count (<code>self._count</code>).</p> required <code>verbose</code> <code>bool</code> <p>If True, prints the sorting progress for each numpy array attribute. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>indices</code> is not an integer array or if its length does not match the frame count of active elements.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.squash","title":"<code>laser.core.LaserFrame.squash(indices, verbose=False)</code>","text":"<p>Reduces the active count of the internal numpy arrays keeping only elements True in the provided boolean indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>ndarray</code> <p>A boolean array indicating which elements to keep. Must have the same length as the current frame active element count.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints detailed information about the squashing process. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>indices</code> is not a boolean array or if its length does not match the current frame active element count.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/#laser.core.PropertySet","title":"<code>laser.core.PropertySet(*bags)</code>","text":"<p>A class that can be used to store properties in a dictionary-like object with <code>.property</code> access to properties.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet--examples","title":"Examples","text":"<p>Basic Initialization:</p> <pre><code>from laser.core import PropertySet\nps = PropertySet()\nps['infection_status'] = 'infected'\nps['age'] = 35\nprint(ps.infection_status)  # Outputs: 'infected'\nprint(ps['age'])            # Outputs: 35\n</code></pre> <p>Combining two PropertySets:</p> <pre><code>ps1 = PropertySet({'immunity': 'high', 'region': 'north'})\nps2 = PropertySet({'infectivity': 0.7})\ncombined_ps = ps1 + ps2\nprint(combined_ps.to_dict())\n# Outputs: {'immunity': 'high', 'region': 'north', 'infectivity': 0.7}\n</code></pre> <p>Creating a PropertySet from a dictionary:</p> <pre><code>ps = PropertySet({'mything': 0.4, 'that_other_thing': 42})\nprint(ps.mything)            # Outputs: 0.4\nprint(ps.that_other_thing)   # Outputs: 42\nprint(ps.to_dict())\n# Outputs: {'mything': 0.4, 'that_other_thing': 42}\n</code></pre> <p>Save and load:</p> <pre><code>ps.save('properties.json')\nloaded_ps = PropertySet.load('properties.json')\nprint(loaded_ps.to_dict())  # Outputs the saved properties\n</code></pre> <p>Property access and length:</p> <pre><code>ps['status'] = 'susceptible'\nps['exposure_timer'] = 5\nprint(ps['status'])          # Outputs: 'susceptible'\nprint(len(ps))               # Outputs: 4\n</code></pre> <p>In-Place addition (added keys must not exist in the destination PropertySet):</p> <pre><code>ps += {'new_timer': 10, 'susceptibility': 0.75}\nprint(ps.to_dict())\n# Outputs: {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 5, 'new_timer': 10, 'susceptibility': 0.75}\n</code></pre> <p>In-place update (keys must already exist in the destination PropertySet):</p> <pre><code>ps &lt;&lt;= {'exposure_timer': 10, 'infectivity': 0.8}\nprint(ps.to_dict())\n# Outputs: {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 10, 'infectivity': 0.8}\n</code></pre> <p>In-place addition or update (no restriction on incoming keys):</p> <pre><code>ps |= {'new_timer': 10, 'exposure_timer': 8}\nprint(ps.to_dict())\n# Outputs: {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 8, 'new_timer': 10}\n</code></pre> <p>Initialize a PropertySet to manage properties in a dictionary-like structure.</p> <p>Parameters:</p> Name Type Description Default <code>bags</code> <code>Union[PropertySet, list, tuple, dict]</code> <p>A sequence of key-value pairs (e.g., lists, tuples, dictionaries) to initialize the PropertySet. Keys must be strings, and values can be any type.</p> <code>()</code>"},{"location":"reference/laser/core/#laser.core.PropertySet.__add__","title":"<code>laser.core.PropertySet.__add__(other)</code>","text":"<p>Add another PropertySet to this PropertySet.</p> <p>This method allows the use of the <code>+</code> operator to combine two PropertySet instances.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PropertySet</code> <p>The other PropertySet instance to add.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <code>PropertySet</code> <p>A new PropertySet instance that combines the properties of both instances.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__contains__","title":"<code>laser.core.PropertySet.__contains__(key)</code>","text":"<p>Check if a key is in the property set.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check for existence in the property set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists in the property set, False otherwise.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__eq__","title":"<code>laser.core.PropertySet.__eq__(other)</code>","text":"<p>Check if two PropertySet instances are equal.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PropertySet</code> <p>The other PropertySet instance to compare.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the two instances are equal, False otherwise.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__getitem__","title":"<code>laser.core.PropertySet.__getitem__(key)</code>","text":"<p>Retrieve the attribute of the object with the given key (e.g., <code>ps[key]</code>).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the attribute to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>any</code> <p>The value of the attribute with the specified key.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute with the specified key does not exist.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__iadd__","title":"<code>laser.core.PropertySet.__iadd__(other)</code>","text":"<p>Implements the in-place addition (<code>+=</code>) operator for the class.</p> <p>This method allows the instance to be updated with attributes from another instance of the same class or from a dictionary. If <code>other</code> is an instance of the same class, its attributes are copied to the current instance. If <code>other</code> is a dictionary, its key-value pairs are added as attributes to the current instance.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary to add to the current instance.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>PropertySet</code> <p>The updated instance with the new attributes.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys already present in the PropertySet.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__ilshift__","title":"<code>laser.core.PropertySet.__ilshift__(other)</code>","text":"<p>Implements the <code>&lt;&lt;=</code> operator on PropertySet to override existing values with new values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>PropertySet</code> <p>The updated instance with the overrides from other.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys not present in the PropertySet.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__ior__","title":"<code>laser.core.PropertySet.__ior__(other)</code>","text":"<p>Implements the <code>|=</code> operator on PropertySet to override existing values with new values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>PropertySet</code> <p>The updated instance with all the values of self with new or overriding values from other.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__len__","title":"<code>laser.core.PropertySet.__len__()</code>","text":"<p>Return the number of attributes in the instance.</p> <p>This method returns the number of attributes stored in the instance's dict attribute, which represents the instance's namespace.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of attributes in the instance.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__lshift__","title":"<code>laser.core.PropertySet.__lshift__(other)</code>","text":"<p>Implements the <code>&lt;&lt;</code> operator on PropertySet to override existing values with new values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <code>PropertySet</code> <p>A new PropertySet with all the values of the first PropertySet with overrides from the second PropertySet.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys not present in the PropertySet.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__or__","title":"<code>laser.core.PropertySet.__or__(other)</code>","text":"<p>Implements the <code>|</code> operator on PropertySet to add new or override existing values with new values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <code>PropertySet</code> <p>A new PropertySet with all the values of the first PropertySet with new or overriding values from the second PropertySet.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__repr__","title":"<code>laser.core.PropertySet.__repr__()</code>","text":"<p>Return a string representation of the PropertySet instance.</p> <p>The string representation includes the class name and the dictionary of the instance's attributes.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the PropertySet instance.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__setitem__","title":"<code>laser.core.PropertySet.__setitem__(key, value)</code>","text":"<p>Set the value of an attribute. This method allows setting an attribute of the instance using the dictionary-like syntax (e.g., <code>ps[key] = value</code>).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the attribute to set.</p> required <code>value</code> <code>any</code> <p>The value to set for the attribute.</p> required"},{"location":"reference/laser/core/#laser.core.PropertySet.__str__","title":"<code>laser.core.PropertySet.__str__()</code>","text":"<p>Returns a string representation of the object's dictionary.</p> <p>This method is used to provide a human-readable string representation of the object, which includes all the attributes stored in the object's <code>__dict__</code>.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the object's dictionary.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.load","title":"<code>laser.core.PropertySet.load(filename)</code>  <code>staticmethod</code>","text":"<p>Load a PropertySet from a specified file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the file where the PropertySet is saved.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <code>PropertySet</code> <p>The PropertySet instance loaded from the file.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.save","title":"<code>laser.core.PropertySet.save(filename)</code>","text":"<p>Save the PropertySet to a specified file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the file where the PropertySet will be saved.</p> required"},{"location":"reference/laser/core/#laser.core.PropertySet.to_dict","title":"<code>laser.core.PropertySet.to_dict()</code>","text":"<p>Convert the PropertySet to a dictionary.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue","title":"<code>laser.core.SortedQueue(capacity, values)</code>","text":"<p>A sorted (priority) queue implemented using NumPy arrays and sped-up with Numba.</p> <p>Using the algorithm from the Python heapq module.</p> <p>init with an existing array of sorting values</p> <p>push with an index into sorting values</p> <p>pop returns the index of the lowest sorting value and its value</p> <p>Initializes a new instance of the class with a specified capacity and reference to existing, sortable values.</p> <p>This implementation is specific to LASER and the expectation of tracking 10s or 100s of millions of agents.</p> <p>We expect the sortable (or priority) values to already be in a NumPy array, usually a property of a LaserFrame object.</p> <p>The <code>push()</code> and <code>pop()</code> will take indices into this array and will sort on values[i]. This avoids making copies of the sort values.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int</code> <p>The maximum number of elements the queue can hold.</p> required <code>values</code> <code>ndarray</code> <p>A reference to an array of values to be accessed by the queue.</p> required"},{"location":"reference/laser/core/#laser.core.SortedQueue.__len__","title":"<code>laser.core.SortedQueue.__len__()</code>","text":"<p>Return the number of elements in the sorted queue.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the sorted queue.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.__pop","title":"<code>laser.core.SortedQueue.__pop()</code>","text":"<p>Removes the smallest value element from the sorted queue.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> Side effects <ul> <li>Decreases the size of the sorted queue by one.</li> <li>Reorganizes the internal structure of the sorted queue to maintain the heap property.</li> </ul>"},{"location":"reference/laser/core/#laser.core.SortedQueue.peeki","title":"<code>laser.core.SortedQueue.peeki()</code>","text":"<p>Returns the index of the smallest value element in the sorted queue without removing it.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> <p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: The index of the smallest value element.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.peekiv","title":"<code>laser.core.SortedQueue.peekiv()</code>","text":"<p>Returns the index and value of the smallest value element in the sorted queue without removing it.</p> <p>Returns:</p> Type Description <code>tuple[uint32, Any]</code> <p>tuple[np.uint32, Any]: A tuple containing the index and value of the smallest value element.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.peekv","title":"<code>laser.core.SortedQueue.peekv()</code>","text":"<p>Return the smallest value from the sorted queue without removing it.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value with the smallest value in the sorted queue.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.popi","title":"<code>laser.core.SortedQueue.popi()</code>","text":"<p>Removes and returns the index of the smallest value element in the sorted queue.</p> <p>This method first retrieves the index of the smallest value element using <code>peeki()</code>, then removes the element from the queue using <code>pop()</code>, and finally returns the index.</p> <p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: The index of the smallest value element in the sorted queue.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.popiv","title":"<code>laser.core.SortedQueue.popiv()</code>","text":"<p>Removes and returns the index and value of the smallest value element in the sorted queue.</p> <p>This method first retrieves the index and value of the smallest value element using <code>peekiv()</code>, then removes the element from the queue using <code>pop()</code>, and finally returns the index and value.</p> <p>Returns:</p> Type Description <code>tuple[uint32, Any]</code> <p>tuple[np.uint32, Any]: A tuple containing the index and value of the smallest value element.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.popv","title":"<code>laser.core.SortedQueue.popv()</code>","text":"<p>Removes and returns the value at the front of the sorted queue.</p> <p>This method first retrieves the value at the front of the queue without removing it by calling <code>peekv()</code>, and then removes the front element from the queue by calling <code>pop()</code>. The retrieved value is then returned.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value at the front of the sorted queue.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.push","title":"<code>laser.core.SortedQueue.push(index)</code>","text":"<p>Insert an element into the sorted queue.</p> <p>This method adds an element at the back of the sorted queue and then ensures the heap property is maintained by sifting the element forward to its correct position.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the element to be added to the sorted queue.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is full.</p>"},{"location":"reference/laser/core/__main__/","title":"laser.core.main","text":""},{"location":"reference/laser/core/__main__/#laser.core.__main__","title":"<code>laser.core.__main__</code>","text":"<p>Entrypoint module, in case you use <code>python -midmlaser</code>.</p> <p>Why does this file exist, and why main? For more info, read:</p> <ul> <li>https://www.python.org/dev/peps/pep-0338/</li> <li>https://docs.python.org/2/using/cmdline.html#cmdoption-m</li> <li>https://docs.python.org/3/using/cmdline.html#cmdoption-m</li> </ul>"},{"location":"reference/laser/core/cli/","title":"laser.core.cli","text":""},{"location":"reference/laser/core/cli/#laser.core.cli","title":"<code>laser.core.cli</code>","text":"<p>Module that contains the command line app.</p> <p>Why does this file exist, and why not put this in main?</p> <p>You might be tempted to import things from main later, but that will cause   problems: the code will get executed twice:</p> <ul> <li>When you run <code>python -midmlaser</code> python will execute     <code>__main__.py</code> as a script. That means there will not be any     <code>idmlaser.__main__</code> in <code>sys.modules</code>.</li> <li>When you import main it will get executed again (as a module) because     there\"s no <code>idmlaser.__main__</code> in <code>sys.modules</code>.</li> </ul> <p>Also see (1) from https://click.palletsprojects.com/en/stable/setuptools/</p>"},{"location":"reference/laser/core/demographics/","title":"laser.core.demographics","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics","title":"<code>laser.core.demographics</code>","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.AliasedDistribution","title":"<code>laser.core.demographics.AliasedDistribution(counts)</code>","text":"<p>A class to generate samples from a distribution using the Vose alias method.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.AliasedDistribution.sample","title":"<code>laser.core.demographics.AliasedDistribution.sample(count=1, dtype=np.int32)</code>","text":"<p>Generate samples from the distribution.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of samples to generate. Default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>int</code> <p>int or numpy.ndarray: A single integer if count is 1, otherwise an array of integers representing the generated samples.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator","title":"<code>laser.core.demographics.KaplanMeierEstimator(source)</code>","text":"<p>Initializes the KMEstimator with the given source data.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>(ndarray, list, Path, str)</code> <p>The source data for the KMEstimator.</p> <ul> <li>A numpy array of unsigned 32-bit integers.</li> <li>A list of integers.</li> <li>A Path object pointing to a file containing the data.</li> <li>A string representing the file path.</li> </ul> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the provided file path does not exist or is not a file.</p> <code>TypeError</code> <p>If the source type is not one of the accepted types (np.ndarray, list, Path, str).</p> <code>ValueError</code> <p>If the source inputs contain negative values or are not monotonically non-decreasing.</p> Notes <ul> <li>If the source is a file path, the file should contain comma-separated values with the data in the second column.</li> <li>The source data is converted to a numpy array of unsigned 32-bit integers.</li> </ul>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.cumulative_deaths","title":"<code>laser.core.demographics.KaplanMeierEstimator.cumulative_deaths</code>  <code>property</code>","text":"<p>Returns the original source data.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_age_at_death","title":"<code>laser.core.demographics.KaplanMeierEstimator.predict_age_at_death(ages_days, max_year=None)</code>","text":"<p>Calculate the predicted age at death (in days) based on the given ages in days.</p> <p>Parameters:</p> Name Type Description Default <code>ages_days</code> <code>ndarray</code> <p>The ages of the individuals in days.</p> required <code>max_year</code> <code>int</code> <p>The maximum year to consider for calculating the predicted year of death. Default is None, which uses the maximum year from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>age_at_death</code> <code>ndarray</code> <p>The predicted days of death.</p> Example <pre><code>predict_age_at_death(np.array([40*365, 50*365, 60*365]), max_year=80) # returns something like array([22732, 26297, 29862])\n</code></pre>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_year_of_death","title":"<code>laser.core.demographics.KaplanMeierEstimator.predict_year_of_death(ages_years, max_year=None)</code>","text":"<p>Calculate the predicted year of death based on the given ages in years.</p> <p>Parameters:</p> Name Type Description Default <code>ages_years</code> <code>ndarray</code> <p>The ages of the individuals in years.</p> required <code>max_year</code> <code>int</code> <p>The maximum year to consider for calculating the predicted year of death. Default is None, which uses the maximum year from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>year_of_death</code> <code>ndarray</code> <p>The predicted years of death.</p> Example <pre><code>predict_year_of_death(np.array([40, 50, 60]), max_year=80) # returns something like array([62, 72, 82])\n</code></pre>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.sample","title":"<code>laser.core.demographics.KaplanMeierEstimator.sample(current, max_index=None)</code>","text":"<p>Similar to <code>predict_year_of_death</code>, but operates on indices rather than years. This method predicts the expiration (death) index for each individual, given their current index.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>ndarray</code> <p>The current indices of the individuals.</p> required <code>max_index</code> <code>int</code> <p>The maximum index to consider for calculating the predicted expiration. Default is None, which uses the maximum index from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>predictions</code> <code>ndarray</code> <p>The predicted expiration indices for each individual.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.load_pyramid_csv","title":"<code>laser.core.demographics.load_pyramid_csv(file, verbose=False)</code>","text":"<p>Load a CSV file with population pyramid data and return it as a NumPy array.</p> <p>The CSV file is expected to have the following schema:</p> <ul> <li>The first line is a header: \"Age,M,F\"</li> <li>Subsequent lines contain age ranges and population counts for males and females:</li> </ul> <p><pre><code>\"low-high,#males,#females\"\n...\n\"max+,#males,#females\"\n</code></pre> Where low, high, males, females, and max are integer values &gt;= 0.</p> <p>The function processes the CSV file to create a NumPy array with the following columns:</p> <ul> <li>Start age of the range</li> <li>End age of the range</li> <li>Number of males</li> <li>Number of females</li> </ul> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The path to the CSV file.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints the file reading status. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A NumPy array with the processed population pyramid data.</p>"},{"location":"reference/laser/core/demographics/kmestimator/","title":"laser.core.demographics.kmestimator","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator","title":"<code>laser.core.demographics.kmestimator</code>","text":"<p>This module provides the KaplanMeierEstimator class for predicting the year and age at death based on given ages and cumulative death data.</p> <p>Classes:</p> Name Description <code>- KaplanMeierEstimator</code> <p>A class to perform Kaplan-Meier estimation for predicting the year and age at death.</p> <p>Functions:</p> Name Description <code>- _pyod</code> <p>np.ndarray, cumulative_deaths: np.ndarray, max_year: np.uint32 = 100): Calculate the predicted year of death based on the given ages in years.</p> <code>- _pdod</code> <p>np.ndarray, year_of_death: np.ndarray, day_of_death: np.ndarray): Calculate the predicted day of death based on the given ages in days and predicted years of death.</p> Usage example <pre><code>estimator = KaplanMeierEstimator(cumulative_deaths=np.array([...]))\nyear_of_death = estimator.predict_year_of_death(np.array([40, 50, 60]), max_year=80)\nage_at_death = estimator.predict_age_at_death(np.array([40*365, 50*365, 60*365]), max_year=80)\n</code></pre>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator","title":"<code>laser.core.demographics.kmestimator.KaplanMeierEstimator(source)</code>","text":"<p>Initializes the KMEstimator with the given source data.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>(ndarray, list, Path, str)</code> <p>The source data for the KMEstimator.</p> <ul> <li>A numpy array of unsigned 32-bit integers.</li> <li>A list of integers.</li> <li>A Path object pointing to a file containing the data.</li> <li>A string representing the file path.</li> </ul> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the provided file path does not exist or is not a file.</p> <code>TypeError</code> <p>If the source type is not one of the accepted types (np.ndarray, list, Path, str).</p> <code>ValueError</code> <p>If the source inputs contain negative values or are not monotonically non-decreasing.</p> Notes <ul> <li>If the source is a file path, the file should contain comma-separated values with the data in the second column.</li> <li>The source data is converted to a numpy array of unsigned 32-bit integers.</li> </ul>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.cumulative_deaths","title":"<code>laser.core.demographics.kmestimator.KaplanMeierEstimator.cumulative_deaths</code>  <code>property</code>","text":"<p>Returns the original source data.</p>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_age_at_death","title":"<code>laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_age_at_death(ages_days, max_year=None)</code>","text":"<p>Calculate the predicted age at death (in days) based on the given ages in days.</p> <p>Parameters:</p> Name Type Description Default <code>ages_days</code> <code>ndarray</code> <p>The ages of the individuals in days.</p> required <code>max_year</code> <code>int</code> <p>The maximum year to consider for calculating the predicted year of death. Default is None, which uses the maximum year from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>age_at_death</code> <code>ndarray</code> <p>The predicted days of death.</p> Example <pre><code>predict_age_at_death(np.array([40*365, 50*365, 60*365]), max_year=80) # returns something like array([22732, 26297, 29862])\n</code></pre>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_year_of_death","title":"<code>laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_year_of_death(ages_years, max_year=None)</code>","text":"<p>Calculate the predicted year of death based on the given ages in years.</p> <p>Parameters:</p> Name Type Description Default <code>ages_years</code> <code>ndarray</code> <p>The ages of the individuals in years.</p> required <code>max_year</code> <code>int</code> <p>The maximum year to consider for calculating the predicted year of death. Default is None, which uses the maximum year from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>year_of_death</code> <code>ndarray</code> <p>The predicted years of death.</p> Example <pre><code>predict_year_of_death(np.array([40, 50, 60]), max_year=80) # returns something like array([62, 72, 82])\n</code></pre>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.sample","title":"<code>laser.core.demographics.kmestimator.KaplanMeierEstimator.sample(current, max_index=None)</code>","text":"<p>Similar to <code>predict_year_of_death</code>, but operates on indices rather than years. This method predicts the expiration (death) index for each individual, given their current index.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>ndarray</code> <p>The current indices of the individuals.</p> required <code>max_index</code> <code>int</code> <p>The maximum index to consider for calculating the predicted expiration. Default is None, which uses the maximum index from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>predictions</code> <code>ndarray</code> <p>The predicted expiration indices for each individual.</p>"},{"location":"reference/laser/core/demographics/pyramid/","title":"laser.core.demographics.pyramid","text":""},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid","title":"<code>laser.core.demographics.pyramid</code>","text":"<p>A class for generating samples from a distribution using the Vose alias method.</p>"},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.AliasedDistribution","title":"<code>laser.core.demographics.pyramid.AliasedDistribution(counts)</code>","text":"<p>A class to generate samples from a distribution using the Vose alias method.</p>"},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.AliasedDistribution.sample","title":"<code>laser.core.demographics.pyramid.AliasedDistribution.sample(count=1, dtype=np.int32)</code>","text":"<p>Generate samples from the distribution.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of samples to generate. Default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>int</code> <p>int or numpy.ndarray: A single integer if count is 1, otherwise an array of integers representing the generated samples.</p>"},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.load_pyramid_csv","title":"<code>laser.core.demographics.pyramid.load_pyramid_csv(file, verbose=False)</code>","text":"<p>Load a CSV file with population pyramid data and return it as a NumPy array.</p> <p>The CSV file is expected to have the following schema:</p> <ul> <li>The first line is a header: \"Age,M,F\"</li> <li>Subsequent lines contain age ranges and population counts for males and females:</li> </ul> <p><pre><code>\"low-high,#males,#females\"\n...\n\"max+,#males,#females\"\n</code></pre> Where low, high, males, females, and max are integer values &gt;= 0.</p> <p>The function processes the CSV file to create a NumPy array with the following columns:</p> <ul> <li>Start age of the range</li> <li>End age of the range</li> <li>Number of males</li> <li>Number of females</li> </ul> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The path to the CSV file.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints the file reading status. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A NumPy array with the processed population pyramid data.</p>"},{"location":"reference/laser/core/demographics/spatialpops/","title":"laser.core.demographics.spatialpops","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops","title":"<code>laser.core.demographics.spatialpops</code>","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed","title":"<code>laser.core.demographics.spatialpops.distribute_population_skewed(tot_pop, num_nodes, frac_rural=0.3)</code>","text":"<p>Calculate the population distribution across a number of nodes based on a total population, the number of nodes, and the fraction of the population assigned to rural nodes.</p> <p>The function generates a list of node populations distributed according to a simple exponential random distribution, with adjustments to ensure the sum matches the total population and the specified fraction of rural population is respected.</p> <p>Parameters:</p> Name Type Description Default <code>tot_pop</code> <code>int</code> <p>The total population to be distributed across the nodes.</p> required <code>num_nodes</code> <code>int</code> <p>The total number of nodes among which the population will be distributed.</p> required <code>frac_rural</code> <code>float</code> <p>The fraction of the total population to be assigned to rural nodes (value between 0 and 1). Defaults to 0.3. The 0 node is the single urban node and has (1 - frac_rural) of the population.</p> <code>0.3</code> <p>Returns:</p> Type Description <code>list[int]</code> <p>A list of integers representing the population at each node. The sum of the list equals <code>tot_pop</code>.</p> Notes <ul> <li>The population distribution is weighted using an exponential random   distribution to create heterogeneity among node populations.</li> <li>Adjustments are made to ensure the total fraction assigned to rural   nodes adheres to <code>frac_rural</code>.</li> </ul>"},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed--examples","title":"Examples","text":"<p>from laser.core.demographics.spatialpops import distribute_population_skewed np.random.seed(42)  # For reproducibility tot_pop = 1000 num_nodes = 5 frac_rural = 0.3 distribute_population_skewed(tot_pop, num_nodes, frac_rural) [700, 154, 64, 54, 28]</p> <p>tot_pop = 500 num_nodes = 3 frac_rural = 0.4 distribute_population_skewed(tot_pop, num_nodes, frac_rural) [300, 136, 64]</p>"},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_tapered","title":"<code>laser.core.demographics.spatialpops.distribute_population_tapered(tot_pop, num_nodes)</code>","text":"<p>Distribute a total population heterogeneously across a given number of nodes.</p> <p>The distribution follows a logarithmic-like decay pattern where the first node (Node 0) receives the largest share of the population, approximately half the total population. Subsequent nodes receive progressively smaller populations, ensuring that even the smallest node has a non-negligible share.</p> <p>The function ensures the sum of the distributed populations matches the <code>tot_pop</code> exactly by adjusting the largest node if rounding introduces discrepancies.</p> <p>Parameters:</p> Name Type Description Default <code>tot_pop</code> <code>int</code> <p>The total population to distribute. Must be a positive integer.</p> required <code>num_nodes</code> <code>int</code> <p>The number of nodes to distribute the population across. Must be a positive integer.</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>A 1D array of integers where each element represents the population assigned to a specific node. The length of the array is equal to <code>num_nodes</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>tot_pop</code> or <code>num_nodes</code> is not greater than 0.</p> Notes <ul> <li>The logarithmic-like distribution ensures that Node 0 has the highest population,   and subsequent nodes receive progressively smaller proportions.</li> <li>The function guarantees that the sum of the returned array equals <code>tot_pop</code>.</li> </ul> <p>Examples:</p> <pre><code>Distribute a total population of 1000 across 5 nodes::\n\n    &gt;&gt;&gt; from laser.core.demographics.spatialpops import distribute_population_tapered\n    &gt;&gt;&gt; distribute_population_tapered(1000, 5)\n    array([500, 250, 125, 75, 50])\n\nDistribute a total population of 1200 across 3 nodes::\n\n    &gt;&gt;&gt; distribute_population_tapered(1200, 3)\n    array([600, 400, 200])\n\nHandling a small total population with more nodes::\n\n    &gt;&gt;&gt; distribute_population_tapered(10, 4)\n    array([5, 3, 2, 0])\n\nEnsuring the distribution adds up to the total population::\n\n    &gt;&gt;&gt; pop = distribute_population_tapered(1000, 5)\n    &gt;&gt;&gt; pop.sum()\n    1000\n</code></pre>"},{"location":"reference/laser/core/distributions/","title":"laser.core.distributions","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions","title":"<code>laser.core.distributions</code>","text":"<p>Various probability distributions implemented using NumPy and Numba.</p> <p>LASER based models generally move from pure NumPy to Numba-accelerated version of the core dynamics, e.g., transmission.</p> <p>It would be a hassle to re-implement these functions for each desired distribution, so we provide these Numba-wrapped distributions here which can be passed in to other Numba compiled functions.</p> <p>For example, a simple SIR model may want to parameterize the infectious period using a distribution. By passing in a Numba-wrapped distribution function, we can pick and parameterize a distribution based on configuration and sample from that distribution within the Numba-compiled SIR model without needing to re-implement the distribution logic within the SIR model itself.</p> <p>A simple example of usage::</p> <pre><code>import laser.core.distributions as dist\n\n# Create a Numba-wrapped beta distribution\nbeta_dist = dist.beta(2.0, 5.0)\n\n# Assign the distribution to the model's infectious period distribution\n# so the transmission component can sample from it during simulation\nmodel.infectious_period_dist = beta_dist\n</code></pre> <p>Note that the distribution functions take two parameters, <code>tick</code> and <code>node</code>, which are currently unused but match the desired signature for disease model components that may need to sample from distributions based on the current simulation tick or node index. In other words, distributions with spatial or temporal variation could be implemented in the future.</p> <p>Here are examples of Numba-wrapped distribution functions that could vary based on tick or tick + node::</p> <pre><code># temporal variation only\ncosine = np.cos(np.linspace(0, np.pi * 2, 365))\n\n@nb.njit(nogil=True, cache=True)\ndef seasonal_distribution(tick: int, node: int) -&gt; np.float32:\n    # ignore node for this seasonal distribution\n    day_of_year = tick % 365\n    base_value = 42.0 + 3.14159 * cosine[day_of_year]\n    # parameterize normal() with seasonal factor\n    return np.float32(np.random.normal(base_value, 2.0))\n\n# additional spatial variation\nramp = np.linspace(0, 2, 42)\n\n@nb.njit(nogil=True, cache=True)\ndef ramped_distribution(tick: int, node: int) -&gt; np.float32:\n    day_of_year = tick % 365\n    # use seasonal factor\n    base_value = 42.0 + 3.14159 * cosine[day_of_year]\n    # apply spatial ramp based on node index\n    base_value *= ramp[node]\n    # parameterize normal() with seasonal + spatial factor\n    return np.float32(np.random.normal(base_value, 1.0))\n</code></pre> <p>Normally, these distributions\u2014built in or custom\u2014will be used once per agent as above. However, the <code>sample_ints()</code> and <code>sample_floats()</code> functions can be used to efficiently sample large arrays using multiple CPU cores in parallel.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.beta","title":"<code>laser.core.distributions.beta(a, b)</code>  <code>cached</code>","text":"<p>Beta distribution.</p> <p>\\(f(x; a, b) = \\frac {x^{a-1} (1-x)^{b-1}} {B(a, b)}\\)</p> <p>where \\(B(a, b)\\) is the beta function.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.binomial","title":"<code>laser.core.distributions.binomial(n, p)</code>  <code>cached</code>","text":"<p>Binomial distribution.</p> <p>\\(f(k,n,p) = Pr(X = k) = \\binom {n} {k} p^k (1-p)^{n-k}\\)</p> <p>where \\(n\\) is the number of trials and \\(p\\) is the probability of success [0, 1].</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.constant_float","title":"<code>laser.core.distributions.constant_float(value)</code>  <code>cached</code>","text":"<p>Constant distribution. Always returns the same floating point value.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.constant_int","title":"<code>laser.core.distributions.constant_int(value)</code>  <code>cached</code>","text":"<p>Constant distribution. Always returns the same integer value.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.exponential","title":"<code>laser.core.distributions.exponential(scale)</code>  <code>cached</code>","text":"<p>Exponential distribution.</p> <p>\\(f(x; \\frac {1} {\\beta}) = \\frac {1} {\\beta} e^{-\\frac {x} {\\beta}}\\)</p> <p>where \\(\\beta\\) is the scale parameter (\\(\\beta = 1 / \\lambda\\)).</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.gamma","title":"<code>laser.core.distributions.gamma(shape, scale)</code>  <code>cached</code>","text":"<p>Gamma distribution.</p> <p>\\(p(x) = x^{k-1} \\frac {e^{- x / \\theta}}{\\theta^k \\Gamma(k)}\\)</p> <p>where \\(k\\) is the shape, \\(\\theta\\) is the scale, and \\(\\Gamma(k)\\) is the gamma function.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.logistic","title":"<code>laser.core.distributions.logistic(loc, scale)</code>  <code>cached</code>","text":"<p>Logistic distribution.</p> <p>\\(P(x) = \\frac {e^{-(x - \\mu) / s}} {s (1 + e^{-(x - \\mu) / s})^2}\\)</p> <p>where \\(\\mu\\) is the location parameter and \\(s\\) is the scale parameter.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.lognormal","title":"<code>laser.core.distributions.lognormal(mean, sigma)</code>  <code>cached</code>","text":"<p>Log-normal distribution.</p> <p>\\(p(x) = \\frac {1} {\\sigma x \\sqrt {2 \\pi}} e^{- \\frac {(\\ln x - \\mu)^2} {2 \\sigma^2}}\\)</p> <p>where \\(\\mu\\) is the mean and \\(\\sigma\\) is the standard deviation of the underlying normal distribution.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.negative_binomial","title":"<code>laser.core.distributions.negative_binomial(n, p)</code>  <code>cached</code>","text":"<p>Negative binomial distribution.</p> <p>\\(P(N; n, p) = \\frac {\\Gamma (N + n)} {N! \\Gamma (n)} p^n (1 - p)^N\\)</p> <p>where \\(n\\) is the number of successes, \\(p\\) is the probability of success on each trial, \\(N + n\\) is the number of trials, and \\(\\Gamma()\\) is the gamma function. When \\(n\\) is an integer,</p> <p>\\(\\frac {\\Gamma (N + n)} {N! \\Gamma (n)} = \\binom {N + n - 1} {n - 1}\\)</p> <p>which is the more common form of this term.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.normal","title":"<code>laser.core.distributions.normal(loc, scale)</code>  <code>cached</code>","text":"<p>Normal (Gaussian) distribution.</p> <p>\\(p(x) = \\frac {1} {\\sqrt {2 \\pi \\sigma^2}} e^{- \\frac {(x - \\mu)^2} {2 \\sigma^2}}\\)</p> <p>where \\(\\mu\\) is the mean and \\(\\sigma\\) is the standard deviation.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.poisson","title":"<code>laser.core.distributions.poisson(lam)</code>  <code>cached</code>","text":"<p>Poisson distribution.</p> <p>\\(f( k ; \\lambda ) = \\frac {\\lambda^k e^{- \\lambda}} {k!}\\)</p> <p>where \\(\\lambda\\) is the expected number of events in the given interval.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.sample_floats","title":"<code>laser.core.distributions.sample_floats(fn, dest, tick=0, node=0)</code>","text":"<p>Fill an array with floating point values sampled from a Numba-wrapped distribution function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>function</code> <p>Numba-wrapped distribution function returning float32 values.</p> required <code>dest</code> <code>ndarray</code> <p>Pre-allocated destination float32 array to store samples.</p> required <code>tick</code> <code>int</code> <p>Current simulation tick (default is 0). Passed through to the distribution function.</p> <code>0</code> <code>node</code> <code>int</code> <p>Current node index (default is 0). Passed through to the distribution function.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>dest</code> <code>ndarray</code> <p>The destination array filled with sampled values.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.sample_ints","title":"<code>laser.core.distributions.sample_ints(fn, dest, tick=0, node=0)</code>","text":"<p>Fill an array with integer values sampled from a Numba-wrapped distribution function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>function</code> <p>Numba-wrapped distribution function returning int32 values.</p> required <code>dest</code> <code>ndarray</code> <p>Pre-allocated destination int32 array to store samples.</p> required <code>tick</code> <code>int</code> <p>Current simulation tick (default is 0). Passed through to the distribution function.</p> <code>0</code> <code>node</code> <code>int</code> <p>Current node index (default is 0). Passed through to the distribution function.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>dest</code> <code>ndarray</code> <p>The destination array filled with sampled values.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.uniform","title":"<code>laser.core.distributions.uniform(low, high)</code>  <code>cached</code>","text":"<p>Uniform distribution.</p> <p>\\(p(x) = \\frac {1} {b - a}\\)</p> <p>where \\(a\\) is the lower bound and \\(b\\) is the upper bound, [\\(a\\), \\(b\\)).</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.weibull","title":"<code>laser.core.distributions.weibull(a, lam)</code>  <code>cached</code>","text":"<p>Weibull distribution.</p> <p>\\(X = \\lambda (- \\ln ( U ))^{1 / a}\\)</p> <p>where \\(a\\) is the shape parameter and \\(\\lambda\\) is the scale parameter.</p>"},{"location":"reference/laser/core/extension/","title":"laser.core.extension","text":""},{"location":"reference/laser/core/extension/#laser.core.extension","title":"<code>laser.core.extension</code>","text":""},{"location":"reference/laser/core/laserframe/","title":"laser.core.laserframe","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe","title":"<code>laser.core.laserframe</code>","text":"<p>laserframe.py</p> <p>This module defines the LaserFrame class, which is used to manage dynamically allocated data for agents or nodes/patches. The LaserFrame class is similar to a database table or a Pandas DataFrame and supports scalar and vector properties.</p> <p>Classes:</p> Name Description <code>LaserFrame</code> <p>A class to manage dynamically allocated data for agents or nodes/patches.</p> Usage Example <pre><code>laser_frame = LaserFrame(capacity=100)\nlaser_frame.add_scalar_property('age', dtype=np.int32, default=0)\nlaser_frame.add_vector_property('position', length=3, dtype=np.float32, default=0.0)\nstart, end = laser_frame.add(10)\nlaser_frame.sort(np.arange(10)[::-1])\nlaser_frame.squash(np.array([True, False, True, False, True, False, True, False, True, False]))\n</code></pre> <p>Attributes:</p> Name Type Description <code>count</code> <code>int</code> <p>The current count of active elements.</p> <code>capacity</code> <code>int</code> <p>The maximum capacity of the frame.</p> Note <p>Since count can be less than capacity, properties return slices of the underlying arrays up to count by default so users do not have to include the slice themselves. I.e., if <code>lf</code> is a LaserFrame, then <code>lf.age</code> returns <code>lf._age[0:lf.count]</code> automatically. The full underlying array is always available as <code>lf._age</code> (or whatever the property name is). The slice returned is valid for all NumPy operations, including assignment, as well as for use with Numba compiled functions.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame","title":"<code>laser.core.laserframe.LaserFrame(capacity, initial_count=-1, **kwargs)</code>","text":"<p>The LaserFrame class, similar to a db table or a Pandas DataFrame, holds dynamically allocated data for agents (generally 1-D or scalar) or for nodes|patches (e.g., 1-D for scalar value per patch or 2-D for time-varying per patch).</p> <p>Initialize a LaserFrame object.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int</code> <p>The maximum capacity of the frame.             Must be a positive integer.</p> required <code>initial_count</code> <code>int</code> <p>The initial number of active elements in the frame.                  Must be a positive integer &lt;= capacity.</p> <code>-1</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to set as attributes of the object.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If capacity or initial_count is not a positive integer,         or if initial_count is greater than capacity.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.capacity","title":"<code>laser.core.laserframe.LaserFrame.capacity</code>  <code>property</code>","text":"<p>Returns the capacity of the laser frame (total possible entries for dynamic properties).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The capacity of the laser frame.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.count","title":"<code>laser.core.laserframe.LaserFrame.count</code>  <code>property</code>","text":"<p>Returns the current count (equivalent to len()).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current count value.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add","title":"<code>laser.core.laserframe.LaserFrame.add(count)</code>","text":"<p>Adds the specified count to the current count of the LaserFrame.</p> <p>This method increments the internal count by the given count, ensuring that the total does not exceed the frame's capacity. If the addition would exceed the capacity, an assertion error is raised. This method is typically used to add new births during the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number to add to the current count.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: A tuple containing the [start index, end index) after the addition.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the resulting count exceeds the frame's capacity.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_array_property","title":"<code>laser.core.laserframe.LaserFrame.add_array_property(name, shape, dtype=np.uint32, default=0)</code>","text":"<p>Adds an array property to the object.</p> <p>This method initializes a new property with the given name as a multi-dimensional NumPy array.</p> <p>The array will have the given shape (note that there is no implied dimension of size self._capacity), datatype (default is np.uint32), and default value (default is 0).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the property to be added.</p> required <code>shape</code> <code>tuple</code> <p>The shape of the array.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data-type for the array, default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value to fill the array with, default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_scalar_property","title":"<code>laser.core.laserframe.LaserFrame.add_scalar_property(name, dtype=np.uint32, default=0)</code>","text":"<p>Add a scalar property to the class.</p> <p>This method initializes a new scalar property for the class instance. The property is stored as a 1-D NumPy array (scalar / entry) with a specified data type and default value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the scalar property to be added.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data type for the property. Default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value for the property. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_vector_property","title":"<code>laser.core.laserframe.LaserFrame.add_vector_property(name, length, dtype=np.uint32, default=0)</code>","text":"<p>Adds a vector property to the object.</p> <p>This method initializes a new property with the given name as a 2-D NumPy array (vector per entry).</p> <p>The array will have a shape of (length, self._capacity) and will be filled with the specified default value. The data type of the array elements is determined by the <code>dtype</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the property to be added.</p> required <code>length</code> <code>int</code> <p>The length of the vector.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data-type for the array, default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value to fill the array with, default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.describe","title":"<code>laser.core.laserframe.LaserFrame.describe(target=None)</code>","text":"<p>Return a formatted string description of the laserframe object, including its attributes and their values.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>string</code> <p>Optional string for the report header (generally the name of the LaserFrame variable, e.g., \"People\". Unlike functions, we can't get the name of a variable automatically).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string describing the laserframe object, including its capacity, count, and  details of its scalar, vector, and other properties.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.load_snapshot","title":"<code>laser.core.laserframe.LaserFrame.load_snapshot(path, n_ppl, cbr, nt)</code>  <code>classmethod</code>","text":"<p>Load a LaserFrame and optional extras from an HDF5 snapshot file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the HDF5 snapshot file.</p> required <code>n_ppl</code> <code>float or array - like</code> <p>Original total population (or per-node array) used to estimate births.</p> required <code>cbr</code> <code>float or array - like</code> <p>Crude birth rate (per 1000/year).</p> required <code>nt</code> <code>int</code> <p>Simulation duration (number of ticks).</p> required <p>Returns:</p> Name Type Description <code>frame</code> <code>LaserFrame</code> <p>Loaded LaserFrame object.</p> <code>results_r</code> <code>ndarray or None</code> <p>Optional 2D numpy array of recovered counts.</p> <code>pars</code> <code>dict or None</code> <p>Optional dictionary of parameters.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.save_snapshot","title":"<code>laser.core.laserframe.LaserFrame.save_snapshot(path, results_r=None, pars=None)</code>","text":"<p>Save this LaserFrame and optional extras to an HDF5 snapshot file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Destination file path</p> required <code>results_r</code> <code>ndarray</code> <p>Optional 2D numpy array of recovered counts</p> <code>None</code> <code>pars</code> <code>PropertySet or dict</code> <p>Optional PropertySet or dict of parameters</p> <code>None</code>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.sort","title":"<code>laser.core.laserframe.LaserFrame.sort(indices, verbose=False)</code>","text":"<p>Sorts the elements of the object's numpy arrays based on the provided indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>ndarray</code> <p>An array of indices used to sort the numpy arrays. Must be of integer type and have the same length as the frame count (<code>self._count</code>).</p> required <code>verbose</code> <code>bool</code> <p>If True, prints the sorting progress for each numpy array attribute. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>indices</code> is not an integer array or if its length does not match the frame count of active elements.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.squash","title":"<code>laser.core.laserframe.LaserFrame.squash(indices, verbose=False)</code>","text":"<p>Reduces the active count of the internal numpy arrays keeping only elements True in the provided boolean indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>ndarray</code> <p>A boolean array indicating which elements to keep. Must have the same length as the current frame active element count.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints detailed information about the squashing process. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>indices</code> is not a boolean array or if its length does not match the current frame active element count.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/migration/","title":"laser.core.migration","text":""},{"location":"reference/laser/core/migration/#laser.core.migration","title":"<code>laser.core.migration</code>","text":"<p>This module provides various functions to calculate migration networks based on different models, including the gravity model, competing destinations model, Stouffer's model, and the radiation model.</p> <p>Additionally, it includes a utility function to calculate the great-circle distance between two points on the Earth's surface using the Haversine formula.</p> <p>Functions:</p> Name Description <code>gravity</code> <p>np.ndarray, distances: np.ndarray, k: float, a: float, b: float, c: float, max_frac: Union[float, None]=None, kwargs) -&gt; np.ndarray: Compute a gravity-model migration network based on origin and destination populations and pairwise distances.</p> <code>row_normalizer</code> <p>np.ndarray, max_rowsum: float) -&gt; np.ndarray: Normalize the rows of a given network matrix such that no row sum exceeds a specified maximum value.</p> <code>competing_destinations</code> <p>np.ndarray, distances: np.ndarray, b: float, c: float, delta: float, params) -&gt; np.ndarray: Compute a migration network using the competing-destinations model, incorporating the influence of alternative destination nodes.</p> <code>stouffer</code> <p>np.ndarray, distances: np.ndarray, k: float, a: float, b: float, include_home: bool, params) -&gt; np.ndarray: Compute a migration network using a modified Stouffer's model.</p> <code>radiation</code> <p>np.ndarray, distances: np.ndarray, k: float, include_home: bool, params) -&gt; np.ndarray: Compute a migration network using the radiation model, which models flows based on intervening population rather than physical distance.</p> <code>distance</code> <p>float, lon1: float, lat2: float, lon2: float) -&gt; float: Calculate the great-circle distance between two points on the Earth's surface using the Haversine formula.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations","title":"<code>laser.core.migration.competing_destinations(pops, distances, k, a, b, c, delta, **params)</code>","text":"<p>Calculate the competing destinations model for a given set of populations and distances. (Fotheringham AS. Spatial flows and spatial patterns. Environment and planning A. 1984;16(4):529-543)</p> <p>This function computes a network matrix based on the gravity model and then adjusts it using the competing destinations model. The adjustment is done by considering the interference from other destinations.</p> Mathematical formula <p>Element-by-element:     $$     network_{i,j} = k \\times p_i^a \\times p_j^b / distance_{i,j}^c \\times \\sum_k {(p_k^b / distance_{j,k}^c \\text {\\small for k not in [i,j]})^{delta} }     $$</p> <p>As-implemented numpy math:</p> <ul> <li>Compute all terms up to the sum_k using the gravity model</li> <li>Construct the matrix inside the sum: <code>p**b * distances**(1-c)</code></li> <li>Sum on the second axis (k), and subtract off the diagonal (j=k terms):     <code>row_sums = np.sum(competition_matrix, axis=1) - np.diag(competition_matrix)</code></li> <li>Now element-by-element, subtract k=i terms off the sum, exponentiate, and multiply the original network term:     <code>network[i][j] = network[i][j] * (row_sums[i] - competition_matrix[i][j]) ** delta</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>pops</code> <code>ndarray</code> <p>Array of populations.</p> required <code>distances</code> <code>ndarray</code> <p>Array of distances between locations.</p> required <code>k</code> <code>float</code> <p>Scaling constant.</p> required <code>a</code> <code>float</code> <p>Exponent for the population of the origin.</p> required <code>b</code> <code>float</code> <p>Exponent parameter for populations in the gravity model.</p> required <code>c</code> <code>float</code> <p>Exponent parameter for distances in the gravity model.</p> required <code>delta</code> <code>float</code> <p>Exponent parameter for the competing destinations adjustment.</p> required <code>params</code> <code>dict</code> <p>Additional parameters to be passed to the gravity model.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>network</code> <code>ndarray</code> <p>Adjusted network matrix based on the competing destinations model.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.distance","title":"<code>laser.core.migration.distance(lat1, lon1, lat2=None, lon2=None)</code>","text":"<p>Calculate the great-circle distance between two points on the Earth's surface. This function uses the Haversine formula to compute the distance between two points specified by their latitude and longitude in decimal degrees.</p> <ul> <li>If <code>lat2</code> and <code>lon2</code> are not provided, they default to <code>lat1</code> and <code>lon1</code>, respectively. This supports the default case of calculating the NxN matrix of distances between all pairs of points in (<code>lat1</code>, <code>lon1</code>).</li> <li>If all arguments are scalars, will return a single scalar distance, (<code>lat1</code>, <code>lon1</code>) to (<code>lat2</code>, <code>lon2</code>).</li> <li>If <code>lat2</code>, <code>lon2</code> are vectors, will return a vector of distances, (<code>lat1</code>, <code>lon1</code>) to each lat/lon in <code>lat2</code>, <code>lon2</code>.</li> <li>If <code>lat1</code>, <code>lon1</code> and <code>lat2</code>, <code>lon2</code> are vectors, will return a matrix with shape (N, M) of distances where N is the length of <code>lat1</code>/<code>lon1</code> and M is the length of <code>lat2</code>/<code>lon2</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>lat1</code> <code>float</code> <p>Latitude of the first point(s) in decimal degrees [-90, 90].</p> required <code>lon1</code> <code>float</code> <p>Longitude of the first point(s) in decimal degrees [-180, 180].</p> required <code>lat2</code> <code>float</code> <p>Latitude of the second point(s) in decimal degrees [-90, 90].</p> <code>None</code> <code>lon2</code> <code>float</code> <p>Longitude of the second point(s) in decimal degrees [-180, 180].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>distance</code> <code>float</code> <p>The distance between the points in kilometers.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.gravity","title":"<code>laser.core.migration.gravity(pops, distances, k, a, b, c, **kwargs)</code>","text":"<p>Calculate a gravity model network.</p> <p>This function computes a gravity model network based on the provided populations and distances. The gravity model estimates migration or interaction flows between populations using a mathematical formula that incorporates scaling, population sizes, and distances.</p> <p>Mathematical formula::     $$     network_{i,j} = k \\cdot \\frac{p_i^a \\cdot p_j^b}{distance_{i,j}^c}     $$</p> <p>As implemented in NumPy::</p> <pre><code>network = k * (pops[:, np.newaxis] ** a) * (pops ** b) * (distances ** (-1 * c))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pops</code> <code>ndarray</code> <p>1D array of population sizes for each node.</p> required <code>distances</code> <code>ndarray</code> <p>2D array of distances between nodes. Must be symmetric, with self-distances (diagonal) handled.</p> required <code>k</code> <code>float</code> <p>Scaling constant to adjust the overall magnitude of interaction flows.</p> required <code>a</code> <code>float</code> <p>Exponent for the population size of the origin node.</p> required <code>b</code> <code>float</code> <p>Exponent for the population size of the destination node.</p> required <code>c</code> <code>float</code> <p>Exponent for the distance between nodes, controlling how distance impacts flows.</p> required <code>kwargs</code> <code>dict</code> <p>Additional keyword arguments (not used in the current implementation).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>network</code> <code>ndarray</code> <p>A 2D matrix representing the interaction network, where each element <code>network[i, j]</code> corresponds to the flow from node <code>i</code> to node <code>j</code>.</p> <p>Example usage::</p> <pre><code>import numpy as np\nfrom gravity_model import gravity\n\npopulations = np.array([1000, 500, 200])\ndistances = np.array([\n    [0, 2, 3],\n    [2, 0, 1],\n    [3, 1, 0]\n])\n\nk = 0.5\na = 1.0\nb = 1.0\nc = 2.0\n\nmigration_network = gravity(populations, distances, k, a, b, c)\n\nprint(\"Migration Network:\")\nprint(migration_network)\n</code></pre> Notes <ul> <li>The diagonal of the distances matrix is set to 1 internally to avoid division by zero.</li> <li>The diagonal of the output network is set to 0 to represent no self-loops.</li> <li>Ensure the distances matrix is symmetric and non-negative.</li> </ul>"},{"location":"reference/laser/core/migration/#laser.core.migration.radiation","title":"<code>laser.core.migration.radiation(pops, distances, k, include_home, **params)</code>","text":"<p>Calculate the migration network using the radiation model.</p> <p>(Simini F, Gonz\u00e1lez MC, Maritan A, Barab\u00e1si AL. A universal model for mobility and migration patterns. Nature. 2012;484(7392):96-100.)</p> Mathematical formula <p>Element-by-element:     $$     network_{i,j} = k \\times p_i^a \\times (p_j / \\sum_k {p_k} )^b,     $$     where the sum proceeds over all \\(k\\) such that \\(distances_{i,k} \\leq distances_{i,j}\\)     the parameter <code>include_home</code> determines whether \\(p_i\\) is included or excluded from the sum.</p> <p>As-implemented numpy math:</p> <ul> <li>Sort each row of the distance matrix (we'll use \\' below to indicate distance-sorted vectors)</li> <li> <p>Loop over \"source nodes\" i</p> <ul> <li>Cumulative sum the sorted populations, ensuring appropriate handling when there are multiple destinations equidistant from the source</li> <li>Subtract the source node population if <code>include_home</code> is <code>False</code></li> <li>Construct the row of the network matrix as     $$     k \\times p_i \\times p_{j'} / (p_i + \\sum_{k'} {p_{k'}}) / (p_i + p_{j'} + \\sum_{k'} {p_{k'}})     $$</li> </ul> </li> <li> <p>Unsort the rows of the network</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>pops</code> <code>ndarray</code> <p>Array of population sizes for each node.</p> required <code>distances</code> <code>ndarray</code> <p>2D array of distances between nodes.</p> required <code>k</code> <code>float</code> <p>Scaling factor for the migration rates.</p> required <code>include_home</code> <code>bool</code> <p>Whether to include the home population in the calculations.</p> required <code>params</code> <code>dict</code> <p>Additional parameters (currently not used).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>network</code> <code>ndarray</code> <p>2D array representing the migration network.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.row_normalizer","title":"<code>laser.core.migration.row_normalizer(network, max_rowsum)</code>","text":"<p>Normalizes the rows of a given network matrix such that no row sum exceeds a specified maximum value.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>ndarray</code> <p>A 2D array representing the network matrix.</p> required <code>max_rowsum</code> <code>float</code> <p>The maximum allowable sum for any row in the network matrix.</p> required <p>Returns:</p> Name Type Description <code>network</code> <code>ndarray</code> <p>The normalized network matrix where no row sum exceeds the specified maximum value.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.stouffer","title":"<code>laser.core.migration.stouffer(pops, distances, k, a, b, include_home, **params)</code>","text":"<p>Computes a migration network using a modified Stouffer's model.</p> <p>(Stouffer SA. Intervening opportunities: a theory relating mobility and distance. American sociological review. 1940;5(6):845-867)</p> Mathematical formula <p>Element-by-element:     $$     network_{i,j} = k \\times p_i \\times p_j / ( (p_i + \\sum_k {p_k}) (p_i + p_j + \\sum_k {p_k}) )     $$     the parameter <code>include_home</code> determines whether \\(p_i\\) is included or excluded from the sum</p> <p>As-implemented numpy math:</p> <ul> <li>Sort each row of the distance matrix (we'll use \\' below to indicate distance-sorted vectors)</li> <li> <p>Loop over \"source nodes\" i:</p> <ul> <li>Cumulative sum the sorted populations, ensuring appropriate handling when there are multiple destinations equidistant from the source</li> <li>Subtract the source node population if <code>include_home</code> is <code>False</code></li> <li>Construct the row of the network matrix as \\(k \\times p_i^a \\times (p_{j'} / \\sum_{k'} {p_{k'}})^b\\)</li> </ul> </li> <li> <p>Unsort the rows of the network</p> </li> </ul> <p>Parameters:</p> <pre><code>pops (numpy.ndarray): An array of population sizes.\ndistances (numpy.ndarray): A 2D array where `distances[i][j]` is the distance from location i to location j.\nk (float): A scaling factor for the migration rates.\na (float): Exponent applied to the population size of the origin.\nb (float): Exponent applied to the ratio of destination population to the sum of all populations at equal or lesser distances.\ninclude_home (bool): If True, includes the home population in the cumulative sum; otherwise, excludes it.\n**params: Additional parameters (not used in the current implementation).\n</code></pre> <p>Returns:</p> Name Type Description <code>network</code> <code>ndarray</code> <p>A 2D array representing the migration network, where <code>network[i][j]</code> is the migration rate from location i to location j.</p>"},{"location":"reference/laser/core/propertyset/","title":"laser.core.propertyset","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset","title":"<code>laser.core.propertyset</code>","text":"<p>Implements a PropertySet class that can be used to store properties in a dictionary-like object.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet","title":"<code>laser.core.propertyset.PropertySet(*bags)</code>","text":"<p>A class that can be used to store properties in a dictionary-like object with <code>.property</code> access to properties.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet--examples","title":"Examples","text":"<p>Basic Initialization:</p> <pre><code>from laser.core import PropertySet\nps = PropertySet()\nps['infection_status'] = 'infected'\nps['age'] = 35\nprint(ps.infection_status)  # Outputs: 'infected'\nprint(ps['age'])            # Outputs: 35\n</code></pre> <p>Combining two PropertySets:</p> <pre><code>ps1 = PropertySet({'immunity': 'high', 'region': 'north'})\nps2 = PropertySet({'infectivity': 0.7})\ncombined_ps = ps1 + ps2\nprint(combined_ps.to_dict())\n# Outputs: {'immunity': 'high', 'region': 'north', 'infectivity': 0.7}\n</code></pre> <p>Creating a PropertySet from a dictionary:</p> <pre><code>ps = PropertySet({'mything': 0.4, 'that_other_thing': 42})\nprint(ps.mything)            # Outputs: 0.4\nprint(ps.that_other_thing)   # Outputs: 42\nprint(ps.to_dict())\n# Outputs: {'mything': 0.4, 'that_other_thing': 42}\n</code></pre> <p>Save and load:</p> <pre><code>ps.save('properties.json')\nloaded_ps = PropertySet.load('properties.json')\nprint(loaded_ps.to_dict())  # Outputs the saved properties\n</code></pre> <p>Property access and length:</p> <pre><code>ps['status'] = 'susceptible'\nps['exposure_timer'] = 5\nprint(ps['status'])          # Outputs: 'susceptible'\nprint(len(ps))               # Outputs: 4\n</code></pre> <p>In-Place addition (added keys must not exist in the destination PropertySet):</p> <pre><code>ps += {'new_timer': 10, 'susceptibility': 0.75}\nprint(ps.to_dict())\n# Outputs: {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 5, 'new_timer': 10, 'susceptibility': 0.75}\n</code></pre> <p>In-place update (keys must already exist in the destination PropertySet):</p> <pre><code>ps &lt;&lt;= {'exposure_timer': 10, 'infectivity': 0.8}\nprint(ps.to_dict())\n# Outputs: {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 10, 'infectivity': 0.8}\n</code></pre> <p>In-place addition or update (no restriction on incoming keys):</p> <pre><code>ps |= {'new_timer': 10, 'exposure_timer': 8}\nprint(ps.to_dict())\n# Outputs: {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 8, 'new_timer': 10}\n</code></pre> <p>Initialize a PropertySet to manage properties in a dictionary-like structure.</p> <p>Parameters:</p> Name Type Description Default <code>bags</code> <code>Union[PropertySet, list, tuple, dict]</code> <p>A sequence of key-value pairs (e.g., lists, tuples, dictionaries) to initialize the PropertySet. Keys must be strings, and values can be any type.</p> <code>()</code>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__add__","title":"<code>laser.core.propertyset.PropertySet.__add__(other)</code>","text":"<p>Add another PropertySet to this PropertySet.</p> <p>This method allows the use of the <code>+</code> operator to combine two PropertySet instances.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PropertySet</code> <p>The other PropertySet instance to add.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <code>PropertySet</code> <p>A new PropertySet instance that combines the properties of both instances.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__contains__","title":"<code>laser.core.propertyset.PropertySet.__contains__(key)</code>","text":"<p>Check if a key is in the property set.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check for existence in the property set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists in the property set, False otherwise.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__eq__","title":"<code>laser.core.propertyset.PropertySet.__eq__(other)</code>","text":"<p>Check if two PropertySet instances are equal.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PropertySet</code> <p>The other PropertySet instance to compare.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the two instances are equal, False otherwise.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__getitem__","title":"<code>laser.core.propertyset.PropertySet.__getitem__(key)</code>","text":"<p>Retrieve the attribute of the object with the given key (e.g., <code>ps[key]</code>).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the attribute to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>any</code> <p>The value of the attribute with the specified key.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute with the specified key does not exist.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__iadd__","title":"<code>laser.core.propertyset.PropertySet.__iadd__(other)</code>","text":"<p>Implements the in-place addition (<code>+=</code>) operator for the class.</p> <p>This method allows the instance to be updated with attributes from another instance of the same class or from a dictionary. If <code>other</code> is an instance of the same class, its attributes are copied to the current instance. If <code>other</code> is a dictionary, its key-value pairs are added as attributes to the current instance.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary to add to the current instance.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>PropertySet</code> <p>The updated instance with the new attributes.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys already present in the PropertySet.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ilshift__","title":"<code>laser.core.propertyset.PropertySet.__ilshift__(other)</code>","text":"<p>Implements the <code>&lt;&lt;=</code> operator on PropertySet to override existing values with new values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>PropertySet</code> <p>The updated instance with the overrides from other.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys not present in the PropertySet.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ior__","title":"<code>laser.core.propertyset.PropertySet.__ior__(other)</code>","text":"<p>Implements the <code>|=</code> operator on PropertySet to override existing values with new values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>PropertySet</code> <p>The updated instance with all the values of self with new or overriding values from other.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__len__","title":"<code>laser.core.propertyset.PropertySet.__len__()</code>","text":"<p>Return the number of attributes in the instance.</p> <p>This method returns the number of attributes stored in the instance's dict attribute, which represents the instance's namespace.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of attributes in the instance.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__lshift__","title":"<code>laser.core.propertyset.PropertySet.__lshift__(other)</code>","text":"<p>Implements the <code>&lt;&lt;</code> operator on PropertySet to override existing values with new values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <code>PropertySet</code> <p>A new PropertySet with all the values of the first PropertySet with overrides from the second PropertySet.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys not present in the PropertySet.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__or__","title":"<code>laser.core.propertyset.PropertySet.__or__(other)</code>","text":"<p>Implements the <code>|</code> operator on PropertySet to add new or override existing values with new values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <code>PropertySet</code> <p>A new PropertySet with all the values of the first PropertySet with new or overriding values from the second PropertySet.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__repr__","title":"<code>laser.core.propertyset.PropertySet.__repr__()</code>","text":"<p>Return a string representation of the PropertySet instance.</p> <p>The string representation includes the class name and the dictionary of the instance's attributes.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the PropertySet instance.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__setitem__","title":"<code>laser.core.propertyset.PropertySet.__setitem__(key, value)</code>","text":"<p>Set the value of an attribute. This method allows setting an attribute of the instance using the dictionary-like syntax (e.g., <code>ps[key] = value</code>).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the attribute to set.</p> required <code>value</code> <code>any</code> <p>The value to set for the attribute.</p> required"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__str__","title":"<code>laser.core.propertyset.PropertySet.__str__()</code>","text":"<p>Returns a string representation of the object's dictionary.</p> <p>This method is used to provide a human-readable string representation of the object, which includes all the attributes stored in the object's <code>__dict__</code>.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the object's dictionary.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.load","title":"<code>laser.core.propertyset.PropertySet.load(filename)</code>  <code>staticmethod</code>","text":"<p>Load a PropertySet from a specified file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the file where the PropertySet is saved.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <code>PropertySet</code> <p>The PropertySet instance loaded from the file.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.save","title":"<code>laser.core.propertyset.PropertySet.save(filename)</code>","text":"<p>Save the PropertySet to a specified file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the file where the PropertySet will be saved.</p> required"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.to_dict","title":"<code>laser.core.propertyset.PropertySet.to_dict()</code>","text":"<p>Convert the PropertySet to a dictionary.</p>"},{"location":"reference/laser/core/random/","title":"laser.core.random","text":""},{"location":"reference/laser/core/random/#laser.core.random","title":"<code>laser.core.random</code>","text":"<p>Functions for seeding and accessing the laser-core random number generator.</p> <p>Using the seed() function here and the pseudo-random number generator (PRNG) returned from the prng() function in simulation code will guarantee that the same random number stream is generated and used during simulation runs using the same seed value (assuming no changes to code which add or remove PRNG calls or change the number of random draws requested). This is important for reproducibility and debugging purposes.</p>"},{"location":"reference/laser/core/random/#laser.core.random.get_seed","title":"<code>laser.core.random.get_seed()</code>","text":"<p>Return the seed used to initialize the pseudo-random number generator.</p> <p>Returns:</p> Name Type Description <code>uint32</code> <code>uint32</code> <p>The seed value used to initialize the random number generators.</p>"},{"location":"reference/laser/core/random/#laser.core.random.prng","title":"<code>laser.core.random.prng()</code>","text":"<p>Return the global (to LASER) pseudo-random number generator.</p>"},{"location":"reference/laser/core/random/#laser.core.random.seed","title":"<code>laser.core.random.seed(seed)</code>","text":"<p>Initialize the pseudo-random number generator with a given seed.</p> <p>This function sets the global pseudo-random number generator (_prng) to a new instance of numpy's default random generator initialized with the provided seed. It also seeds Numba's per-thread random number generators with the same seed.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The seed value to initialize the random number generators.</p> required <p>Returns:</p> Type Description <code>Generator</code> <p>numpy.random.Generator: The initialized pseudo-random number generator.</p>"},{"location":"reference/laser/core/sortedqueue/","title":"laser.core.sortedqueue","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue","title":"<code>laser.core.sortedqueue</code>","text":"<p>SortedQueue implementation using NumPy and Numba.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue","title":"<code>laser.core.sortedqueue.SortedQueue(capacity, values)</code>","text":"<p>A sorted (priority) queue implemented using NumPy arrays and sped-up with Numba.</p> <p>Using the algorithm from the Python heapq module.</p> <p>init with an existing array of sorting values</p> <p>push with an index into sorting values</p> <p>pop returns the index of the lowest sorting value and its value</p> <p>Initializes a new instance of the class with a specified capacity and reference to existing, sortable values.</p> <p>This implementation is specific to LASER and the expectation of tracking 10s or 100s of millions of agents.</p> <p>We expect the sortable (or priority) values to already be in a NumPy array, usually a property of a LaserFrame object.</p> <p>The <code>push()</code> and <code>pop()</code> will take indices into this array and will sort on values[i]. This avoids making copies of the sort values.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int</code> <p>The maximum number of elements the queue can hold.</p> required <code>values</code> <code>ndarray</code> <p>A reference to an array of values to be accessed by the queue.</p> required"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.__len__","title":"<code>laser.core.sortedqueue.SortedQueue.__len__()</code>","text":"<p>Return the number of elements in the sorted queue.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the sorted queue.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.__pop","title":"<code>laser.core.sortedqueue.SortedQueue.__pop()</code>","text":"<p>Removes the smallest value element from the sorted queue.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> Side effects <ul> <li>Decreases the size of the sorted queue by one.</li> <li>Reorganizes the internal structure of the sorted queue to maintain the heap property.</li> </ul>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peeki","title":"<code>laser.core.sortedqueue.SortedQueue.peeki()</code>","text":"<p>Returns the index of the smallest value element in the sorted queue without removing it.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> <p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: The index of the smallest value element.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peekiv","title":"<code>laser.core.sortedqueue.SortedQueue.peekiv()</code>","text":"<p>Returns the index and value of the smallest value element in the sorted queue without removing it.</p> <p>Returns:</p> Type Description <code>tuple[uint32, Any]</code> <p>tuple[np.uint32, Any]: A tuple containing the index and value of the smallest value element.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peekv","title":"<code>laser.core.sortedqueue.SortedQueue.peekv()</code>","text":"<p>Return the smallest value from the sorted queue without removing it.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value with the smallest value in the sorted queue.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popi","title":"<code>laser.core.sortedqueue.SortedQueue.popi()</code>","text":"<p>Removes and returns the index of the smallest value element in the sorted queue.</p> <p>This method first retrieves the index of the smallest value element using <code>peeki()</code>, then removes the element from the queue using <code>pop()</code>, and finally returns the index.</p> <p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: The index of the smallest value element in the sorted queue.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popiv","title":"<code>laser.core.sortedqueue.SortedQueue.popiv()</code>","text":"<p>Removes and returns the index and value of the smallest value element in the sorted queue.</p> <p>This method first retrieves the index and value of the smallest value element using <code>peekiv()</code>, then removes the element from the queue using <code>pop()</code>, and finally returns the index and value.</p> <p>Returns:</p> Type Description <code>tuple[uint32, Any]</code> <p>tuple[np.uint32, Any]: A tuple containing the index and value of the smallest value element.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popv","title":"<code>laser.core.sortedqueue.SortedQueue.popv()</code>","text":"<p>Removes and returns the value at the front of the sorted queue.</p> <p>This method first retrieves the value at the front of the queue without removing it by calling <code>peekv()</code>, and then removes the front element from the queue by calling <code>pop()</code>. The retrieved value is then returned.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value at the front of the sorted queue.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.push","title":"<code>laser.core.sortedqueue.SortedQueue.push(index)</code>","text":"<p>Insert an element into the sorted queue.</p> <p>This method adds an element at the back of the sorted queue and then ensures the heap property is maintained by sifting the element forward to its correct position.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the element to be added to the sorted queue.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is full.</p>"},{"location":"reference/laser/core/utils/","title":"laser.core.utils","text":""},{"location":"reference/laser/core/utils/#laser.core.utils","title":"<code>laser.core.utils</code>","text":"<p>This module provides utility functions for the laser-measles project.</p> <p>Functions:</p> Name Description <code>calc_capacity</code> <p>np.ndarray, initial_pop: np.ndarray, safety_factor: float = 1.0) -&gt; np.ndarray: Calculate the population capacity after a given number of ticks based on a constant birth rate.</p> <code>grid</code> <p>Tuple[int, int], fill_value: float = 0.0) -&gt; np.ndarray: Create a 2D grid (numpy array) of the specified shape, filled with the given value.</p>"},{"location":"reference/laser/core/utils/#laser.core.utils.calc_capacity","title":"<code>laser.core.utils.calc_capacity(birthrates, initial_pop, safety_factor=1.0)</code>","text":"<p>Estimate the required capacity (number of agents) to model a population given birthrates over time.</p> <p>Args:</p> <pre><code>birthrates (np.ndarray): 2D array of shape (nsteps, nnodes) representing birthrates (CBR) per 1,000 individuals per year.\ninitial_pop (np.ndarray): 1D array of length nnodes representing the initial population at each node.\nsafety_factor (float): Safety factor to account for variability in population growth. Default is 1.0.\n</code></pre> <p>Returns:</p> <pre><code>np.ndarray: 1D array of length nnodes representing the estimated required capacity (number of agents) at each node.\n</code></pre>"},{"location":"reference/laser/core/utils/#laser.core.utils.grid","title":"<code>laser.core.utils.grid(M=5, N=5, node_size_degs=0.08983, population_fn=None, origin_x=0, origin_y=0, states=None)</code>","text":"<p>Create an MxN grid of cells anchored at (lat, long) with populations and geometries.</p> <p>By default all nodes are initialized with the full population in the first state (e.g., \"S\" for susceptible).</p> <p>Parameters:</p> Name Type Description Default <code>M</code> <code>int</code> <p>Number of rows (north-south).</p> <code>5</code> <code>N</code> <code>int</code> <p>Number of columns (east-west).</p> <code>5</code> <code>node_size_degs</code> <code>float</code> <p>Size of each cell in decimal degrees (default 0.08983 \u2248 10km at the equator).</p> <code>0.08983</code> <code>population_fn</code> <code>callable</code> <p>Function(row, col) returning population for a cell. Default is uniform random between 1,000 and 100,000.</p> <code>None</code> <code>origin_x</code> <code>float</code> <p>longitude of the origin in decimal degrees (bottom-left corner) -180 &lt;= origin_x &lt; 180.</p> <code>0</code> <code>origin_y</code> <code>float</code> <p>latitude of the origin in decimal degrees (bottom-left corner) -90 &lt;= origin_y &lt; 90.</p> <code>0</code> <code>states</code> <code>list</code> <p>List of state names to initialize in the GeoDataFrame. Default is [\"S\", \"E\", \"I\", \"R\"].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>scenario</code> <code>GeoDataFrame</code> <p>Columns are nodeid, population, geometry.</p>"},{"location":"reference/laser/core/utils/#laser.core.utils.initialize_population","title":"<code>laser.core.utils.initialize_population(grid, initial, states=None)</code>","text":"<p>Initialize the population states in the grid based on the initial state counts provided.</p> <p>Provide integer values to set the exact counts for each state at each node. Alternatively, provide fractional values between 0.0 and 1.0 to set proportions of the population for each state at each node. In the latter case, the first state in the states list will be computed as the remainder of the population after assigning the other states.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>GeoDataFrame</code> <p>The grid GeoDataFrame with population and state columns.</p> required <code>initial</code> <code>list or ndarray</code> <p>A list or array of shape (1|nnodes, nstates) representing the initial counts for each state at each node. If the shape is (1, nstates), the same initial state distribution will be applied to all nodes.</p> required <code>states</code> <code>list</code> <p>List of state names corresponding to the columns in the grid. Default is [\"S\", \"E\", \"I\", \"R\"].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>GeoDataFrame</code> <p>The updated grid with initialized population states.</p>"},{"location":"reference/laser/generic/","title":"laser.generic","text":""},{"location":"reference/laser/generic/#laser.generic","title":"<code>laser.generic</code>","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign","title":"<code>laser.generic.ImmunizationCampaign(model, period, coverage, age_lower, age_upper, start=0, end=-1, verbose=False)</code>","text":"<p>A LASER component that applies an immunization campaign over an age band.</p> <p>On eligible ticks, all agents with age in [age_lower, age_upper) are considered and immunized with probability <code>coverage</code>. Susceptibles become immune (<code>population.susceptibility[idx] = 0</code>). This aligns with the campaign-style immunization component described in the <code>laser-generic</code> docs.</p> <p>Initialize an ImmunizationCampaign instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER <code>Model</code> with <code>population</code>, <code>patches</code>, and <code>params</code>. <code>params.nticks</code> must be defined.</p> required <code>period</code> <code>int</code> <p>Number of ticks between campaign events. Must be &gt;= 1.</p> required <code>coverage</code> <code>float</code> <p>Per-event immunization probability in [0.0, 1.0].</p> required <code>age_lower</code> <code>int</code> <p>Inclusive lower bound of target age band (ticks).</p> required <code>age_upper</code> <code>int</code> <p>Exclusive upper bound of target age band (ticks). Must be &gt; age_lower.</p> required <code>start</code> <code>int</code> <p>First tick (inclusive) to run campaigns. Default 0.</p> <code>0</code> <code>end</code> <code>int</code> <p>Last tick (exclusive) to run campaigns. If -1, defaults to <code>model.params.nticks</code>. Default -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging. Default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model instance.</p> <code>period</code> <code>int</code> <p>Ticks between campaign events.</p> <code>coverage</code> <code>float</code> <p>Immunization probability at each event.</p> <code>age_lower</code> <code>int</code> <p>Inclusive lower age (ticks).</p> <code>age_upper</code> <code>int</code> <p>Exclusive upper age (ticks).</p> <code>start</code> <code>int</code> <p>First campaign tick (inclusive).</p> <code>end</code> <code>int</code> <p>Last campaign tick (exclusive).</p> <code>verbose</code> <code>bool</code> <p>Verbosity flag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs are out of range (e.g., period &lt; 1, coverage not in [0, 1],         age bounds invalid).</p>"},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.__call__","title":"<code>laser.generic.ImmunizationCampaign.__call__(model, tick)</code>","text":"<p>Apply the immunization campaign at the given tick, if eligible.</p> Triggers when <p>tick &gt;= start and ((tick - start) % period == 0) and tick &lt; end</p> On each event <ul> <li>Agents with age in [age_lower, age_upper) are considered.</li> <li>A Binomial draw with probability <code>coverage</code> selects agents to immunize.</li> <li>Selected agents have <code>susceptibility</code> set to 0 (immune).</li> <li>If present, test arrays on <code>model.nodes</code> are updated for validation.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER model (unused; provided for signature parity).</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.plot","title":"<code>laser.generic.ImmunizationCampaign.plot(fig=None)</code>","text":"<p>Placeholder for campaign visualization.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A Matplotlib Figure to draw into.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents","title":"<code>laser.generic.Infect_Random_Agents(model, verbose=False)</code>","text":"<p>A LASER model component that introduces random infections into the population at regular intervals. This is typically used to simulate importation events or background infection pressure.</p> <p>Initialize an Infect_Random_Agents instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model object that contains the population, patches, and parameters. The following attributes must exist in <code>model.params</code>:   - importation_period (int): Number of ticks between each infection event.   - importation_count (int): Number of agents to infect per event.   - nticks (int): Total number of ticks in the simulation.   - importation_start (int, optional): First tick to introduce infections.     Defaults to 0 if not provided.   - importation_end (int, optional): Last tick to introduce infections.     Defaults to nticks if not provided.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model object used by the component.</p> <code>period</code> <code>int</code> <p>Number of ticks between infection events.</p> <code>count</code> <code>int</code> <p>Number of agents infected at each event.</p> <code>start</code> <code>int</code> <p>First tick to apply infections.</p> <code>end</code> <code>int</code> <p>Last tick to apply infections.</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.__call__","title":"<code>laser.generic.Infect_Random_Agents.__call__(model, tick)</code>","text":"<p>Introduce random infections into the population at the given tick.</p> Infections are seeded if <ul> <li>The current tick is greater than or equal to <code>start</code>.</li> <li>The tick falls on a multiple of <code>period</code> (relative to <code>start</code>).</li> <li>The tick is less than <code>end</code>.</li> </ul> <p>This updates both the agent-level infections and, if present, the test arrays in <code>model.patches</code> for validation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model containing the population and patches.</p> required <code>tick</code> <code>int</code> <p>The current tick (time step) of the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.plot","title":"<code>laser.generic.Infect_Random_Agents.plot(fig=None)</code>","text":"<p>Placeholder for visualization of infection events.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A matplotlib Figure to plot into. If None, no plot is generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.Model","title":"<code>laser.generic.Model(scenario, params, birthrates=None, name='generic', skip_capacity=False, states=None, additional_states=None)</code>","text":"<p>Initialize the SI model.</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>GeoDataFrame</code> <p>The scenario data containing per patch population, initial S and I counts, and geometry.</p> required <code>params</code> <code>PropertySet</code> <p>The parameters for the model, including 'nticks' and 'beta'.</p> required <code>birthrates</code> <code>ndarray</code> <p>Birth rates in CBR per patch per tick. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the model instance. Defaults to \"generic\".</p> <code>'generic'</code> <code>skip_capacity</code> <code>bool</code> <p>If True, skips capacity checks. Defaults to False.</p> <code>False</code> <code>states</code> <code>list</code> <p>List of state names. Defaults to None == {\"S\", \"E\", \"I\", \"R\"}.</p> <code>None</code> <code>additional_states</code> <code>list</code> <p>List of additional state names. Defaults to None.</p> <code>None</code>"},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization","title":"<code>laser.generic.RoutineImmunization(model, period, coverage, age, start=0, end=-1, verbose=False)</code>","text":"<p>A LASER component that updates immunity via routine immunization (RI).</p> <p>At eligible ticks, agents whose age (in ticks) falls within an RI window centered at <code>age</code> with half-width <code>period // 2</code> are sampled with probability <code>coverage</code> and made immune (by setting <code>population.susceptibility[idx] = 0</code>).</p> <p>This component follows the general component style in <code>laser-generic</code> and can be added to <code>Model.components</code>. See package documentation for details on the component pattern.</p> <p>Initialize a RoutineImmunization instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER <code>Model</code> with <code>population</code>, <code>patches</code>, and <code>params</code>. <code>params.nticks</code> must be defined.</p> required <code>period</code> <code>int</code> <p>Number of ticks between RI events. Must be &gt;= 1.</p> required <code>coverage</code> <code>float</code> <p>Per-event immunization probability in [0.0, 1.0].</p> required <code>age</code> <code>int</code> <p>Target age (in ticks) around which to immunize.</p> required <code>start</code> <code>int</code> <p>First tick (inclusive) to run RI. Default 0.</p> <code>0</code> <code>end</code> <code>int</code> <p>Last tick (exclusive) to run RI. If -1, defaults to <code>model.params.nticks</code>. Default -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging. Default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model instance.</p> <code>period</code> <code>int</code> <p>Ticks between RI events.</p> <code>coverage</code> <code>float</code> <p>Immunization probability at each event.</p> <code>age</code> <code>int</code> <p>Target age in ticks.</p> <code>start</code> <code>int</code> <p>First RI tick (inclusive).</p> <code>end</code> <code>int</code> <p>Last RI tick (exclusive).</p> <code>verbose</code> <code>bool</code> <p>Verbosity flag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>period &lt; 1</code>, <code>coverage</code> not in [0, 1], or <code>age &lt; 0</code>.</p>"},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.__call__","title":"<code>laser.generic.RoutineImmunization.__call__(model, tick)</code>","text":"<p>Apply routine immunization at the given tick, if eligible.</p> An event fires when <p>tick &gt;= start and ((tick - start) % period == 0) and tick &lt; end</p> On each event <ul> <li>Agents with age in [age - period//2, age + period//2) are considered.</li> <li>A Binomial draw with probability <code>coverage</code> selects agents to immunize.</li> <li>Selected agents have <code>susceptibility</code> set to 0 (immune).</li> <li>If present, test arrays on <code>model.nodes</code> are updated for validation.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER model (unused; provided for signature parity).</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.plot","title":"<code>laser.generic.RoutineImmunization.plot(fig=None)</code>","text":"<p>Placeholder for RI visualization.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A Matplotlib Figure to draw into.</p> <code>None</code>"},{"location":"reference/laser/generic/SEIR/","title":"laser.generic.SEIR","text":""},{"location":"reference/laser/generic/SEIR/#laser.generic.SEIR","title":"<code>laser.generic.SEIR</code>","text":"<p>Export required components for an SEIR model.</p> <p>Agents transition from Susceptible to Exposed upon infection, with an incubation duration. Agents transition from Exposed to Infectious after the incubation period and are infectious for a duration. Agents transition from Infectious to Recovered after the infectious period. Agents remain in the Recovered state indefinitely (no waning immunity).</p>"},{"location":"reference/laser/generic/SEIR/#laser.generic.SEIR.Exposed","title":"<code>laser.generic.SEIR.Exposed(model, expdurdist, infdurdist, expdurmin=1, infdurmin=1, validating=False)</code>","text":"<p>Exposed Component for SEIR/SEIRS Models with Explicit Incubation Period</p> <p>This component handles the incubation phase in models where agents must transition from an 'exposed' (E) state to 'infectious' (I) after a delay. It supports custom incubation and infectious duration distributions and handles both initialization and per-tick dynamics.</p> <p>Agents transition from Exposed to Infectious when their incubation timer (etimer) expires. Tracks number of agents becoming infectious each tick in <code>model.nodes.newly_infectious</code>.</p> <p>Responsibilities: - Initializes exposed individuals at time 0 (if provided in the scenario) - Assigns and tracks per-agent incubation timers (<code>etimer</code>) - Transitions agents from <code>EXPOSED</code> to <code>INFECTIOUS</code> when <code>etimer == 0</code> - Assigns new infection timers (<code>itimer</code>) upon becoming infectious - Updates patch-level EXPOSED (<code>E</code>) and INFECTIOUS case counts - Provides validation hooks for state and timer consistency</p> <p>Required Inputs: - <code>model.scenario.E</code>: initial count of exposed individuals per node (optional) - <code>expdurdist</code>: callable returning sampled incubation durations - <code>infdurdist</code>: callable returning sampled infectious durations - <code>expdurmin</code>: minimum incubation period (default 1 day) - <code>infdurmin</code>: minimum infectious period (default 1 day)</p> <p>Outputs: - <code>model.people.etimer</code>: agent-level incubation timer - <code>model.nodes.E[t, i]</code>: number of exposed individuals at time <code>t</code> in node <code>i</code> - <code>model.nodes.newly_infectious[t, i]</code>: number of newly infectious cases per node per day</p> <p>Validation: - Ensures consistency between individual states and <code>etimer</code> values - Ensures that agents becoming infectious have valid <code>itimer</code> values assigned - Prevents agents with expired <code>etimer</code> from remaining in EXPOSED state</p> Step Behavior <p>For each agent:     - Decrease <code>etimer</code>     - If <code>etimer == 0</code>, change state to <code>INFECTIOUS</code> and assign <code>itimer</code>     - Update <code>model.nodes.E</code> and <code>model.nodes.I</code> counts accordingly</p> <p>Plotting: The <code>plot()</code> method provides a time series of exposed individuals per node and total across all nodes.</p> Example <p>model.components = [     SIR.Susceptible(model),     Exposed(model, expdurdist, infdurdist),     SIR.Infectious(model, infdurdist),     ... ]</p>"},{"location":"reference/laser/generic/SEIR/#laser.generic.SEIR.Infectious","title":"<code>laser.generic.SEIR.Infectious(model, infdurdist, infdurmin=1, validating=False)</code>","text":"<p>Infectious Component for SIR/SEIR Models (With Recovery to Immune)</p> <p>This component manages agents in the infectious state for models where infected individuals recover permanently (i.e., transition to a <code>RECOVERED</code> state without waning). It supports agent-level infection durations and patch-level tracking of recoveries over time.</p> <p>Infectious component for an SIR/SEIR model - includes infectious duration, no waning immunity in newly_recovered state.</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Tracks number of agents recovering each tick in <code>model.nodes.newly_recovered</code>.</p> <p>Responsibilities: - Initializes infected agents and their infection timers (<code>itimer</code>) based on scenario input - Decrements <code>itimer</code> daily for infectious agents - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Updates patch-level state variables:     \u2022 <code>I[t, i]</code>: infectious count at tick <code>t</code> in node <code>i</code>     \u2022 <code>R[t, i]</code>: recovered count     \u2022 <code>recovered[t, i]</code>: number of recoveries during tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected individuals per patch - <code>infdurdist</code>: function returning infection durations - <code>infdurmin</code>: minimum infectious period (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: countdown timers per agent - <code>model.nodes.I[t]</code>, <code>.R[t]</code>: infectious and recovered counts per patch - <code>model.nodes.recovered[t]</code>: daily recoveries per patch</p> <p>Step Behavior: - Infectious agents decrement <code>itimer</code> - When <code>itimer == 0</code>, agent state is set to <code>RECOVERED</code> - Patch-level <code>I</code> and <code>R</code> are updated; <code>recovered</code> logs today's transitions</p> <p>Validation: - Ensures internal consistency between agent state and timer - Confirms agents with <code>itimer == 1</code> recover exactly one day later - Validates population conservation (<code>S + I + R = N</code>)</p> <p>Plotting: The <code>plot()</code> method shows per-node and total infectious counts across time.</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     SIR.Recovered(model),     ... ]</p>"},{"location":"reference/laser/generic/SEIR/#laser.generic.SEIR.Infectious.step","title":"<code>laser.generic.SEIR.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/SEIR/#laser.generic.SEIR.Recovered","title":"<code>laser.generic.SEIR.Recovered(model, validating=False)</code>","text":"<p>Recovered Component for SIR/SEIR Models (Permanent Immunity)</p> <p>This component manages agents in the recovered state in models where immunity does not wane (i.e., once recovered, agents stay recovered permanently). It tracks the number of recovered individuals over time at the patch level, but performs no active transitions itself \u2014 recovery transitions must be handled by upstream components.</p> <p>Responsibilities: - Initializes agents as recovered if specified in <code>model.scenario.R</code> - Tracks per-patch recovered counts over time in <code>model.nodes.R</code> - Verifies consistency between agent state and aggregate recovered counts - Propagates recovered totals forward unchanged (unless modified by other components)</p> <p>Required Inputs: - <code>model.scenario.R</code>: number of initially recovered individuals per node</p> <p>Outputs: - <code>model.nodes.R[t, i]</code>: number of recovered individuals at tick <code>t</code> in node <code>i</code></p> <p>Step Behavior: - At each tick, carries forward:     R[t+1] = R[t] - This component does not change any agent's state or internal timers</p> <p>\ud83e\uddea Validation: - Ensures per-agent state matches aggregate <code>R</code> counts before and after each step - Detects accidental changes to recovered counts not explained by upstream logic</p> <p>Plotting: The <code>plot()</code> method shows per-node and total recovered counts over time.</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     Recovered(model),  # passive tracker, assumes recovery handled upstream ]</p>"},{"location":"reference/laser/generic/SEIR/#laser.generic.SEIR.Susceptible","title":"<code>laser.generic.SEIR.Susceptible(model, validating=False)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p> Step Behavior <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p> Example <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/SEIR/#laser.generic.SEIR.Transmission","title":"<code>laser.generic.SEIR.Transmission(model, expdurdist, expdurmin=1, seasonality=None, validating=False)</code>","text":"<p>Transmission component for an SEIR/SEIRS model with S -&gt; E transition and incubation duration.</p> <pre><code>This component simulates the transition from `SUSCEPTIBLE` to `EXPOSED` in models\nwhere infection includes an incubation period before agents become infectious.\nIt handles stochastic exposure based on per-node force of infection (FOI), and\nassigns individual incubation timers to newly exposed agents.\n\nAgents transition from Susceptible to Exposed based on force of infection.\nSets newly exposed agents' infection timers (etimer) based on `expdurdist` and `expdurmin`.\nTracks number of new infections each tick in `model.nodes.newly_infected`.\n\nResponsibilities:\n- Computes force of infection `\u03bb = \u03b2 * (I / N)` at each tick per node\n- Adjusts FOI using `model.network` for inter-node transmission coupling. Required but can be nullified by filling with all zeros.\n- Applies FOI to susceptible agents to determine exposure\n- Assigns incubation durations (`etimer`) to each newly exposed agent\n- Updates node-level counts for `S` and `E` and logs daily incidence\n\nRequired Inputs:\n- `model.params.beta`: global transmission rate\n- `model.network`: [n x n] matrix for FOI migration\n- `expdurdist(tick, node)`: callable that samples the exposure/incubation duration distribution\n- `expdurmin`: minimum incubation period (default = 1)\n\nOutputs:\n- `model.nodes.forces[t, i]`: computed FOI in node `i` at tick `t`\n- `model.nodes.incidence[t, i]`: new exposures per node per day\n- `model.people.etimer`: per-agent incubation countdown\n\nStep Behavior:\n- Computes FOI (`\u03bb`) for each node\n- Optionally applies inter-node infection pressure via `model.network`\n- Converts FOI into a Bernoulli probability using: `p = 1 - exp(-\u03bb)`\n- Infects susceptible agents probabilistically\n- Updates state and records incidence\n\nValidation:\n- Validates consistency between agent states and patch-level counts before and after tick\n- Confirms that `incidence[t] == E[t+1] - E[t]`\n\nPlotting:\nThe `plot()` method shows per-node FOI (`\u03bb`) trajectories over time.\n\nExample:\n    model.components = [\n        SIR.Susceptible(model),\n        TransmissionSE(model, expdurdist),\n        Exposed(model, ...),\n        InfectiousIR(model, ...),\n        Recovered(model),\n    ]\n</code></pre> <p>Initializes the TransmissionSE component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The epidemiological model instance.</p> required <code>expdurdist</code> <code>Callable[[int, int], float]</code> <p>A function that returns the incubation duration for a given tick and node.</p> required <code>expdurmin</code> <code>int</code> <p>Minimum incubation duration.</p> <code>1</code> <code>seasonality</code> <code>Union[ValuesMap, ndarray]</code> <p>Seasonality modifier for transmission rate. Defaults to None.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Enable component-level validation. Defaults to False.</p> <code>False</code>"},{"location":"reference/laser/generic/SEIRS/","title":"laser.generic.SEIRS","text":""},{"location":"reference/laser/generic/SEIRS/#laser.generic.SEIRS","title":"<code>laser.generic.SEIRS</code>","text":"<p>Export required components for an SEIRS model.</p> <p>Agents transition from Susceptible to Exposed upon infection, with an incubation duration. Agents transition from Exposed to Infectious after the incubation period and are infectious for a duration. Agents transition from Infectious to Recovered after the infectious period. Agents transition from Recovered back to Susceptible upon waning immunity after the waning duration</p>"},{"location":"reference/laser/generic/SEIRS/#laser.generic.SEIRS.Exposed","title":"<code>laser.generic.SEIRS.Exposed(model, expdurdist, infdurdist, expdurmin=1, infdurmin=1, validating=False)</code>","text":"<p>Exposed Component for SEIR/SEIRS Models with Explicit Incubation Period</p> <p>This component handles the incubation phase in models where agents must transition from an 'exposed' (E) state to 'infectious' (I) after a delay. It supports custom incubation and infectious duration distributions and handles both initialization and per-tick dynamics.</p> <p>Agents transition from Exposed to Infectious when their incubation timer (etimer) expires. Tracks number of agents becoming infectious each tick in <code>model.nodes.newly_infectious</code>.</p> <p>Responsibilities: - Initializes exposed individuals at time 0 (if provided in the scenario) - Assigns and tracks per-agent incubation timers (<code>etimer</code>) - Transitions agents from <code>EXPOSED</code> to <code>INFECTIOUS</code> when <code>etimer == 0</code> - Assigns new infection timers (<code>itimer</code>) upon becoming infectious - Updates patch-level EXPOSED (<code>E</code>) and INFECTIOUS case counts - Provides validation hooks for state and timer consistency</p> <p>Required Inputs: - <code>model.scenario.E</code>: initial count of exposed individuals per node (optional) - <code>expdurdist</code>: callable returning sampled incubation durations - <code>infdurdist</code>: callable returning sampled infectious durations - <code>expdurmin</code>: minimum incubation period (default 1 day) - <code>infdurmin</code>: minimum infectious period (default 1 day)</p> <p>Outputs: - <code>model.people.etimer</code>: agent-level incubation timer - <code>model.nodes.E[t, i]</code>: number of exposed individuals at time <code>t</code> in node <code>i</code> - <code>model.nodes.newly_infectious[t, i]</code>: number of newly infectious cases per node per day</p> <p>Validation: - Ensures consistency between individual states and <code>etimer</code> values - Ensures that agents becoming infectious have valid <code>itimer</code> values assigned - Prevents agents with expired <code>etimer</code> from remaining in EXPOSED state</p> Step Behavior <p>For each agent:     - Decrease <code>etimer</code>     - If <code>etimer == 0</code>, change state to <code>INFECTIOUS</code> and assign <code>itimer</code>     - Update <code>model.nodes.E</code> and <code>model.nodes.I</code> counts accordingly</p> <p>Plotting: The <code>plot()</code> method provides a time series of exposed individuals per node and total across all nodes.</p> Example <p>model.components = [     SIR.Susceptible(model),     Exposed(model, expdurdist, infdurdist),     SIR.Infectious(model, infdurdist),     ... ]</p>"},{"location":"reference/laser/generic/SEIRS/#laser.generic.SEIRS.Infectious","title":"<code>laser.generic.SEIRS.Infectious(model, infdurdist, wandurdist, infdurmin=1, wandurmin=1, validating=False)</code>","text":"<p>Infectious Component for SIRS/SEIRS Models (Recovery with Waning Immunity)</p> <p>This component manages infectious individuals in models where recovery confers temporary immunity, after which agents become susceptible again (SIRS/SEIRS).</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Set the waning immunity timer (rtimer) upon recovery. Tracks number of agents recovering each tick in <code>model.nodes.newly_recovered</code>.</p> <p>Responsibilities: - Initializes infectious agents from <code>model.scenario.I</code> - Assigns and tracks infectious timers (<code>itimer</code>) per agent - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Assigns a waning immunity timer (<code>rtimer</code>) upon recovery - Updates patch-level state:     \u2022 <code>I[t, i]</code>: current infectious count     \u2022 <code>R[t, i]</code>: current recovered count     \u2022 <code>recovered[t, i]</code>: number of agents recovering on tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected agents per node - <code>infdurdist</code>: function that samples the infectious duration distribution - <code>wandurdist</code>: function that samples the waning immunity duration distribution - <code>infdurmin</code>: minimum infectious period (default = 1 day) - <code>wandurmin</code>: minimum duration of immunity (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: days remaining in the infectious state - <code>model.people.rtimer</code>: days remaining in the recovered state - <code>model.nodes.I</code>, <code>model.nodes.R</code>: counts per node per tick - <code>model.nodes.recovered[t]</code>: number of recoveries recorded on tick <code>t</code></p> <p>Step Behavior: - Infectious agents decrement their <code>itimer</code> - When <code>itimer == 0</code>, agents become recovered and receive an <code>rtimer</code> - Patch-level totals are updated - Downstream components (e.g., <code>Recovered</code>) handle <code>rtimer</code> countdown and eventual return to <code>SUSCEPTIBLE</code></p> <p>Validation: - Ensures timer consistency and population accounting - Confirms correct infectious-to-recovered transitions - Can be chained with recovery and waning components for full SIRS/SEIRS loops</p> <p>Plotting: Two plots are provided: 1. Infected counts per node 2. Total infected and recovered counts across time</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIRS(model, infdurdist, wandurdist),     Exposed(model, ...),     Recovered(model), ]</p>"},{"location":"reference/laser/generic/SEIRS/#laser.generic.SEIRS.Infectious.step","title":"<code>laser.generic.SEIRS.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/SEIRS/#laser.generic.SEIRS.Recovered","title":"<code>laser.generic.SEIRS.Recovered(model, wandurdist, wandurmin=1, validating=False)</code>","text":"<p>Recovered Component for SIRS/SEIRS Models (Waning Immunity)</p> <p>This component manages agents in the recovered state in models where immunity is temporary. It supports per-agent recovery timers, enabling individuals to return to the susceptible state after a configurable waning period. This is essential for SEIRS/SIRS model dynamics.</p> <p>Agents transition from Recovered back to Susceptible after the waning immunity period (rtimer). Tracks number of agents losing immunity each tick in <code>model.nodes.newly_waned</code>.</p> <p>Responsibilities: - Initializes agents in the <code>RECOVERED</code> state using <code>model.scenario.R</code> - Assigns <code>rtimer</code> values to track the duration of immunity - Decrements <code>rtimer</code> each tick; transitions agents to <code>SUSCEPTIBLE</code> when <code>rtimer == 0</code> - Updates patch-level counts:     \u2022 <code>R[t, i]</code>: number of recovered individuals in node <code>i</code> at time <code>t</code>     \u2022 <code>waned[t, i]</code>: number of agents who re-entered susceptibility on time step <code>t</code></p> <p>Required Inputs: - <code>model.scenario.R</code>: initial number of recovered individuals per node - <code>wandurdist</code>: a function sampling the waning immunity duration distribution - <code>wandurmin</code>: minimum duration of immunity (default = 1 time step)</p> <p>Outputs: - <code>model.people.rtimer</code>: per-agent countdown to immunity expiration - <code>model.nodes.R</code>: recovered count per patch per timestep - <code>model.nodes.waned</code>: number of immunity losses per patch per tick</p> <p>Step Behavior: - Agents with <code>state == RECOVERED</code> decrement <code>rtimer</code> - When <code>rtimer == 0</code>, they return to <code>SUSCEPTIBLE</code> - <code>R</code> and <code>S</code> counts are updated to reflect this transition - <code>waned[t]</code> logs the number of agents who lost immunity on time step <code>t</code></p> <p>Validation: - Ensures population conservation and consistency between agent states and patch totals - Detects unexpected changes in <code>R</code> or invalid transitions</p> <p>Plotting: The <code>plot()</code> method provides two views: 1. Per-node recovered trajectories 2. Total recovered and waned agents over time</p> Example <p>model.components = [     SIR.Susceptible(model),     SEIRS.Infectious(model, infdurdist, wandurdist),     Exposed(model, ...),     RecoveredRS(model, wandurdist), ]</p>"},{"location":"reference/laser/generic/SEIRS/#laser.generic.SEIRS.Susceptible","title":"<code>laser.generic.SEIRS.Susceptible(model, validating=False)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p> Step Behavior <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p> Example <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/SEIRS/#laser.generic.SEIRS.Transmission","title":"<code>laser.generic.SEIRS.Transmission(model, expdurdist, expdurmin=1, seasonality=None, validating=False)</code>","text":"<p>Transmission component for an SEIR/SEIRS model with S -&gt; E transition and incubation duration.</p> <pre><code>This component simulates the transition from `SUSCEPTIBLE` to `EXPOSED` in models\nwhere infection includes an incubation period before agents become infectious.\nIt handles stochastic exposure based on per-node force of infection (FOI), and\nassigns individual incubation timers to newly exposed agents.\n\nAgents transition from Susceptible to Exposed based on force of infection.\nSets newly exposed agents' infection timers (etimer) based on `expdurdist` and `expdurmin`.\nTracks number of new infections each tick in `model.nodes.newly_infected`.\n\nResponsibilities:\n- Computes force of infection `\u03bb = \u03b2 * (I / N)` at each tick per node\n- Adjusts FOI using `model.network` for inter-node transmission coupling. Required but can be nullified by filling with all zeros.\n- Applies FOI to susceptible agents to determine exposure\n- Assigns incubation durations (`etimer`) to each newly exposed agent\n- Updates node-level counts for `S` and `E` and logs daily incidence\n\nRequired Inputs:\n- `model.params.beta`: global transmission rate\n- `model.network`: [n x n] matrix for FOI migration\n- `expdurdist(tick, node)`: callable that samples the exposure/incubation duration distribution\n- `expdurmin`: minimum incubation period (default = 1)\n\nOutputs:\n- `model.nodes.forces[t, i]`: computed FOI in node `i` at tick `t`\n- `model.nodes.incidence[t, i]`: new exposures per node per day\n- `model.people.etimer`: per-agent incubation countdown\n\nStep Behavior:\n- Computes FOI (`\u03bb`) for each node\n- Optionally applies inter-node infection pressure via `model.network`\n- Converts FOI into a Bernoulli probability using: `p = 1 - exp(-\u03bb)`\n- Infects susceptible agents probabilistically\n- Updates state and records incidence\n\nValidation:\n- Validates consistency between agent states and patch-level counts before and after tick\n- Confirms that `incidence[t] == E[t+1] - E[t]`\n\nPlotting:\nThe `plot()` method shows per-node FOI (`\u03bb`) trajectories over time.\n\nExample:\n    model.components = [\n        SIR.Susceptible(model),\n        TransmissionSE(model, expdurdist),\n        Exposed(model, ...),\n        InfectiousIR(model, ...),\n        Recovered(model),\n    ]\n</code></pre> <p>Initializes the TransmissionSE component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The epidemiological model instance.</p> required <code>expdurdist</code> <code>Callable[[int, int], float]</code> <p>A function that returns the incubation duration for a given tick and node.</p> required <code>expdurmin</code> <code>int</code> <p>Minimum incubation duration.</p> <code>1</code> <code>seasonality</code> <code>Union[ValuesMap, ndarray]</code> <p>Seasonality modifier for transmission rate. Defaults to None.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Enable component-level validation. Defaults to False.</p> <code>False</code>"},{"location":"reference/laser/generic/SI/","title":"laser.generic.SI","text":""},{"location":"reference/laser/generic/SI/#laser.generic.SI","title":"<code>laser.generic.SI</code>","text":"<p>Components for an SI model.</p> <p>Agents transition from Susceptible to Infectious upon infection. Agents remain in the Infectious state indefinitely (no recovery).</p>"},{"location":"reference/laser/generic/SI/#laser.generic.SI.Infectious","title":"<code>laser.generic.SI.Infectious(model, validating=False)</code>","text":"<p>Infectious Component for SI Models (No Recovery)</p> <p>This component manages the infectious state in SI-style epidemic models where agents remain infectious indefinitely. It is appropriate for use in models without a recovered or removed state (i.e., no <code>R</code> compartment).</p> <p>Responsibilities: - Initializes agents as infectious based on <code>model.scenario.I</code> - Tracks the number of infectious individuals (<code>I</code>) in each patch over time - Maintains per-tick, per-node counts in <code>model.nodes.I</code> - Validates consistency between agent states and patch-level totals</p> <p>Required Inputs: - <code>model.scenario.I</code>: array of initial infected counts per patch - <code>model.people.state</code>: infection state per agent - <code>model.people.nodeid</code>: patch assignment per agent - <code>model.params.nticks</code>: number of timesteps to simulate</p> <p>Outputs: - <code>model.nodes.I[t, i]</code>: number of infectious individuals in node <code>i</code> at time <code>t</code></p> Step Behavior <p>For each timestep <code>t</code>, this component copies:     I[t+1] = I[t] (No recovery or removal; new infections may be added externally.)</p> <p>Validation: - Ensures that patch-level infectious counts (<code>model.nodes.I</code>) match the agent-level state - Asserts that the sum of <code>S</code> and <code>I</code> matches total population at initialization - Validates that infected counts do not change unexpectedly (unless altered by another component)</p> <p>Plotting: The <code>plot()</code> method shows the number of infectious agents per patch and in total across time.</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousSI(model),     SIR.Transmission(model, ...), ]</p>"},{"location":"reference/laser/generic/SI/#laser.generic.SI.Infectious.step","title":"<code>laser.generic.SI.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/SI/#laser.generic.SI.Susceptible","title":"<code>laser.generic.SI.Susceptible(model, validating=False)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p> Step Behavior <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p> Example <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/SI/#laser.generic.SI.Transmission","title":"<code>laser.generic.SI.Transmission(model, seasonality=None, validating=False)</code>","text":"<p>Transmission Component for SI-Style Models (S \u2192 I Only, No Recovery)</p> <p>This component simulates the transmission process in simple epidemic models where agents move from the <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> state and remain infectious indefinitely. It computes the force of infection (FOI) for each patch and applies it stochastically to susceptible agents.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Tracks number of new infections each tick in <code>model.nodes.newly_infected</code>.</p> <p>Responsibilities: - Computes per-node force of infection (<code>\u03bb</code>) at each tick:     \u03bb = \u03b2 * (I / N), with spatial coupling via a migration matrix - Applies probabilistic infection to susceptible agents using <code>nb_transmission_step</code> - Updates per-node <code>S</code> and <code>I</code> counts accordingly - Tracks new infections (incidence) and FOI values per node and tick</p> <p>Required Inputs: - <code>model.nodes.I[t]</code>: number of infectious agents per node at tick <code>t</code> - <code>model.nodes.S[t]</code>: number of susceptible agents per node at tick <code>t</code> - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: matrix of spatial coupling between nodes</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: force of infection in node <code>i</code> at tick <code>t</code> - <code>model.nodes.incidence[t, i]</code>: number of new infections in node <code>i</code> at tick <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between state transitions and incidence records - Checks conservation of population in <code>S</code> and <code>I</code> states - Validates <code>incidence[t] == I[t+1] - I[t]</code></p> <p>Plotting: The <code>plot()</code> method displays the force of infection over time per node.</p> Example <p>model.components = [     SIR.Susceptible(model),     TransmissionSIx(model),     InfectiousSI(model), ]</p> <p>Transmission Component for SI-Style Models (S \u2192 I Only, No Recovery)</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The epidemic model instance.</p> required <code>seasonality</code> <code>Union[ValuesMap, ndarray]</code> <p>Seasonality modifier for transmission rate. Can be a ValuesMap or a precomputed array. Defaults to None.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Enable component-level validation. Defaults to False.</p> <code>False</code>"},{"location":"reference/laser/generic/SIR/","title":"laser.generic.SIR","text":""},{"location":"reference/laser/generic/SIR/#laser.generic.SIR","title":"<code>laser.generic.SIR</code>","text":"<p>Export required components for an SIR model.</p> <p>Agents transition from Susceptible to Infectious upon infection and are infectious for a duration. Agents transition from Infectious to Recovered upon recovery. Agents remain in the Recovered state indefinitely (no waning immunity).</p>"},{"location":"reference/laser/generic/SIR/#laser.generic.SIR.Infectious","title":"<code>laser.generic.SIR.Infectious(model, infdurdist, infdurmin=1, validating=False)</code>","text":"<p>Infectious Component for SIR/SEIR Models (With Recovery to Immune)</p> <p>This component manages agents in the infectious state for models where infected individuals recover permanently (i.e., transition to a <code>RECOVERED</code> state without waning). It supports agent-level infection durations and patch-level tracking of recoveries over time.</p> <p>Infectious component for an SIR/SEIR model - includes infectious duration, no waning immunity in newly_recovered state.</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Tracks number of agents recovering each tick in <code>model.nodes.newly_recovered</code>.</p> <p>Responsibilities: - Initializes infected agents and their infection timers (<code>itimer</code>) based on scenario input - Decrements <code>itimer</code> daily for infectious agents - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Updates patch-level state variables:     \u2022 <code>I[t, i]</code>: infectious count at tick <code>t</code> in node <code>i</code>     \u2022 <code>R[t, i]</code>: recovered count     \u2022 <code>recovered[t, i]</code>: number of recoveries during tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected individuals per patch - <code>infdurdist</code>: function returning infection durations - <code>infdurmin</code>: minimum infectious period (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: countdown timers per agent - <code>model.nodes.I[t]</code>, <code>.R[t]</code>: infectious and recovered counts per patch - <code>model.nodes.recovered[t]</code>: daily recoveries per patch</p> <p>Step Behavior: - Infectious agents decrement <code>itimer</code> - When <code>itimer == 0</code>, agent state is set to <code>RECOVERED</code> - Patch-level <code>I</code> and <code>R</code> are updated; <code>recovered</code> logs today's transitions</p> <p>Validation: - Ensures internal consistency between agent state and timer - Confirms agents with <code>itimer == 1</code> recover exactly one day later - Validates population conservation (<code>S + I + R = N</code>)</p> <p>Plotting: The <code>plot()</code> method shows per-node and total infectious counts across time.</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     SIR.Recovered(model),     ... ]</p>"},{"location":"reference/laser/generic/SIR/#laser.generic.SIR.Infectious.step","title":"<code>laser.generic.SIR.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/SIR/#laser.generic.SIR.Recovered","title":"<code>laser.generic.SIR.Recovered(model, validating=False)</code>","text":"<p>Recovered Component for SIR/SEIR Models (Permanent Immunity)</p> <p>This component manages agents in the recovered state in models where immunity does not wane (i.e., once recovered, agents stay recovered permanently). It tracks the number of recovered individuals over time at the patch level, but performs no active transitions itself \u2014 recovery transitions must be handled by upstream components.</p> <p>Responsibilities: - Initializes agents as recovered if specified in <code>model.scenario.R</code> - Tracks per-patch recovered counts over time in <code>model.nodes.R</code> - Verifies consistency between agent state and aggregate recovered counts - Propagates recovered totals forward unchanged (unless modified by other components)</p> <p>Required Inputs: - <code>model.scenario.R</code>: number of initially recovered individuals per node</p> <p>Outputs: - <code>model.nodes.R[t, i]</code>: number of recovered individuals at tick <code>t</code> in node <code>i</code></p> <p>Step Behavior: - At each tick, carries forward:     R[t+1] = R[t] - This component does not change any agent's state or internal timers</p> <p>\ud83e\uddea Validation: - Ensures per-agent state matches aggregate <code>R</code> counts before and after each step - Detects accidental changes to recovered counts not explained by upstream logic</p> <p>Plotting: The <code>plot()</code> method shows per-node and total recovered counts over time.</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     Recovered(model),  # passive tracker, assumes recovery handled upstream ]</p>"},{"location":"reference/laser/generic/SIR/#laser.generic.SIR.Susceptible","title":"<code>laser.generic.SIR.Susceptible(model, validating=False)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p> Step Behavior <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p> Example <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/SIR/#laser.generic.SIR.Transmission","title":"<code>laser.generic.SIR.Transmission(model, infdurdist, infdurmin=1, seasonality=None, validating=False)</code>","text":"<p>Transmission Component for SIS/SIR/SIRS Models (S \u2192 I with Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> in models where infectious individuals have a finite infection duration (<code>itimer</code>). It supports full spatial coupling and allows infection durations to vary by node and tick.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Sets newly infectious agents' infection timers (itimer) based on <code>infdurdist</code> and <code>infdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.newly_infected</code>.</p> <p>Responsibilities: - Computes force of infection (FOI) <code>\u03bb = \u03b2 * (I / N)</code> per patch each tick - Applies optional spatial coupling via <code>model.network</code> (infection pressure transfer) - Converts FOI into Bernoulli probabilities using <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents stochastically, assigning per-agent <code>itimer</code> - Updates patch-level susceptible (<code>S</code>) and infectious (<code>I</code>) counts - Records number of new infections per tick in <code>model.nodes.incidence</code></p> <p>Required Inputs: - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: [n x n] matrix of transmission coupling - <code>infdurdist(tick, node)</code>: callable sampling the infectious duration distribution - <code>model.people.itimer</code>: preallocated per-agent infection timer</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at time <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new infections in node <code>i</code> on time step <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between incidence and change in <code>I</code> - Checks for correct state and population accounting before and after tick</p> <p>Plotting: The <code>plot()</code> method visualizes per-node FOI (<code>\u03bb</code>) over simulation time.</p> Example <p>model.components = [     SIR.Susceptible(model),     TransmissionSI(model, infdurdist),     InfectiousIR(model, infdurdist), ]</p> <p>Initializes the TransmissionSI component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <code>Callable[[int, int], float]</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <code>int</code> <p>Minimum infectious duration.</p> <code>1</code> <code>seasonality</code> <code>Union[ValuesMap, ndarray]</code> <p>Seasonality modifier for transmission rate. Defaults to None.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Enable component-level validation. Defaults to False.</p> <code>False</code>"},{"location":"reference/laser/generic/SIRS/","title":"laser.generic.SIRS","text":""},{"location":"reference/laser/generic/SIRS/#laser.generic.SIRS","title":"<code>laser.generic.SIRS</code>","text":"<p>Export required components for an SIRS model.</p> <p>Agents transition from Susceptible to Infectious upon infection. Agents transition from Infectious to Recovered upon recovery after the infectious duration. Agents transition from Recovered back to Susceptible upon waning immunity after the waning duration.</p>"},{"location":"reference/laser/generic/SIRS/#laser.generic.SIRS.Infectious","title":"<code>laser.generic.SIRS.Infectious(model, infdurdist, wandurdist, infdurmin=1, wandurmin=1, validating=False)</code>","text":"<p>Infectious Component for SIRS/SEIRS Models (Recovery with Waning Immunity)</p> <p>This component manages infectious individuals in models where recovery confers temporary immunity, after which agents become susceptible again (SIRS/SEIRS).</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Set the waning immunity timer (rtimer) upon recovery. Tracks number of agents recovering each tick in <code>model.nodes.newly_recovered</code>.</p> <p>Responsibilities: - Initializes infectious agents from <code>model.scenario.I</code> - Assigns and tracks infectious timers (<code>itimer</code>) per agent - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Assigns a waning immunity timer (<code>rtimer</code>) upon recovery - Updates patch-level state:     \u2022 <code>I[t, i]</code>: current infectious count     \u2022 <code>R[t, i]</code>: current recovered count     \u2022 <code>recovered[t, i]</code>: number of agents recovering on tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected agents per node - <code>infdurdist</code>: function that samples the infectious duration distribution - <code>wandurdist</code>: function that samples the waning immunity duration distribution - <code>infdurmin</code>: minimum infectious period (default = 1 day) - <code>wandurmin</code>: minimum duration of immunity (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: days remaining in the infectious state - <code>model.people.rtimer</code>: days remaining in the recovered state - <code>model.nodes.I</code>, <code>model.nodes.R</code>: counts per node per tick - <code>model.nodes.recovered[t]</code>: number of recoveries recorded on tick <code>t</code></p> <p>Step Behavior: - Infectious agents decrement their <code>itimer</code> - When <code>itimer == 0</code>, agents become recovered and receive an <code>rtimer</code> - Patch-level totals are updated - Downstream components (e.g., <code>Recovered</code>) handle <code>rtimer</code> countdown and eventual return to <code>SUSCEPTIBLE</code></p> <p>Validation: - Ensures timer consistency and population accounting - Confirms correct infectious-to-recovered transitions - Can be chained with recovery and waning components for full SIRS/SEIRS loops</p> <p>Plotting: Two plots are provided: 1. Infected counts per node 2. Total infected and recovered counts across time</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIRS(model, infdurdist, wandurdist),     Exposed(model, ...),     Recovered(model), ]</p>"},{"location":"reference/laser/generic/SIRS/#laser.generic.SIRS.Infectious.step","title":"<code>laser.generic.SIRS.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/SIRS/#laser.generic.SIRS.Recovered","title":"<code>laser.generic.SIRS.Recovered(model, wandurdist, wandurmin=1, validating=False)</code>","text":"<p>Recovered Component for SIRS/SEIRS Models (Waning Immunity)</p> <p>This component manages agents in the recovered state in models where immunity is temporary. It supports per-agent recovery timers, enabling individuals to return to the susceptible state after a configurable waning period. This is essential for SEIRS/SIRS model dynamics.</p> <p>Agents transition from Recovered back to Susceptible after the waning immunity period (rtimer). Tracks number of agents losing immunity each tick in <code>model.nodes.newly_waned</code>.</p> <p>Responsibilities: - Initializes agents in the <code>RECOVERED</code> state using <code>model.scenario.R</code> - Assigns <code>rtimer</code> values to track the duration of immunity - Decrements <code>rtimer</code> each tick; transitions agents to <code>SUSCEPTIBLE</code> when <code>rtimer == 0</code> - Updates patch-level counts:     \u2022 <code>R[t, i]</code>: number of recovered individuals in node <code>i</code> at time <code>t</code>     \u2022 <code>waned[t, i]</code>: number of agents who re-entered susceptibility on time step <code>t</code></p> <p>Required Inputs: - <code>model.scenario.R</code>: initial number of recovered individuals per node - <code>wandurdist</code>: a function sampling the waning immunity duration distribution - <code>wandurmin</code>: minimum duration of immunity (default = 1 time step)</p> <p>Outputs: - <code>model.people.rtimer</code>: per-agent countdown to immunity expiration - <code>model.nodes.R</code>: recovered count per patch per timestep - <code>model.nodes.waned</code>: number of immunity losses per patch per tick</p> <p>Step Behavior: - Agents with <code>state == RECOVERED</code> decrement <code>rtimer</code> - When <code>rtimer == 0</code>, they return to <code>SUSCEPTIBLE</code> - <code>R</code> and <code>S</code> counts are updated to reflect this transition - <code>waned[t]</code> logs the number of agents who lost immunity on time step <code>t</code></p> <p>Validation: - Ensures population conservation and consistency between agent states and patch totals - Detects unexpected changes in <code>R</code> or invalid transitions</p> <p>Plotting: The <code>plot()</code> method provides two views: 1. Per-node recovered trajectories 2. Total recovered and waned agents over time</p> Example <p>model.components = [     SIR.Susceptible(model),     SEIRS.Infectious(model, infdurdist, wandurdist),     Exposed(model, ...),     RecoveredRS(model, wandurdist), ]</p>"},{"location":"reference/laser/generic/SIRS/#laser.generic.SIRS.Susceptible","title":"<code>laser.generic.SIRS.Susceptible(model, validating=False)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p> Step Behavior <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p> Example <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/SIRS/#laser.generic.SIRS.Transmission","title":"<code>laser.generic.SIRS.Transmission(model, infdurdist, infdurmin=1, seasonality=None, validating=False)</code>","text":"<p>Transmission Component for SIS/SIR/SIRS Models (S \u2192 I with Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> in models where infectious individuals have a finite infection duration (<code>itimer</code>). It supports full spatial coupling and allows infection durations to vary by node and tick.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Sets newly infectious agents' infection timers (itimer) based on <code>infdurdist</code> and <code>infdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.newly_infected</code>.</p> <p>Responsibilities: - Computes force of infection (FOI) <code>\u03bb = \u03b2 * (I / N)</code> per patch each tick - Applies optional spatial coupling via <code>model.network</code> (infection pressure transfer) - Converts FOI into Bernoulli probabilities using <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents stochastically, assigning per-agent <code>itimer</code> - Updates patch-level susceptible (<code>S</code>) and infectious (<code>I</code>) counts - Records number of new infections per tick in <code>model.nodes.incidence</code></p> <p>Required Inputs: - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: [n x n] matrix of transmission coupling - <code>infdurdist(tick, node)</code>: callable sampling the infectious duration distribution - <code>model.people.itimer</code>: preallocated per-agent infection timer</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at time <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new infections in node <code>i</code> on time step <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between incidence and change in <code>I</code> - Checks for correct state and population accounting before and after tick</p> <p>Plotting: The <code>plot()</code> method visualizes per-node FOI (<code>\u03bb</code>) over simulation time.</p> Example <p>model.components = [     SIR.Susceptible(model),     TransmissionSI(model, infdurdist),     InfectiousIR(model, infdurdist), ]</p> <p>Initializes the TransmissionSI component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <code>Callable[[int, int], float]</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <code>int</code> <p>Minimum infectious duration.</p> <code>1</code> <code>seasonality</code> <code>Union[ValuesMap, ndarray]</code> <p>Seasonality modifier for transmission rate. Defaults to None.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Enable component-level validation. Defaults to False.</p> <code>False</code>"},{"location":"reference/laser/generic/SIS/","title":"laser.generic.SIS","text":""},{"location":"reference/laser/generic/SIS/#laser.generic.SIS","title":"<code>laser.generic.SIS</code>","text":"<p>Export required components for an SIS model.</p> <p>Agents transition from Susceptible to Infectious upon infection and are infectious for a duration. Agents transition from Infectious back to Susceptible upon recovery.</p>"},{"location":"reference/laser/generic/SIS/#laser.generic.SIS.Infectious","title":"<code>laser.generic.SIS.Infectious(model, infdurdist, infdurmin=1, validating=False)</code>","text":"<p>Infectious Component for SIS Models (Infection + Recovery to Susceptible)</p> <p>This component handles the infectious state in SIS-style models, where agents recover from infection and immediately return to the susceptible pool. It supports per-agent infection durations and manages patch-level infectious counts over time.</p> <p>Agents transition from Infectious back to Susceptible after the infectious period (itimer). Tracks number of agents recovering each tick in <code>model.nodes.newly_recovered</code>.</p> <p>Responsibilities: - Initializes infected agents and their infection timers (<code>itimer</code>) - Decrements <code>itimer</code> daily for infectious agents - Automatically transitions agents from <code>INFECTIOUS</code> to <code>SUSCEPTIBLE</code> when <code>itimer == 0</code> - Tracks per-day recoveries at the node level in <code>model.nodes.recovered</code> - Maintains node-level <code>I</code> and <code>S</code> counts with full timestep resolution</p> <p>Required Inputs: - <code>model.scenario.I</code>: initial number of infectious agents per patch - <code>infdurdist</code>: a callable function which samples the infectious duration distribution - <code>infdurmin</code>: the minimum infection period (default = 1 time step)</p> <p>Outputs: - <code>model.people.itimer</code>: per-agent infection countdown timer - <code>model.nodes.I[t, i]</code>: number of infectious individuals at tick <code>t</code> in node <code>i</code> - <code>model.nodes.recovered[t, i]</code>: number of recoveries at tick <code>t</code> in node <code>i</code></p> Step Behavior <p>At each tick: - Infectious agents decrement their <code>itimer</code> - Agents with <code>itimer == 0</code> are transitioned back to susceptible - <code>model.nodes.I</code> is updated accordingly - Recovered counts are recorded in <code>model.nodes.recovered</code></p> <p>Validation: - Ensures consistency between agent <code>state</code> and infection timer (<code>itimer</code>) - Validates <code>I</code> census against agent-level state before and after each tick</p> <p>Plotting: The <code>plot()</code> method displays both per-node and total infectious counts over time.</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIS(model, infdurdist),     SIR.Transmission(model, ...), ]</p>"},{"location":"reference/laser/generic/SIS/#laser.generic.SIS.Infectious.step","title":"<code>laser.generic.SIS.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/SIS/#laser.generic.SIS.Susceptible","title":"<code>laser.generic.SIS.Susceptible(model, validating=False)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p> Step Behavior <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p> Example <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/SIS/#laser.generic.SIS.Transmission","title":"<code>laser.generic.SIS.Transmission(model, infdurdist, infdurmin=1, seasonality=None, validating=False)</code>","text":"<p>Transmission Component for SIS/SIR/SIRS Models (S \u2192 I with Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> in models where infectious individuals have a finite infection duration (<code>itimer</code>). It supports full spatial coupling and allows infection durations to vary by node and tick.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Sets newly infectious agents' infection timers (itimer) based on <code>infdurdist</code> and <code>infdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.newly_infected</code>.</p> <p>Responsibilities: - Computes force of infection (FOI) <code>\u03bb = \u03b2 * (I / N)</code> per patch each tick - Applies optional spatial coupling via <code>model.network</code> (infection pressure transfer) - Converts FOI into Bernoulli probabilities using <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents stochastically, assigning per-agent <code>itimer</code> - Updates patch-level susceptible (<code>S</code>) and infectious (<code>I</code>) counts - Records number of new infections per tick in <code>model.nodes.incidence</code></p> <p>Required Inputs: - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: [n x n] matrix of transmission coupling - <code>infdurdist(tick, node)</code>: callable sampling the infectious duration distribution - <code>model.people.itimer</code>: preallocated per-agent infection timer</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at time <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new infections in node <code>i</code> on time step <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between incidence and change in <code>I</code> - Checks for correct state and population accounting before and after tick</p> <p>Plotting: The <code>plot()</code> method visualizes per-node FOI (<code>\u03bb</code>) over simulation time.</p> Example <p>model.components = [     SIR.Susceptible(model),     TransmissionSI(model, infdurdist),     InfectiousIR(model, infdurdist), ]</p> <p>Initializes the TransmissionSI component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <code>Callable[[int, int], float]</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <code>int</code> <p>Minimum infectious duration.</p> <code>1</code> <code>seasonality</code> <code>Union[ValuesMap, ndarray]</code> <p>Seasonality modifier for transmission rate. Defaults to None.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Enable component-level validation. Defaults to False.</p> <code>False</code>"},{"location":"reference/laser/generic/components/","title":"laser.generic.components","text":""},{"location":"reference/laser/generic/components/#laser.generic.components","title":"<code>laser.generic.components</code>","text":""},{"location":"reference/laser/generic/components/#laser.generic.components.Exposed","title":"<code>laser.generic.components.Exposed(model, expdurdist, infdurdist, expdurmin=1, infdurmin=1, validating=False)</code>","text":"<p>Exposed Component for SEIR/SEIRS Models with Explicit Incubation Period</p> <p>This component handles the incubation phase in models where agents must transition from an 'exposed' (E) state to 'infectious' (I) after a delay. It supports custom incubation and infectious duration distributions and handles both initialization and per-tick dynamics.</p> <p>Agents transition from Exposed to Infectious when their incubation timer (etimer) expires. Tracks number of agents becoming infectious each tick in <code>model.nodes.newly_infectious</code>.</p> <p>Responsibilities: - Initializes exposed individuals at time 0 (if provided in the scenario) - Assigns and tracks per-agent incubation timers (<code>etimer</code>) - Transitions agents from <code>EXPOSED</code> to <code>INFECTIOUS</code> when <code>etimer == 0</code> - Assigns new infection timers (<code>itimer</code>) upon becoming infectious - Updates patch-level EXPOSED (<code>E</code>) and INFECTIOUS case counts - Provides validation hooks for state and timer consistency</p> <p>Required Inputs: - <code>model.scenario.E</code>: initial count of exposed individuals per node (optional) - <code>expdurdist</code>: callable returning sampled incubation durations - <code>infdurdist</code>: callable returning sampled infectious durations - <code>expdurmin</code>: minimum incubation period (default 1 day) - <code>infdurmin</code>: minimum infectious period (default 1 day)</p> <p>Outputs: - <code>model.people.etimer</code>: agent-level incubation timer - <code>model.nodes.E[t, i]</code>: number of exposed individuals at time <code>t</code> in node <code>i</code> - <code>model.nodes.newly_infectious[t, i]</code>: number of newly infectious cases per node per day</p> <p>Validation: - Ensures consistency between individual states and <code>etimer</code> values - Ensures that agents becoming infectious have valid <code>itimer</code> values assigned - Prevents agents with expired <code>etimer</code> from remaining in EXPOSED state</p> Step Behavior <p>For each agent:     - Decrease <code>etimer</code>     - If <code>etimer == 0</code>, change state to <code>INFECTIOUS</code> and assign <code>itimer</code>     - Update <code>model.nodes.E</code> and <code>model.nodes.I</code> counts accordingly</p> <p>Plotting: The <code>plot()</code> method provides a time series of exposed individuals per node and total across all nodes.</p> Example <p>model.components = [     SIR.Susceptible(model),     Exposed(model, expdurdist, infdurdist),     SIR.Infectious(model, infdurdist),     ... ]</p>"},{"location":"reference/laser/generic/components/#laser.generic.components.InfectiousIR","title":"<code>laser.generic.components.InfectiousIR(model, infdurdist, infdurmin=1, validating=False)</code>","text":"<p>Infectious Component for SIR/SEIR Models (With Recovery to Immune)</p> <p>This component manages agents in the infectious state for models where infected individuals recover permanently (i.e., transition to a <code>RECOVERED</code> state without waning). It supports agent-level infection durations and patch-level tracking of recoveries over time.</p> <p>Infectious component for an SIR/SEIR model - includes infectious duration, no waning immunity in newly_recovered state.</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Tracks number of agents recovering each tick in <code>model.nodes.newly_recovered</code>.</p> <p>Responsibilities: - Initializes infected agents and their infection timers (<code>itimer</code>) based on scenario input - Decrements <code>itimer</code> daily for infectious agents - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Updates patch-level state variables:     \u2022 <code>I[t, i]</code>: infectious count at tick <code>t</code> in node <code>i</code>     \u2022 <code>R[t, i]</code>: recovered count     \u2022 <code>recovered[t, i]</code>: number of recoveries during tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected individuals per patch - <code>infdurdist</code>: function returning infection durations - <code>infdurmin</code>: minimum infectious period (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: countdown timers per agent - <code>model.nodes.I[t]</code>, <code>.R[t]</code>: infectious and recovered counts per patch - <code>model.nodes.recovered[t]</code>: daily recoveries per patch</p> <p>Step Behavior: - Infectious agents decrement <code>itimer</code> - When <code>itimer == 0</code>, agent state is set to <code>RECOVERED</code> - Patch-level <code>I</code> and <code>R</code> are updated; <code>recovered</code> logs today's transitions</p> <p>Validation: - Ensures internal consistency between agent state and timer - Confirms agents with <code>itimer == 1</code> recover exactly one day later - Validates population conservation (<code>S + I + R = N</code>)</p> <p>Plotting: The <code>plot()</code> method shows per-node and total infectious counts across time.</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     SIR.Recovered(model),     ... ]</p>"},{"location":"reference/laser/generic/components/#laser.generic.components.InfectiousIR.step","title":"<code>laser.generic.components.InfectiousIR.step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/components/#laser.generic.components.InfectiousIRS","title":"<code>laser.generic.components.InfectiousIRS(model, infdurdist, wandurdist, infdurmin=1, wandurmin=1, validating=False)</code>","text":"<p>Infectious Component for SIRS/SEIRS Models (Recovery with Waning Immunity)</p> <p>This component manages infectious individuals in models where recovery confers temporary immunity, after which agents become susceptible again (SIRS/SEIRS).</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Set the waning immunity timer (rtimer) upon recovery. Tracks number of agents recovering each tick in <code>model.nodes.newly_recovered</code>.</p> <p>Responsibilities: - Initializes infectious agents from <code>model.scenario.I</code> - Assigns and tracks infectious timers (<code>itimer</code>) per agent - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Assigns a waning immunity timer (<code>rtimer</code>) upon recovery - Updates patch-level state:     \u2022 <code>I[t, i]</code>: current infectious count     \u2022 <code>R[t, i]</code>: current recovered count     \u2022 <code>recovered[t, i]</code>: number of agents recovering on tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected agents per node - <code>infdurdist</code>: function that samples the infectious duration distribution - <code>wandurdist</code>: function that samples the waning immunity duration distribution - <code>infdurmin</code>: minimum infectious period (default = 1 day) - <code>wandurmin</code>: minimum duration of immunity (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: days remaining in the infectious state - <code>model.people.rtimer</code>: days remaining in the recovered state - <code>model.nodes.I</code>, <code>model.nodes.R</code>: counts per node per tick - <code>model.nodes.recovered[t]</code>: number of recoveries recorded on tick <code>t</code></p> <p>Step Behavior: - Infectious agents decrement their <code>itimer</code> - When <code>itimer == 0</code>, agents become recovered and receive an <code>rtimer</code> - Patch-level totals are updated - Downstream components (e.g., <code>Recovered</code>) handle <code>rtimer</code> countdown and eventual return to <code>SUSCEPTIBLE</code></p> <p>Validation: - Ensures timer consistency and population accounting - Confirms correct infectious-to-recovered transitions - Can be chained with recovery and waning components for full SIRS/SEIRS loops</p> <p>Plotting: Two plots are provided: 1. Infected counts per node 2. Total infected and recovered counts across time</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIRS(model, infdurdist, wandurdist),     Exposed(model, ...),     Recovered(model), ]</p>"},{"location":"reference/laser/generic/components/#laser.generic.components.InfectiousIRS.step","title":"<code>laser.generic.components.InfectiousIRS.step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/components/#laser.generic.components.InfectiousIS","title":"<code>laser.generic.components.InfectiousIS(model, infdurdist, infdurmin=1, validating=False)</code>","text":"<p>Infectious Component for SIS Models (Infection + Recovery to Susceptible)</p> <p>This component handles the infectious state in SIS-style models, where agents recover from infection and immediately return to the susceptible pool. It supports per-agent infection durations and manages patch-level infectious counts over time.</p> <p>Agents transition from Infectious back to Susceptible after the infectious period (itimer). Tracks number of agents recovering each tick in <code>model.nodes.newly_recovered</code>.</p> <p>Responsibilities: - Initializes infected agents and their infection timers (<code>itimer</code>) - Decrements <code>itimer</code> daily for infectious agents - Automatically transitions agents from <code>INFECTIOUS</code> to <code>SUSCEPTIBLE</code> when <code>itimer == 0</code> - Tracks per-day recoveries at the node level in <code>model.nodes.recovered</code> - Maintains node-level <code>I</code> and <code>S</code> counts with full timestep resolution</p> <p>Required Inputs: - <code>model.scenario.I</code>: initial number of infectious agents per patch - <code>infdurdist</code>: a callable function which samples the infectious duration distribution - <code>infdurmin</code>: the minimum infection period (default = 1 time step)</p> <p>Outputs: - <code>model.people.itimer</code>: per-agent infection countdown timer - <code>model.nodes.I[t, i]</code>: number of infectious individuals at tick <code>t</code> in node <code>i</code> - <code>model.nodes.recovered[t, i]</code>: number of recoveries at tick <code>t</code> in node <code>i</code></p> Step Behavior <p>At each tick: - Infectious agents decrement their <code>itimer</code> - Agents with <code>itimer == 0</code> are transitioned back to susceptible - <code>model.nodes.I</code> is updated accordingly - Recovered counts are recorded in <code>model.nodes.recovered</code></p> <p>Validation: - Ensures consistency between agent <code>state</code> and infection timer (<code>itimer</code>) - Validates <code>I</code> census against agent-level state before and after each tick</p> <p>Plotting: The <code>plot()</code> method displays both per-node and total infectious counts over time.</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIS(model, infdurdist),     SIR.Transmission(model, ...), ]</p>"},{"location":"reference/laser/generic/components/#laser.generic.components.InfectiousIS.step","title":"<code>laser.generic.components.InfectiousIS.step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/components/#laser.generic.components.InfectiousSI","title":"<code>laser.generic.components.InfectiousSI(model, validating=False)</code>","text":"<p>Infectious Component for SI Models (No Recovery)</p> <p>This component manages the infectious state in SI-style epidemic models where agents remain infectious indefinitely. It is appropriate for use in models without a recovered or removed state (i.e., no <code>R</code> compartment).</p> <p>Responsibilities: - Initializes agents as infectious based on <code>model.scenario.I</code> - Tracks the number of infectious individuals (<code>I</code>) in each patch over time - Maintains per-tick, per-node counts in <code>model.nodes.I</code> - Validates consistency between agent states and patch-level totals</p> <p>Required Inputs: - <code>model.scenario.I</code>: array of initial infected counts per patch - <code>model.people.state</code>: infection state per agent - <code>model.people.nodeid</code>: patch assignment per agent - <code>model.params.nticks</code>: number of timesteps to simulate</p> <p>Outputs: - <code>model.nodes.I[t, i]</code>: number of infectious individuals in node <code>i</code> at time <code>t</code></p> Step Behavior <p>For each timestep <code>t</code>, this component copies:     I[t+1] = I[t] (No recovery or removal; new infections may be added externally.)</p> <p>Validation: - Ensures that patch-level infectious counts (<code>model.nodes.I</code>) match the agent-level state - Asserts that the sum of <code>S</code> and <code>I</code> matches total population at initialization - Validates that infected counts do not change unexpectedly (unless altered by another component)</p> <p>Plotting: The <code>plot()</code> method shows the number of infectious agents per patch and in total across time.</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousSI(model),     SIR.Transmission(model, ...), ]</p>"},{"location":"reference/laser/generic/components/#laser.generic.components.InfectiousSI.step","title":"<code>laser.generic.components.InfectiousSI.step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/components/#laser.generic.components.Recovered","title":"<code>laser.generic.components.Recovered(model, validating=False)</code>","text":"<p>Recovered Component for SIR/SEIR Models (Permanent Immunity)</p> <p>This component manages agents in the recovered state in models where immunity does not wane (i.e., once recovered, agents stay recovered permanently). It tracks the number of recovered individuals over time at the patch level, but performs no active transitions itself \u2014 recovery transitions must be handled by upstream components.</p> <p>Responsibilities: - Initializes agents as recovered if specified in <code>model.scenario.R</code> - Tracks per-patch recovered counts over time in <code>model.nodes.R</code> - Verifies consistency between agent state and aggregate recovered counts - Propagates recovered totals forward unchanged (unless modified by other components)</p> <p>Required Inputs: - <code>model.scenario.R</code>: number of initially recovered individuals per node</p> <p>Outputs: - <code>model.nodes.R[t, i]</code>: number of recovered individuals at tick <code>t</code> in node <code>i</code></p> <p>Step Behavior: - At each tick, carries forward:     R[t+1] = R[t] - This component does not change any agent's state or internal timers</p> <p>\ud83e\uddea Validation: - Ensures per-agent state matches aggregate <code>R</code> counts before and after each step - Detects accidental changes to recovered counts not explained by upstream logic</p> <p>Plotting: The <code>plot()</code> method shows per-node and total recovered counts over time.</p> Example <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     Recovered(model),  # passive tracker, assumes recovery handled upstream ]</p>"},{"location":"reference/laser/generic/components/#laser.generic.components.RecoveredRS","title":"<code>laser.generic.components.RecoveredRS(model, wandurdist, wandurmin=1, validating=False)</code>","text":"<p>Recovered Component for SIRS/SEIRS Models (Waning Immunity)</p> <p>This component manages agents in the recovered state in models where immunity is temporary. It supports per-agent recovery timers, enabling individuals to return to the susceptible state after a configurable waning period. This is essential for SEIRS/SIRS model dynamics.</p> <p>Agents transition from Recovered back to Susceptible after the waning immunity period (rtimer). Tracks number of agents losing immunity each tick in <code>model.nodes.newly_waned</code>.</p> <p>Responsibilities: - Initializes agents in the <code>RECOVERED</code> state using <code>model.scenario.R</code> - Assigns <code>rtimer</code> values to track the duration of immunity - Decrements <code>rtimer</code> each tick; transitions agents to <code>SUSCEPTIBLE</code> when <code>rtimer == 0</code> - Updates patch-level counts:     \u2022 <code>R[t, i]</code>: number of recovered individuals in node <code>i</code> at time <code>t</code>     \u2022 <code>waned[t, i]</code>: number of agents who re-entered susceptibility on time step <code>t</code></p> <p>Required Inputs: - <code>model.scenario.R</code>: initial number of recovered individuals per node - <code>wandurdist</code>: a function sampling the waning immunity duration distribution - <code>wandurmin</code>: minimum duration of immunity (default = 1 time step)</p> <p>Outputs: - <code>model.people.rtimer</code>: per-agent countdown to immunity expiration - <code>model.nodes.R</code>: recovered count per patch per timestep - <code>model.nodes.waned</code>: number of immunity losses per patch per tick</p> <p>Step Behavior: - Agents with <code>state == RECOVERED</code> decrement <code>rtimer</code> - When <code>rtimer == 0</code>, they return to <code>SUSCEPTIBLE</code> - <code>R</code> and <code>S</code> counts are updated to reflect this transition - <code>waned[t]</code> logs the number of agents who lost immunity on time step <code>t</code></p> <p>Validation: - Ensures population conservation and consistency between agent states and patch totals - Detects unexpected changes in <code>R</code> or invalid transitions</p> <p>Plotting: The <code>plot()</code> method provides two views: 1. Per-node recovered trajectories 2. Total recovered and waned agents over time</p> Example <p>model.components = [     SIR.Susceptible(model),     SEIRS.Infectious(model, infdurdist, wandurdist),     Exposed(model, ...),     RecoveredRS(model, wandurdist), ]</p>"},{"location":"reference/laser/generic/components/#laser.generic.components.Susceptible","title":"<code>laser.generic.components.Susceptible(model, validating=False)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p> Step Behavior <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p> Example <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/components/#laser.generic.components.TransmissionSE","title":"<code>laser.generic.components.TransmissionSE(model, expdurdist, expdurmin=1, seasonality=None, validating=False)</code>","text":"<p>Transmission component for an SEIR/SEIRS model with S -&gt; E transition and incubation duration.</p> <pre><code>This component simulates the transition from `SUSCEPTIBLE` to `EXPOSED` in models\nwhere infection includes an incubation period before agents become infectious.\nIt handles stochastic exposure based on per-node force of infection (FOI), and\nassigns individual incubation timers to newly exposed agents.\n\nAgents transition from Susceptible to Exposed based on force of infection.\nSets newly exposed agents' infection timers (etimer) based on `expdurdist` and `expdurmin`.\nTracks number of new infections each tick in `model.nodes.newly_infected`.\n\nResponsibilities:\n- Computes force of infection `\u03bb = \u03b2 * (I / N)` at each tick per node\n- Adjusts FOI using `model.network` for inter-node transmission coupling. Required but can be nullified by filling with all zeros.\n- Applies FOI to susceptible agents to determine exposure\n- Assigns incubation durations (`etimer`) to each newly exposed agent\n- Updates node-level counts for `S` and `E` and logs daily incidence\n\nRequired Inputs:\n- `model.params.beta`: global transmission rate\n- `model.network`: [n x n] matrix for FOI migration\n- `expdurdist(tick, node)`: callable that samples the exposure/incubation duration distribution\n- `expdurmin`: minimum incubation period (default = 1)\n\nOutputs:\n- `model.nodes.forces[t, i]`: computed FOI in node `i` at tick `t`\n- `model.nodes.incidence[t, i]`: new exposures per node per day\n- `model.people.etimer`: per-agent incubation countdown\n\nStep Behavior:\n- Computes FOI (`\u03bb`) for each node\n- Optionally applies inter-node infection pressure via `model.network`\n- Converts FOI into a Bernoulli probability using: `p = 1 - exp(-\u03bb)`\n- Infects susceptible agents probabilistically\n- Updates state and records incidence\n\nValidation:\n- Validates consistency between agent states and patch-level counts before and after tick\n- Confirms that `incidence[t] == E[t+1] - E[t]`\n\nPlotting:\nThe `plot()` method shows per-node FOI (`\u03bb`) trajectories over time.\n\nExample:\n    model.components = [\n        SIR.Susceptible(model),\n        TransmissionSE(model, expdurdist),\n        Exposed(model, ...),\n        InfectiousIR(model, ...),\n        Recovered(model),\n    ]\n</code></pre> <p>Initializes the TransmissionSE component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The epidemiological model instance.</p> required <code>expdurdist</code> <code>Callable[[int, int], float]</code> <p>A function that returns the incubation duration for a given tick and node.</p> required <code>expdurmin</code> <code>int</code> <p>Minimum incubation duration.</p> <code>1</code> <code>seasonality</code> <code>Union[ValuesMap, ndarray]</code> <p>Seasonality modifier for transmission rate. Defaults to None.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Enable component-level validation. Defaults to False.</p> <code>False</code>"},{"location":"reference/laser/generic/components/#laser.generic.components.TransmissionSI","title":"<code>laser.generic.components.TransmissionSI(model, infdurdist, infdurmin=1, seasonality=None, validating=False)</code>","text":"<p>Transmission Component for SIS/SIR/SIRS Models (S \u2192 I with Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> in models where infectious individuals have a finite infection duration (<code>itimer</code>). It supports full spatial coupling and allows infection durations to vary by node and tick.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Sets newly infectious agents' infection timers (itimer) based on <code>infdurdist</code> and <code>infdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.newly_infected</code>.</p> <p>Responsibilities: - Computes force of infection (FOI) <code>\u03bb = \u03b2 * (I / N)</code> per patch each tick - Applies optional spatial coupling via <code>model.network</code> (infection pressure transfer) - Converts FOI into Bernoulli probabilities using <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents stochastically, assigning per-agent <code>itimer</code> - Updates patch-level susceptible (<code>S</code>) and infectious (<code>I</code>) counts - Records number of new infections per tick in <code>model.nodes.incidence</code></p> <p>Required Inputs: - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: [n x n] matrix of transmission coupling - <code>infdurdist(tick, node)</code>: callable sampling the infectious duration distribution - <code>model.people.itimer</code>: preallocated per-agent infection timer</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at time <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new infections in node <code>i</code> on time step <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between incidence and change in <code>I</code> - Checks for correct state and population accounting before and after tick</p> <p>Plotting: The <code>plot()</code> method visualizes per-node FOI (<code>\u03bb</code>) over simulation time.</p> Example <p>model.components = [     SIR.Susceptible(model),     TransmissionSI(model, infdurdist),     InfectiousIR(model, infdurdist), ]</p> <p>Initializes the TransmissionSI component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <code>Callable[[int, int], float]</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <code>int</code> <p>Minimum infectious duration.</p> <code>1</code> <code>seasonality</code> <code>Union[ValuesMap, ndarray]</code> <p>Seasonality modifier for transmission rate. Defaults to None.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Enable component-level validation. Defaults to False.</p> <code>False</code>"},{"location":"reference/laser/generic/components/#laser.generic.components.TransmissionSIx","title":"<code>laser.generic.components.TransmissionSIx(model, seasonality=None, validating=False)</code>","text":"<p>Transmission Component for SI-Style Models (S \u2192 I Only, No Recovery)</p> <p>This component simulates the transmission process in simple epidemic models where agents move from the <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> state and remain infectious indefinitely. It computes the force of infection (FOI) for each patch and applies it stochastically to susceptible agents.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Tracks number of new infections each tick in <code>model.nodes.newly_infected</code>.</p> <p>Responsibilities: - Computes per-node force of infection (<code>\u03bb</code>) at each tick:     \u03bb = \u03b2 * (I / N), with spatial coupling via a migration matrix - Applies probabilistic infection to susceptible agents using <code>nb_transmission_step</code> - Updates per-node <code>S</code> and <code>I</code> counts accordingly - Tracks new infections (incidence) and FOI values per node and tick</p> <p>Required Inputs: - <code>model.nodes.I[t]</code>: number of infectious agents per node at tick <code>t</code> - <code>model.nodes.S[t]</code>: number of susceptible agents per node at tick <code>t</code> - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: matrix of spatial coupling between nodes</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: force of infection in node <code>i</code> at tick <code>t</code> - <code>model.nodes.incidence[t, i]</code>: number of new infections in node <code>i</code> at tick <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between state transitions and incidence records - Checks conservation of population in <code>S</code> and <code>I</code> states - Validates <code>incidence[t] == I[t+1] - I[t]</code></p> <p>Plotting: The <code>plot()</code> method displays the force of infection over time per node.</p> Example <p>model.components = [     SIR.Susceptible(model),     TransmissionSIx(model),     InfectiousSI(model), ]</p> <p>Transmission Component for SI-Style Models (S \u2192 I Only, No Recovery)</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The epidemic model instance.</p> required <code>seasonality</code> <code>Union[ValuesMap, ndarray]</code> <p>Seasonality modifier for transmission rate. Can be a ValuesMap or a precomputed array. Defaults to None.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Enable component-level validation. Defaults to False.</p> <code>False</code>"},{"location":"reference/laser/generic/immunization/","title":"laser.generic.immunization","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization","title":"<code>laser.generic.immunization</code>","text":"<p>Immunization components for LASER models.</p> <p>These components introduce immunity into the agent population during a simulation.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization--notes","title":"Notes","text":"<ul> <li>Deployment is currently global (all patches). Future extensions may include:</li> <li>targeting by patch or lists of patches,</li> <li>patch-varying coverage,</li> <li>time-varying routine immunization (RI) coverage.</li> <li>The routine immunization window centers on the target age with width \u2248 period,   i.e., [age - period/2, age + period/2).</li> </ul>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign","title":"<code>laser.generic.immunization.ImmunizationCampaign(model, period, coverage, age_lower, age_upper, start=0, end=-1, verbose=False)</code>","text":"<p>A LASER component that applies an immunization campaign over an age band.</p> <p>On eligible ticks, all agents with age in [age_lower, age_upper) are considered and immunized with probability <code>coverage</code>. Susceptibles become immune (<code>population.susceptibility[idx] = 0</code>). This aligns with the campaign-style immunization component described in the <code>laser-generic</code> docs.</p> <p>Initialize an ImmunizationCampaign instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER <code>Model</code> with <code>population</code>, <code>patches</code>, and <code>params</code>. <code>params.nticks</code> must be defined.</p> required <code>period</code> <code>int</code> <p>Number of ticks between campaign events. Must be &gt;= 1.</p> required <code>coverage</code> <code>float</code> <p>Per-event immunization probability in [0.0, 1.0].</p> required <code>age_lower</code> <code>int</code> <p>Inclusive lower bound of target age band (ticks).</p> required <code>age_upper</code> <code>int</code> <p>Exclusive upper bound of target age band (ticks). Must be &gt; age_lower.</p> required <code>start</code> <code>int</code> <p>First tick (inclusive) to run campaigns. Default 0.</p> <code>0</code> <code>end</code> <code>int</code> <p>Last tick (exclusive) to run campaigns. If -1, defaults to <code>model.params.nticks</code>. Default -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging. Default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model instance.</p> <code>period</code> <code>int</code> <p>Ticks between campaign events.</p> <code>coverage</code> <code>float</code> <p>Immunization probability at each event.</p> <code>age_lower</code> <code>int</code> <p>Inclusive lower age (ticks).</p> <code>age_upper</code> <code>int</code> <p>Exclusive upper age (ticks).</p> <code>start</code> <code>int</code> <p>First campaign tick (inclusive).</p> <code>end</code> <code>int</code> <p>Last campaign tick (exclusive).</p> <code>verbose</code> <code>bool</code> <p>Verbosity flag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs are out of range (e.g., period &lt; 1, coverage not in [0, 1],         age bounds invalid).</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.__call__","title":"<code>laser.generic.immunization.ImmunizationCampaign.__call__(model, tick)</code>","text":"<p>Apply the immunization campaign at the given tick, if eligible.</p> Triggers when <p>tick &gt;= start and ((tick - start) % period == 0) and tick &lt; end</p> On each event <ul> <li>Agents with age in [age_lower, age_upper) are considered.</li> <li>A Binomial draw with probability <code>coverage</code> selects agents to immunize.</li> <li>Selected agents have <code>susceptibility</code> set to 0 (immune).</li> <li>If present, test arrays on <code>model.nodes</code> are updated for validation.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER model (unused; provided for signature parity).</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.plot","title":"<code>laser.generic.immunization.ImmunizationCampaign.plot(fig=None)</code>","text":"<p>Placeholder for campaign visualization.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A Matplotlib Figure to draw into.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization","title":"<code>laser.generic.immunization.RoutineImmunization(model, period, coverage, age, start=0, end=-1, verbose=False)</code>","text":"<p>A LASER component that updates immunity via routine immunization (RI).</p> <p>At eligible ticks, agents whose age (in ticks) falls within an RI window centered at <code>age</code> with half-width <code>period // 2</code> are sampled with probability <code>coverage</code> and made immune (by setting <code>population.susceptibility[idx] = 0</code>).</p> <p>This component follows the general component style in <code>laser-generic</code> and can be added to <code>Model.components</code>. See package documentation for details on the component pattern.</p> <p>Initialize a RoutineImmunization instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER <code>Model</code> with <code>population</code>, <code>patches</code>, and <code>params</code>. <code>params.nticks</code> must be defined.</p> required <code>period</code> <code>int</code> <p>Number of ticks between RI events. Must be &gt;= 1.</p> required <code>coverage</code> <code>float</code> <p>Per-event immunization probability in [0.0, 1.0].</p> required <code>age</code> <code>int</code> <p>Target age (in ticks) around which to immunize.</p> required <code>start</code> <code>int</code> <p>First tick (inclusive) to run RI. Default 0.</p> <code>0</code> <code>end</code> <code>int</code> <p>Last tick (exclusive) to run RI. If -1, defaults to <code>model.params.nticks</code>. Default -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging. Default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model instance.</p> <code>period</code> <code>int</code> <p>Ticks between RI events.</p> <code>coverage</code> <code>float</code> <p>Immunization probability at each event.</p> <code>age</code> <code>int</code> <p>Target age in ticks.</p> <code>start</code> <code>int</code> <p>First RI tick (inclusive).</p> <code>end</code> <code>int</code> <p>Last RI tick (exclusive).</p> <code>verbose</code> <code>bool</code> <p>Verbosity flag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>period &lt; 1</code>, <code>coverage</code> not in [0, 1], or <code>age &lt; 0</code>.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.__call__","title":"<code>laser.generic.immunization.RoutineImmunization.__call__(model, tick)</code>","text":"<p>Apply routine immunization at the given tick, if eligible.</p> An event fires when <p>tick &gt;= start and ((tick - start) % period == 0) and tick &lt; end</p> On each event <ul> <li>Agents with age in [age - period//2, age + period//2) are considered.</li> <li>A Binomial draw with probability <code>coverage</code> selects agents to immunize.</li> <li>Selected agents have <code>susceptibility</code> set to 0 (immune).</li> <li>If present, test arrays on <code>model.nodes</code> are updated for validation.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER model (unused; provided for signature parity).</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.plot","title":"<code>laser.generic.immunization.RoutineImmunization.plot(fig=None)</code>","text":"<p>Placeholder for RI visualization.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A Matplotlib Figure to draw into.</p> <code>None</code>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.immunize_in_age_window","title":"<code>laser.generic.immunization.immunize_in_age_window(model, lower, upper, coverage, tick)</code>","text":"<p>Immunize susceptible agents whose age is in [lower, upper).</p> <p>This function updates agent-level susceptibility and returns the corresponding node IDs for accounting or test-array updates.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER <code>Model</code> containing <code>population</code> with fields: - dob (array[int]): Agent date-of-birth ticks. - susceptibility (array[int|bool]): 1/True if susceptible, 0/False if immune. - nodeid (array[int]): Patch index per agent.</p> required <code>lower</code> <code>int</code> <p>Inclusive lower bound on age (in ticks). Clamped to &gt;= 0.</p> required <code>upper</code> <code>int</code> <p>Exclusive upper bound on age (in ticks). Must be &gt;= lower.</p> required <code>coverage</code> <code>float</code> <p>Probability in [0, 1] to immunize each eligible susceptible.</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required <p>Returns:</p> Type Description <code>Optional[ndarray]</code> <p>np.ndarray | None: Array of <code>nodeid</code> for immunized agents, or None if none.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>upper &lt; lower</code> or <code>coverage</code> not in [0, 1].</p>"},{"location":"reference/laser/generic/importation/","title":"laser.generic.importation","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation","title":"<code>laser.generic.importation</code>","text":"<p>This module defines Importation classes, which provide methods to import cases into a population during simulation.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch","title":"<code>laser.generic.importation.Infect_Agents_In_Patch(model, verbose=False)</code>","text":"<p>A LASER model component that introduces infections into specific patches of the population at regular intervals. This is useful for modeling geographically targeted importations or outbreaks.</p> <p>Initialize an Infect_Agents_In_Patch instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model object that contains the population, patches, and parameters. The following attributes must exist or may optionally exist in <code>model.params</code>:   - importation_period (int): Number of ticks between infection events.   - importation_count (int, optional): Number of agents to infect     per patch per event. Defaults to 1 if not provided.   - importation_patchlist (array-like of int, optional): Indices     of patches where infections will be seeded. Defaults to all patches     if not provided.   - importation_start (int, optional): First tick to apply infections.     Defaults to 0 if not provided.   - importation_end (int, optional): Last tick to apply infections.     Defaults to <code>nticks</code> if not provided.   - nticks (int): Total number of ticks in the simulation.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model used by this component.</p> <code>period</code> <code>int</code> <p>Number of ticks between infection events.</p> <code>count</code> <code>int</code> <p>Number of agents infected per patch at each event.</p> <code>patchlist</code> <code>ndarray</code> <p>List of patch indices to target with infections.</p> <code>start</code> <code>int</code> <p>First tick to apply infections.</p> <code>end</code> <code>int</code> <p>Last tick to apply infections.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.__call__","title":"<code>laser.generic.importation.Infect_Agents_In_Patch.__call__(model, tick)</code>","text":"<p>Introduce infections into the specified patches at the given tick.</p> Infections are seeded if <ul> <li>The current tick is greater than or equal to <code>start</code>.</li> <li>The tick falls on a multiple of <code>period</code> (relative to <code>start</code>).</li> <li>The tick is less than <code>end</code>.</li> </ul> <p>At each eligible tick, every patch in <code>patchlist</code> receives <code>count</code> infections via <code>seed_infections_in_patch</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model containing the population and patches.</p> required <code>tick</code> <code>int</code> <p>The current tick (time step) of the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.plot","title":"<code>laser.generic.importation.Infect_Agents_In_Patch.plot(fig=None)</code>","text":"<p>Placeholder for visualization of targeted patch infections.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A matplotlib Figure to plot into. If None, no plot is generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>None</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents","title":"<code>laser.generic.importation.Infect_Random_Agents(model, verbose=False)</code>","text":"<p>A LASER model component that introduces random infections into the population at regular intervals. This is typically used to simulate importation events or background infection pressure.</p> <p>Initialize an Infect_Random_Agents instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model object that contains the population, patches, and parameters. The following attributes must exist in <code>model.params</code>:   - importation_period (int): Number of ticks between each infection event.   - importation_count (int): Number of agents to infect per event.   - nticks (int): Total number of ticks in the simulation.   - importation_start (int, optional): First tick to introduce infections.     Defaults to 0 if not provided.   - importation_end (int, optional): Last tick to introduce infections.     Defaults to nticks if not provided.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model object used by the component.</p> <code>period</code> <code>int</code> <p>Number of ticks between infection events.</p> <code>count</code> <code>int</code> <p>Number of agents infected at each event.</p> <code>start</code> <code>int</code> <p>First tick to apply infections.</p> <code>end</code> <code>int</code> <p>Last tick to apply infections.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.__call__","title":"<code>laser.generic.importation.Infect_Random_Agents.__call__(model, tick)</code>","text":"<p>Introduce random infections into the population at the given tick.</p> Infections are seeded if <ul> <li>The current tick is greater than or equal to <code>start</code>.</li> <li>The tick falls on a multiple of <code>period</code> (relative to <code>start</code>).</li> <li>The tick is less than <code>end</code>.</li> </ul> <p>This updates both the agent-level infections and, if present, the test arrays in <code>model.patches</code> for validation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model containing the population and patches.</p> required <code>tick</code> <code>int</code> <p>The current tick (time step) of the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.plot","title":"<code>laser.generic.importation.Infect_Random_Agents.plot(fig=None)</code>","text":"<p>Placeholder for visualization of infection events.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A matplotlib Figure to plot into. If None, no plot is generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>None</p>"},{"location":"reference/laser/generic/model/","title":"laser.generic.model","text":""},{"location":"reference/laser/generic/model/#laser.generic.model","title":"<code>laser.generic.model</code>","text":""},{"location":"reference/laser/generic/model/#laser.generic.model.Model","title":"<code>laser.generic.model.Model(scenario, params, birthrates=None, name='generic', skip_capacity=False, states=None, additional_states=None)</code>","text":"<p>Initialize the SI model.</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>GeoDataFrame</code> <p>The scenario data containing per patch population, initial S and I counts, and geometry.</p> required <code>params</code> <code>PropertySet</code> <p>The parameters for the model, including 'nticks' and 'beta'.</p> required <code>birthrates</code> <code>ndarray</code> <p>Birth rates in CBR per patch per tick. Defaults to None.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the model instance. Defaults to \"generic\".</p> <code>'generic'</code> <code>skip_capacity</code> <code>bool</code> <p>If True, skips capacity checks. Defaults to False.</p> <code>False</code> <code>states</code> <code>list</code> <p>List of state names. Defaults to None == {\"S\", \"E\", \"I\", \"R\"}.</p> <code>None</code> <code>additional_states</code> <code>list</code> <p>List of additional state names. Defaults to None.</p> <code>None</code>"},{"location":"reference/laser/generic/shared/","title":"laser.generic.shared","text":""},{"location":"reference/laser/generic/shared/#laser.generic.shared","title":"<code>laser.generic.shared</code>","text":""},{"location":"reference/laser/generic/utils/","title":"laser.generic.utils","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils","title":"<code>laser.generic.utils</code>","text":"<p>This module provides utility functions for the laser-measles project.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.TimingContext","title":"<code>laser.generic.utils.TimingContext(label, stats, parent)</code>","text":"<p>Internal class for timing context management.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.ValuesMap","title":"<code>laser.generic.utils.ValuesMap(nnodes, nticks)</code>","text":"<p>A class to efficiently represent values mapped over nodes and time steps.</p> <p>Parameters:</p> Name Type Description Default <code>nnodes</code> <code>int</code> <p>Number of nodes.</p> required <code>nticks</code> <code>int</code> <p>Number of time steps.</p> required Methods to create ValuesMap from different data sources <ul> <li>from_scalar(scalar: float, nticks: int, nnodes: int)</li> <li>from_timeseries(data: np.ndarray, nnodes: int)</li> <li>from_nodes(data: np.ndarray, nticks: int)</li> <li>from_array(data: np.ndarray, writeable: bool = False)</li> </ul>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.ValuesMap.nnodes","title":"<code>laser.generic.utils.ValuesMap.nnodes</code>  <code>property</code>","text":"<p>Number of nodes.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.ValuesMap.nticks","title":"<code>laser.generic.utils.ValuesMap.nticks</code>  <code>property</code>","text":"<p>Number of time steps.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.ValuesMap.shape","title":"<code>laser.generic.utils.ValuesMap.shape</code>  <code>property</code>","text":"<p>Shape of the underlying data array (nticks, nnodes).</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.ValuesMap.values","title":"<code>laser.generic.utils.ValuesMap.values</code>  <code>property</code>","text":"<p>Underlying data array of shape (nticks, nnodes).</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.ValuesMap.from_array","title":"<code>laser.generic.utils.ValuesMap.from_array(data, writeable=False)</code>  <code>staticmethod</code>","text":"<p>Create a ValuesMap from a 2D array of data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>2D array of shape (nticks, nnodes).</p> required <code>writeable</code> <code>bool</code> <p>If True, the underlying data array is writeable and can be modified during simulation. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ValuesMap</code> <code>ValuesMap</code> <p>The created ValuesMap instance.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.ValuesMap.from_nodes","title":"<code>laser.generic.utils.ValuesMap.from_nodes(data, nticks)</code>  <code>staticmethod</code>","text":"<p>Create a ValuesMap from a nodes array for all time steps.</p> <p>All time steps have the same node data.</p> <p>nnodes is inferred from the length of data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>1D array of node data.</p> required <code>nticks</code> <code>int</code> <p>Number of time steps.</p> required <p>Returns:</p> Name Type Description <code>ValuesMap</code> <code>ValuesMap</code> <p>The created ValuesMap instance.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.ValuesMap.from_scalar","title":"<code>laser.generic.utils.ValuesMap.from_scalar(scalar, nticks, nnodes)</code>  <code>staticmethod</code>","text":"<p>Create a ValuesMap with the same scalar value for all nodes and time steps.</p> <p>Parameters:</p> Name Type Description Default <code>scalar</code> <code>float</code> <p>The scalar value to fill the map.</p> required <code>nnodes</code> <code>int</code> <p>Number of nodes.</p> required <code>nticks</code> <code>int</code> <p>Number of time steps.</p> required <p>Returns:</p> Name Type Description <code>ValuesMap</code> <code>ValuesMap</code> <p>The created ValuesMap instance.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.ValuesMap.from_timeseries","title":"<code>laser.generic.utils.ValuesMap.from_timeseries(data, nnodes, nticks=None)</code>  <code>staticmethod</code>","text":"<p>Create a ValuesMap from a time series array for all nodes.</p> <p>All nodes have the same time series data.</p> <p>nticks is inferred from the length of data if not explicitly provided.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>1D array of time series data.</p> required <code>nnodes</code> <code>int</code> <p>Number of nodes.</p> required <code>nticks</code> <code>int</code> <p>Number of ticks. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ValuesMap</code> <code>ValuesMap</code> <p>The created ValuesMap instance.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.get_centroids","title":"<code>laser.generic.utils.get_centroids(gdf)</code>","text":"<p>Get centroids of geometries in gdf in degrees (EPSG:4326).</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.get_default_parameters","title":"<code>laser.generic.utils.get_default_parameters()</code>","text":"<p>Returns a default PropertySet with common parameters used across laser-generic models.</p> <p>Each parameter in the returned PropertySet is described below, along with its default value and rationale:</p> <pre><code>nticks (int, default=730): Number of simulation ticks (days). Default is 2 years (365*2), which is a typical duration for seasonal epidemic simulations.\nbeta (float, default=0.15): Transmission rate per contact. Chosen as a moderate value for SIR-type models to reflect realistic disease spread.\nbiweekly_beta_scalar (list of float, default=[1.0]*biweekly_steps): Scalar for beta for each biweekly period. Default is 1.0 for all periods, meaning no seasonal variation unless specified.\ncbr (float, default=0.03): Constant birth rate. Set to 0.03 to represent a typical annual birth rate in people models.\nexp_shape (float, default=2.0): Shape parameter for the exposed period distribution. Default chosen for moderate dispersion.\nexp_scale (float, default=2.0): Scale parameter for the exposed period distribution. Default chosen for moderate mean duration.\ninf_mean (float, default=4.0): Mean infectious period (days). Set to 4.0 to reflect typical infectious durations for diseases like measles.\ninf_sigma (float, default=1.0): Standard deviation of infectious period. Default is 1.0 for moderate variability.\nseasonality_factor (float, default=0.2): Amplitude of seasonal forcing. Chosen to allow moderate seasonal variation in transmission.\nseasonality_phase (float, default=0.0): Phase offset for seasonality. Default is 0.0, meaning no phase shift.\nimportation_count (int, default=1): Number of cases imported per importation event. Default is 1 for sporadic importation.\nimportation_period (int, default=30): Days between importation events. Default is 30 to represent monthly importation.\nimportation_start (int, default=0): Start day for importation events. Default is 0 (simulation start).\nimportation_end (int, default=730): End day for importation events. Default is 2 years (365*2).\nseed (int, default=123): Random seed for reproducibility. Default is 123.\nverbose (bool, default=False): If True, enables verbose output. Default is False for minimal output.\n</code></pre> <p>These values are chosen to be broadly reasonable for seasonal SIR-type models with importation.</p> <p>We need a function like this because even-though laser-core requires no particular param name, laser-generic code does presume certain parameters and there's no elegant way to just discover what those are. So we put them here.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_in_patch","title":"<code>laser.generic.utils.seed_infections_in_patch(model, ipatch, ninfections=1)</code>","text":"<p>Seed initial infections in a specific patch of the people at the start of the simulation.</p> <p>This function randomly selects up to <code>ninfections</code> individuals from the specified patch who are currently susceptible (state == State.SUSCEPTIBLE) and marks them as infected by:   - Setting their infection timer (<code>itimer</code>) to the model's mean infectious duration (<code>inf_mean</code>),   - Setting their infection <code>state</code> to State.INFECTIOUS.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model containing the people and parameters. It must expose:    - model.people.state (integer infection state),    - model.people.itimer (infection timers),    - model.people.nodeid (patch index),    - model.params.inf_mean (mean infectious period).</p> required <code>ipatch</code> <code>int</code> <p>The identifier of the patch where infections should be seeded.</p> required <code>ninfections</code> <code>int</code> <p>The number of initial infections to seed. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly","title":"<code>laser.generic.utils.seed_infections_randomly(model, ninfections=100)</code>","text":"<p>Randomly seed initial infections across the entire people.</p> <p>This function selects up to <code>ninfections</code> susceptible individuals at random from the full people. It marks them as infected by: - Setting their infection timer (<code>itimer</code>) to the model's mean infectious duration (<code>inf_mean</code>), - Setting their susceptibility to zero.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model, which must contain a <code>people</code> with    <code>susceptibility</code>, <code>itimer</code>, and <code>nodeid</code> arrays, and a <code>params</code> object with <code>inf_mean</code>.</p> required <code>ninfections</code> <code>int</code> <p>The number of individuals to infect. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The node IDs of the newly infected individuals.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.validate","title":"<code>laser.generic.utils.validate(pre, post)</code>","text":"<p>Decorator to add pre- and post-validation to a method.</p> <p>Calls the given pre- and post-validation methods if the model or component is in validating mode.</p>"},{"location":"reference/laser/generic/vitaldynamics/","title":"laser.generic.vitaldynamics","text":""},{"location":"reference/laser/generic/vitaldynamics/#laser.generic.vitaldynamics","title":"<code>laser.generic.vitaldynamics</code>","text":""},{"location":"reference/laser/generic/vitaldynamics/#laser.generic.vitaldynamics.BirthsByCBR","title":"<code>laser.generic.vitaldynamics.BirthsByCBR(model, birthrates, pyramid, track=True, validating=False)</code>","text":"<p>Component to model births based on crude birth rates (CBR).</p> <p>On each tick, selects the number of agents to be born in each node based on the CBR for that tick and the total population at that tick.</p> <p>\\(\\#births = Poisson (N \\times ((1 + \\frac {CBR} {1000})^{\\frac {1} {365}} - 1))\\)</p> <p>Newborns are added to the susceptible state by default. Calls the <code>on_birth()</code> method of other components in the model, if they implement it, with the indices of the newborn agents. Optionally tracks date of birth (dob) for individuals which may be required for other components (see <code>MortalityByEstimator</code>) or otherwise useful, e.g., age-based intervention targeting.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The simulation model instance.</p> required <code>birthrates</code> <code>ndarray</code> <p>Array of crude birth rates (per 1000 per year) for each time step.</p> required <code>pyramid</code> <code>AliasedDistribution</code> <p>Age pyramid data structure for sampling dates of birth.</p> required <code>track</code> <code>bool</code> <p>Whether to track date of birth (dob) for individuals. Default is True.</p> <code>True</code> <code>validating</code> <code>bool</code> <p>Whether to enable validation checks. Default is False.</p> <code>False</code>"},{"location":"reference/laser/generic/vitaldynamics/#laser.generic.vitaldynamics.ConstantPopVitalDynamics","title":"<code>laser.generic.vitaldynamics.ConstantPopVitalDynamics(model, recycle_rates, dobs=False, mappings=None, validating=False)</code>","text":"<p>Component to model vital dynamics with constant population via recycling - agents are returned to the susceptible state and, optionally, given a new date of birth.</p> <p>On each tick, probabilistically \"recycles\" agents (resets state to susceptible and optionally resets <code>dob</code>) based on the CDR for that tick and the total population at that tick.</p> <p>\\(p(recycle) = 1 - e^{1 - (1 - \\frac {rate} {1000})^{\\frac {1} {365}}}\\)</p> <p>Uses a mapping of (state_value, state_name) tuples to decrement counts in the specified states when individuals die. The default mapping is for 'S', 'E', 'I', and 'R' states.</p> <p>Optionally tracks date of birth (dob) for individuals which may be useful, e.g., age-based intervention targeting or age-at-infection tracking.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The simulation model instance.</p> required <code>recycle_rates</code> <code>ndarray</code> <p>Array of recycling rates (per 1000 per year) for each time step.</p> required <code>dobs</code> <code>bool</code> <p>Whether to track date of birth (dob) for recycled individuals. Default is False.</p> <code>False</code> <code>mappings</code> <code>list of tuples</code> <p>Optional list of (state_value, state_name) tuples to map states for recycling. 'S', 'E', 'I', 'R' by default.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Whether to enable validation checks. Default is False.</p> <code>False</code>"},{"location":"reference/laser/generic/vitaldynamics/#laser.generic.vitaldynamics.MortalityByCDR","title":"<code>laser.generic.vitaldynamics.MortalityByCDR(model, mortalityrates, mappings=None, validating=False)</code>","text":"<p>Component to model mortality based on crude death rates (CDR).</p> <p>On each tick, probabilistically \"recycles\" agents based on the CDR for that tick and the total population at that tick.</p> <p>\\(p(death) = 1 - e^{1 - (1 - \\frac {CDR} {1000})^{\\frac {1} {365}}}\\)</p> <p>Uses a mapping of (state_value, state_name) tuples to decrement counts in the specified states when individuals die. The default mapping is for 'S', 'E', 'I', and 'R' states.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The simulation model instance.</p> required <code>mortalityrates</code> <code>ndarray</code> <p>Array of crude death rates (per 1000 per year) for each time step.</p> required <code>mappings</code> <code>list of tuples</code> <p>Optional list of (state_value, state_name) tuples to map states for decrementing counts.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Whether to enable validation checks. Default is False.</p> <code>False</code>"},{"location":"reference/laser/generic/vitaldynamics/#laser.generic.vitaldynamics.MortalityByEstimator","title":"<code>laser.generic.vitaldynamics.MortalityByEstimator(model, estimator, mappings=None, validating=False)</code>","text":"<p>Component to model mortality based on a life table estimator.</p> <p>Uses a Kaplan-Meier or other estimator to sample dates of death for individuals based on their date of birth. At initialization, samples dates of death for all individuals in the population based on their initial age. Requires that individuals have a 'dob' property. At each tick, individuals whose date of death is equal to the current tick are marked as deceased. Uses a mapping of (state_value, state_name) tuples to decrement counts in the specified states when individuals die. The default mapping is for 'S', 'E', 'I', and 'R' states. Implements an <code>on_birth()</code> method to sample dates of death for newborn individuals.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The simulation model instance.</p> required <code>estimator</code> <code>KaplanMeierEstimator</code> <p>Life table estimator instance with a method to sample dates of death.</p> required <code>mappings</code> <code>list of tuples</code> <p>Optional list of (state_value, state_name) tuples to map states for decrementing counts. 'S', 'E', 'I', 'R' by default.</p> <code>None</code> <code>validating</code> <code>bool</code> <p>Whether to enable validation checks. Default is False.</p> <code>False</code>"},{"location":"software-overview/","title":"Software overview","text":"<p>LASER is a modeling framework that includes a variety of ways for users to implement the code to model infectious diseases.</p>"},{"location":"software-overview/#design-principles","title":"Design principles","text":"<p>The philosophy driving the development of LASER was to create a framework that was flexible, powerful, and fast, able to tackle a variety of complex modeling scenarios without sacrificing performance. But complexity often slows performance, and not every modeling question requires a full suite of model features. To solve this problem, LASER was designed as a set of core components, each with fundamental features that could be added--or not--to build working models. Users can optimize performance by creating models tailored to their research needs, only using components necessary for their modeling question. This building-block framework enables parsimony in model design, but also facilitates the building of powerful models with bespoke, complex dynamics.</p> <p>LASER's core principles can be summarized as follows:</p> <ul> <li>Efficient computation: preallocated memory, fixed-size arrays, sequential array access, and cache-friendly operations.</li> <li>Modular design: users define properties and add modular components (step functions) that run each timestep.</li> <li>Fast: models can be progressively optimized using NumPy, Numba, or even C/OpenMP for performance.</li> <li>Spatial focus: agents belong to patches (nodes), with migration modules (gravity, radiation, Stouffer\u2019s rank, etc.) for multi-patch models.</li> </ul>"},{"location":"software-overview/#software-architecture","title":"Software architecture","text":""},{"location":"software-overview/#input-files","title":"Input files","text":"<p>All LASER models have two basic input requirements:</p> <ol> <li>A scenario DataFrame</li> <li>A <code>PropertySet</code> object</li> </ol> <p>The scenario DataFrame can be created manually or, for simple models, by using the <code>grid()</code> function. The DataFrame, at a minimum, contains one geographic node with the total population for the node and initial compartment counts for susceptible, exposed, infectious, or recovered individuals, depending on the model type used.</p> <p>For example,</p> <pre><code>scenario = pd.DataFrame({\n    \"x\": [0.0],\n    \"y\": [0.0],\n    \"population\": [100000],\n    \"S\": [99990],\n    \"I\": [10],\n})\n</code></pre> <p>The <code>PropertySet</code> object contains parameters for the model. These include the number of timesteps to run (<code>nticks</code>), the random seed, and beta (the transmission rate per day).</p> <p>Depending on the model being used, you may also include epidemiological parameters such as an infectious period sampler or latent period sampler, or mobility parameters such as travel probabilities, gravity kernels, or other information necessary for migration between nodes.</p> <p>For example,</p> <pre><code>params = PropertySet({\n    \"nticks\": 180,\n    \"seed\": 42,\n    \"beta\": 0.05,\n})\n</code></pre> <p>All other input data is optional, and includes additional SI/SIR/SEIR components, agent-level property definitions, spatial and network data, and more.</p> <p>To get started with a simple model, see Create and run a simulation.</p>"},{"location":"software-overview/#software-components","title":"Software components","text":"<p>Components are modular units of functionality within the simulation, responsible for performing specific updates or computations on the agent population or node-level data. Each component is implemented as a class with an initialization function to set up any required state and a step function to execute the component\u2019s logic during each timestep.</p> <p>Components vary in their complexity and functionality. Some may be simple counters or used for general accounting purposes, such as tracking individuals in different diseases states, while others will include disease dynamics or even data analysis functionality. LASER enables users to customize which components are used in order to help customize model functions to specific research questions, while providing basic set up examples and ready-to-use model configurations. The following sections provide background on some of the main components; see the API documentation for all class information.</p>"},{"location":"software-overview/architecture/","title":"LASER architecture overview","text":"<p>Architecture of <code>laser-core</code> and <code>laser-generic</code> packages</p>"},{"location":"software-overview/architecture/#1-purpose","title":"1. Purpose","text":"<p>This document describes the structural architecture and core responsibilities of:</p> <ul> <li><code>laser-core</code> \u2014 low-level data and memory structures used to build high-performance disease models.</li> <li><code>laser-generic</code> \u2014 a library of modular, composable components implementing generic disease transmission models such as SI, SIR, SIRS, SEIR, and SEIRS.</li> </ul> <p>This document intentionally excludes details of:</p> <ul> <li>Statistical distributions</li> <li>Spatial connectivity kernels</li> <li>Demographic initialization utilities</li> </ul> <p>Those are documented separately.</p>"},{"location":"software-overview/architecture/#2-high-level-system-structure","title":"2. High-level system structure","text":"<p>At a high level:</p> <ul> <li><code>laser-core</code> provides the data substrate (memory, properties, layout).</li> <li><code>laser-generic</code> provides the simulation model, components, and execution loop.</li> </ul> <pre><code>flowchart LR\n    subgraph Core[laser-core]\n        LF[LaserFrame]\n        Utils[\"Low-level utilities (distributions, spatial, demographics)\"]\n    end\n\n    subgraph Generic[laser-generic]\n        Model[Model]\n        Comp[\"Components (Transmission, Progression, etc.)\"]\n        Kernels[Numba Kernels]\n    end\n\n    LF --&gt; Model\n    Model --&gt; Comp\n    Comp --&gt; Kernels\n</code></pre> <p>The architecture is designed so that:</p> <ul> <li><code>laser-core</code> knows nothing about disease modeling, and</li> <li><code>laser-generic</code> relies heavily on the memory layout &amp; speed provided by <code>laser-core</code>.</li> </ul>"},{"location":"software-overview/architecture/#3-laser-core-architecture","title":"3. <code>laser-core</code> architecture","text":""},{"location":"software-overview/architecture/#31-responsibilities","title":"3.1 Responsibilities","text":"<p><code>laser-core</code> is responsible for:</p> <ul> <li>Managing efficient, columnar memory layouts for agent/node properties.</li> <li>Providing a schema-like interface for defining scalar and vector properties per entity.</li> <li>Enabling parallel execution by keeping values contiguous and Numba-friendly.</li> <li>Supporting dynamic population changes (primarily births and, optionally, resizing).</li> </ul>"},{"location":"software-overview/architecture/#32-laserframe","title":"3.2 <code>LaserFrame</code>","text":"<p><code>LaserFrame</code> behaves conceptually like a high-performance <code>DataFrame</code> designed for:</p> <ul> <li>Constant mutation</li> <li>Parallel processing</li> <li>Zero Python-object overhead</li> </ul>"},{"location":"software-overview/architecture/#core-concepts","title":"Core concepts","text":"<ul> <li>Each row = one agent or node.</li> <li>Each column = a property.</li> <li> <p>Properties may be:</p> </li> <li> <p>Scalars (e.g., age, state)</p> </li> <li>Fixed-length vectors (e.g., per-tick recording of S/E/I/R counts for nodes)</li> </ul>"},{"location":"software-overview/architecture/#key-responsibilities","title":"Key responsibilities","text":"<ul> <li>Allocate and manage contiguous memory for each property.</li> <li>Provide direct access to underlying NumPy arrays.</li> <li>Ensure layout is friendly to Numba kernels and multicore CPUs.</li> <li>Resize automatically when agents are added.</li> </ul>"},{"location":"software-overview/architecture/#class-diagram","title":"Class diagram","text":"<pre><code>classDiagram\n    class LaserFrame {\n        +int count\n        +int capacity\n        +dict properties\n        +add_scalar_property(name, dtype, default)\n        +add_vector_property(name, length, dtype, default)\n        +add_array_property(name, shape, dtype, default)\n        +add(count)\n        +squash(indices)\n    }\n</code></pre>"},{"location":"software-overview/architecture/#4-laser-generic-architecture","title":"4. <code>laser-generic</code> architecture","text":""},{"location":"software-overview/architecture/#41-responsibilities","title":"4.1 Responsibilities","text":"<p><code>laser-generic</code> provides:</p> <ul> <li>A Model container orchestrating simulation flow.</li> <li>A library of components representing distinct parts of a disease process (e.g., transmission, incubation, recovery).</li> <li>A component execution pipeline ([optional pre-step validation] \u2192 step \u2192 [optional post-step validation]).</li> <li>Integration with Numba kernels for high-performance agent updates.</li> </ul>"},{"location":"software-overview/architecture/#42-the-model-class","title":"4.2 The <code>Model</code> class","text":"<p>The <code>Model</code> object is the conductor of the simulation orchestra:</p> <ul> <li>Holds one or more LaserFrames.</li> <li>Holds a list of components.</li> <li>Maintains simulation time (<code>tick</code>).</li> <li>Defines the run loop, calling component hooks in sequence.</li> </ul>"},{"location":"software-overview/architecture/#simulation-loop-conceptual","title":"Simulation loop (conceptual)","text":"<pre><code>for tick in range(nticks):\n    for component in components:\n        if validating:\n            component.pre_step(model)\n        component.step(model)   # usually calls a Numba kernel\n        if validating:\n            component.post_step(model)\n</code></pre> <p>This consistent execution order ensures deterministic progression, assuming your random number draws are deterministic as well. The <code>laser.generic.random</code> module provides PRNG seeding across NumPy, Numba, and SciPy to help with deterministic random number draws. Note, though, that while Numba generally does provide repeatable random number sequences, it does not guarantee this behavior.</p>"},{"location":"software-overview/architecture/#43-component-architecture","title":"4.3 Component architecture","text":"<p>Components represent modular behaviors. Examples:</p> <ul> <li>Transmission</li> <li>Incubation</li> <li>Infectious progression</li> <li>Recovery</li> <li>Births / deaths</li> <li>Vaccinations</li> </ul>"},{"location":"software-overview/architecture/#component-responsibilities","title":"Component responsibilities","text":"<ul> <li>Own and manage their own model-specific properties.</li> <li>Implement a <code>step(self, tick)</code> method containing the core dynamics.</li> <li> <p>Optionally implement:</p> </li> <li> <p><code>pre_step(self, tick)</code></p> </li> <li><code>post_step(self, tick)</code></li> <li><code>on_birth(self, tick, newborn_indices)</code></li> <li><code>plot(self)</code></li> </ul>"},{"location":"software-overview/architecture/#component-interface","title":"Component interface","text":"<pre><code>class BaseComponent:\n    def pre_step(self, tick): pass\n    def step(self, tick): raise NotImplementedError\n    def post_step(self, tick): pass\n    def on_birth(self, tick, newborn_indices): pass\n    def plot(self): pass\n</code></pre>"},{"location":"software-overview/architecture/#kernel-delegation","title":"Kernel delegation","text":"<p>The <code>step()</code> method typically:</p> <ol> <li>Extracts needed properties from the <code>LaserFrame</code>.</li> <li>Passes them to a Numba kernel.</li> <li>Lets the kernel perform parallel updates.</li> </ol>"},{"location":"software-overview/architecture/#5-execution-flow-diagram","title":"5. Execution flow diagram","text":"<pre><code>sequenceDiagram\n    participant Model\n    participant Component as Component[i]\n    participant Kernel as NumbaKernel\n\n    loop timestep t\n        loop components\n            Model-&gt;&gt;Component: pre_step(model)\n        end\n\n        loop components\n            Model-&gt;&gt;Component: step(model)\n            Component-&gt;&gt;Kernel: call kernel(arrays...)\n            Kernel--&gt;&gt;Component: updates arrays\n        end\n\n        loop components\n            Model-&gt;&gt;Component: post_step(model)\n        end\n\n        Model-&gt;&gt;Model: t += dt\n    end\n</code></pre>"},{"location":"software-overview/architecture/#6-seir-model-detailed-class-diagram","title":"6. SEIR model: detailed class diagram","text":"<p>Below is a detailed wiring diagram for a generic SEIR model using <code>laser-generic</code> components. This example uses:</p> <ul> <li><code>Susceptible</code> component</li> <li><code>Exposed</code> component (E \u2192 I)</li> <li><code>Infectious</code> component (I \u2192 R)</li> <li><code>Recovered</code> component (terminal state or may loop back via waning in SIRS or SEIRS)</li> <li><code>Transmission</code> component</li> <li><code>Births</code> component (optional)</li> <li><code>Mortality</code> component (optional)</li> </ul> <p>(You may have bells, whistles, or mutations, but this is the canonical SEIR template.)</p>"},{"location":"software-overview/architecture/#component-wiring-diagram","title":"Component wiring diagram","text":"<pre><code>classDiagram\n    class Model {\n        +LaserFrame people\n        +LaserFrame nodes\n        +list~Component~ components\n        +int tick\n        +int nticks\n        +run()\n    }\n\n    class Susceptible {\n        +\\_\\_init__()\n        +step()\n    }\n\n    class Exposed {\n        +\\_\\_init__()\n        +step()\n    }\n\n    class Infectious {\n        +\\_\\_init__()\n        +step()\n    }\n\n    class Recovered {\n        +\\_\\_init__()\n        +step()\n    }\n\n    class Transmission {\n        +pre_step()\n        +step()\n        +post_step()\n    }\n\n    class Births {\n        +\\_\\_init__()\n        +step()\n    }\n\n    class Mortality {\n        +\\_\\_init__()\n        +step()\n    }\n\n    class LaserFrame {\n        +add_scalar_property()\n        +add_vector_property()\n    }\n\n    %% Relationships\n    Model --&gt; LaserFrame : uses\n    Model \"1\" o-- \"1\" Susceptible : has\n    Model \"1\" o-- \"1\" Exposed : has\n    Model \"1\" o-- \"1\" Infectious : has\n    Model \"1\" o-- \"1\" Recovered : has\n    Model \"1\" o-- \"1\" Transmission : has\n    Model \"1\" o-- \"1\" Births : has\n    Model \"1\" o-- \"1\" Mortality : has\n\n    Exposed --&gt; LaserFrame : reads/writes\n    Infectious --&gt; LaserFrame : reads/writes\n    Recovered --&gt; LaserFrame : reads/writes\n    Transmission --&gt; LaserFrame : reads/writes\n    Births --&gt; LaserFrame : writes\n    Mortality --&gt; LaserFrame : reads/writes\n</code></pre>"},{"location":"software-overview/architecture/#property-flow-narrative","title":"Property flow (narrative)","text":"<ul> <li> <p>Susceptible</p> </li> <li> <p>Adds: <code>nodeid</code> and <code>state</code> properties to <code>model.people</code>, <code>S</code> property to <code>model.nodes</code></p> </li> <li>Reads: none</li> <li> <p>Writes: none</p> </li> <li> <p>Exposed</p> </li> <li> <p>Adds: <code>etimer</code> property to <code>model.people</code>, <code>E</code> and <code>newly_infectious</code> properties to <code>model.nodes</code></p> </li> <li>Reads: <code>state</code>, <code>etimer</code></li> <li> <p>Writes: <code>state</code> (E \u2192 I)</p> </li> <li> <p>Infectious</p> </li> <li> <p>Adds: <code>itimer</code> property to <code>model.people</code>, <code>I</code> and <code>newly_recovered</code> properties to <code>model.nodes</code></p> </li> <li>Reads: <code>state</code>, <code>itimer</code></li> <li> <p>Writes: <code>state</code> (I \u2192 R)</p> </li> <li> <p>Recovered</p> </li> <li> <p>Adds: <code>R</code> property to <code>model.nodes</code></p> </li> <li>Reads: <code>state</code></li> <li> <p>Writes: nothing unless waning immunity exists (in SIRS or SEIRS)</p> </li> <li> <p>Transmission</p> </li> <li> <p>Adds: <code>forces</code> and <code>newly_infected</code> properties to <code>model.nodes</code></p> </li> <li>Reads: <code>state</code></li> <li> <p>Writes: <code>state</code> (S \u2192 E), sets incubation durations</p> </li> <li> <p>Births</p> </li> <li> <p>Adds: <code>births</code> to <code>model.nodes</code> and optionally <code>dob</code> to <code>model.people</code></p> </li> <li>Reads: nothing</li> <li> <p>Writes: optionally <code>dob</code>, adds agents, triggers <code>on_birth()</code> on relevant components</p> </li> <li> <p>Mortality</p> </li> <li> <p>Adds: <code>deaths</code> to <code>model.nodes</code></p> </li> <li>Reads: possibly <code>dob</code> (date of birth), survival-related properties</li> <li>Writes: <code>dod</code> (date of death), <code>state</code></li> </ul>"},{"location":"software-overview/architecture/#7-extensibility-structure","title":"7. Extensibility structure","text":"<p>The architecture supports extension in three directions:</p>"},{"location":"software-overview/architecture/#71-adding-new-properties","title":"7.1 Adding new properties","text":"<p>Add new per-agent or per-node attributes by modifying the <code>LaserFrame</code> schema.</p>"},{"location":"software-overview/architecture/#72-adding-new-components","title":"7.2 Adding new components","text":"<p>Implement a new class conforming to the Component interface.</p>"},{"location":"software-overview/architecture/#73-creating-custom-models","title":"7.3 Creating custom models","text":"<p>Compose components into a <code>Model</code> in the correct execution order.</p>"},{"location":"software-overview/architecture/#8-summary","title":"8. Summary","text":"<p>This architectural split provides:</p> <ul> <li>Modularity \u2014 Components rely only on <code>LaserFrame</code> and model lifecycle hooks.</li> <li>Performance \u2014 Data is laid out explicitly for multicore, Numba-driven kernels.</li> <li>Flexibility \u2014 New models and components can be composed without touching core infrastructure.</li> <li>Stability \u2014 <code>laser-core</code> provides a durable, minimal foundation; <code>laser-generic</code> builds everything else on top.</li> </ul>"},{"location":"software-overview/database/","title":"Simulation data and properties","text":"<p>LASER is designed to handle large populations with high numbers of independent agents. In order to track agents and their properties, LASER includes functions that store and update this information.</p> <p>The classes described below are only a subset of LASER components. For a full list of all LASER classes, see the API reference.</p>"},{"location":"software-overview/database/#laserframe-and-propertyset","title":"LaserFrame and PropertySet","text":"<p><code>LaserFrame</code> can be thought of as a database system for LASER models. It is a class that is used to dynamically manage and allocate data for nodes and agents, and supports both scalar and vector properties.</p> <p><code>PropertySet</code> stores agent properties in a dictionary-like object. Properties can be dynamically updated and this class is used to help define simulation parameters.</p> <p>The tutorial Build SIR models demonstrates how these two classes can be implemented.</p>"},{"location":"software-overview/database/#sortedqueue","title":"SortedQueue","text":"<p>Timing of events is an important function for agent-based models. Management and tracking of values, especially as the number of agents reaches the millions, can be problematic. <code>SortedQueue</code> is a custom process created for LASER to track and sort these values, and works directly with <code>LaserFrame</code> object arrays.</p>"},{"location":"software-overview/migration/","title":"Migration","text":"<p>The ability to add spatial dynamics to LASER models is one of the features that makes the framework so powerful. There are multiple methods available for adding migration to your model, and the class you choose will depend on which features are important for your research question. Each of the migration models will distribute your population of agents among a set of nodes, with set distances between nodes, and utilize a matrix to define the connection between nodes. How agents or infectivity travels between the nodes (and which nodes they may travel to) will be determined by the specific migration model you choose.</p>"},{"location":"software-overview/migration/#sequential-migration-matrix","title":"Sequential migration matrix","text":""},{"location":"software-overview/migration/#gravity-model","title":"Gravity model","text":"<p>The gravity model can be used to compute the migration of people between nodes located at specific distances, with migration rates proportional to population size and the distance between nodes. This type of migration is useful when you would like to add 2-dimensional movement of agents to nodes.</p> <p>Functional form:</p> \\[ M_{ij} = k \\frac{P_i^{a} P_j^{b}}{d_{ij}^{c}} \\] <p>Where:</p> <ul> <li>\\(M_{ij}\\) = migration flow from origin i to destination j</li> <li>\\(P_i, P_j\\) = populations of origin and destination</li> <li>\\(d_{ij}\\) = distance between i and j</li> <li>\\(k\\) = Parameter: scaling constant</li> <li>\\(a\\) = Parameter: exponent for the population of the origin</li> <li>\\(b\\) = Parameter: exponent for the population of the destination</li> <li>\\(c\\) = Parameter: exponent for the distance</li> </ul> <p>The following example demonstrates implementing the gravity model to calculate the number of migrants moving between nodes. Agents are randomly assigned to different migration paths.</p> <pre><code>import numpy as np\nfrom laser.core.migration import gravity\n\n# Define populations and distances\npopulations = np.array([5000, 10000, 15000, 20000, 25000])  # Unequal populations\ndistances = np.array([\n    [0.0, 10.0, 15.0, 20.0, 25.0],\n    [10.0, 0.0, 10.0, 15.0, 20.0],\n    [15.0, 10.0, 0.0, 10.0, 15.0],\n    [20.0, 15.0, 10.0, 0.0, 10.0],\n    [25.0, 20.0, 15.0, 10.0, 0.0]\n])\n\n# Gravity model parameters\nk = 0.1    # Scaling constant\na = 0.5    # Exponent for the population of the origin\nb = 1.0    # Exponent for the population of the destination\nc = 2.0    # Exponent for the distance\n\n# Compute the gravity model network\nmigration_network = gravity(populations, distances, k=k, a=a, b=b, c=c)\n\n# Normalize to ensure total migrations represent 1% of the population\ntotal_population = np.sum(populations)\nmigration_fraction = 0.01  # 1% of the population migrates\nscaling_factor = (total_population * migration_fraction) / np.sum(migration_network)\nmigration_network *= scaling_factor\n\n# Generate a node ID array for agents\nnode_ids = np.concatenate([np.full(count, i) for i, count in enumerate(populations)])\n\n# Initialize a 2D array for migration counts\nmigration_matrix = np.zeros_like(distances, dtype=int)\n\n# Select migrants based on the gravity model\nfor origin in range(len(populations)):\n    for destination in range(len(populations)):\n        if origin != destination:\n            # Number of migrants to move from origin to destination\n            num_migrants = int(migration_network[origin, destination])\n            # Select migrants randomly\n            origin_ids = np.where(node_ids == origin)[0]\n            selected_migrants = np.random.choice(origin_ids, size=num_migrants, replace=False)\n            # Update the migration matrix\n            migration_matrix[origin, destination] = num_migrants\n</code></pre>"},{"location":"software-overview/migration/#the-competing-destinations-model","title":"The competing destinations model","text":"<p>The competing destinations model extends the gravity model by incorporating the fact that nodes may not be independent, but instead may \"compete\" with each other for incoming agents. Some nodes may be more or less attractive than other nodes, regardless of their proximity to the origin node. There may  be synergistic or antagonistic effects of nodes, creating specific networks and relationships among a series of nodes.</p> <p>For example, in a \u201csynergistic\u201d version, perhaps migratory flow from Boston to Baltimore is higher than flow between two comparator cities of similar population and at similar distance, because the proximity of Washington, D.C. to Baltimore makes travel to Baltimore more attractive to Bostonians. This would be accounted for by a positive value of \\(\\delta\\). On the other hand, this term may also be \u201cantagonistic\u201d if Washington is such an attractive destination that Bostonians eschew travel to Baltimore entirely; this would indicate a negative value of \\(\\delta\\).</p> <p>Functional form:</p> \\[ M_{i,j} = k \\frac{P_i^{a} P_j^{b}}{d_{ij}^{c}} \\left(\\sum_{k \\neq i,j} \\frac{P_k^{b}}{d_{jk}^{c}}\\right)^{\\delta} \\]"},{"location":"software-overview/migration/#stouffers-rank-model","title":"Stouffer's rank model","text":"<p>Stouffer argued that human mobility patterns do not respond to absolute distance directly, but only indirectly through the accumulation of intervening opportunities for destinations. Stouffer thus proposed a model with no distance-dependence at all, rather only a term that accounts for all potential destinations closer than destination \\(j\\); thus, longer-distance travel depends on the density of attractive destinations at shorter distances.</p> <p>Mathematical formulation:</p> <p>Define \\(\\Omega (i,j)\\) to be the set of all locations \\(k\\) such that \\(D_{i,k} \\leq D_{i,j}\\)</p> \\[ M_{i,j} = kp_i^a \\sum_j \\left(\\frac{p_j}{\\sum_{k \\in D(i,j)} p_k}\\right)^b \\] <p>This presents us with the choice of whether or not the origin population \\(i\\) is included in \\(\\Omega\\) - i.e., does the same \"gravity\" that brings others to visit a community reduce the propensity of that community's members to travel to other communities?</p> <p>This Stouffer model does not include the impact from the local community:</p> \\[ \\Omega(i,j) = \\left(k:0 &lt; D_{i,k} \\leq D_{i,j}\\right). \\] <p>The Stouffer variant model does include the impact of the local community:</p> \\[ \\Omega(i,j) = \\left(k:0 \\leq D_{i,k} \\leq D_{i,j}\\right). \\] <p>To simplify the code, <code>laser-core</code>'s implementation of the Stouffer model includes a parameter <code>include_home</code>.</p>"},{"location":"software-overview/migration/#radiation-model","title":"Radiation model","text":"<p>The radiation model is a parameter-free model (up to an overall scaling constant for total migration flux), derived from arguments around job-related commuting. The radiation model overcomes limitations of the gravity model (which is limited to flow at two specific points and is proportional to the populations at source and destination) by only requiring data on population densities. It can describe situations in which outbound migration flux from origin to destination is enhanced by destination population and absorbed by the density of nearer destinations.</p> <p>Mathematical formulation, whith \\(\\Omega\\) defined as above in the Stouffer model:</p> \\[ M_{i,j} = k \\frac{p_i p_j}{\\left(p_i + \\sum_{k \\in \\theta(i,j)} p_k\\right) \\left(p_i + p_j + \\sum_{k \\in \\theta(i,j)} p_k\\right)} \\] <p>We again use the parameter <code>include_home</code> to determine whether or not location \\(i\\) is to be included in \\(\\Omega(i,j)\\).</p>"},{"location":"software-overview/scenario/","title":"Simulation structure","text":"<p>To fully leverage the power and flexibility of the LASER framework, it is important to understand how the various components work together to produce simulations, and ultimately, simulation results. You can think of a simulation as having two main pieces: the scenario and the model.</p> <p>For a simple working example of building a simulation, see Build a model.</p>"},{"location":"software-overview/scenario/#scenarios","title":"Scenarios","text":"<p>The scenario is information that describes the environment in which your model will operate. Scenarios include information on:</p> <ul> <li>The number of nodes or patches</li> <li>Population sizes</li> <li>Node coordinates (latitude and longitude) for spatial models</li> <li>The initial disease state counts</li> </ul> <p>The scenario is the static information that tells LASER what exists in your model world prior to the first timestep. Scenario information will be contained in a DataFrame, either using the <code>grid()</code> function or created manually. Scenarios DataFrames should be formatted with one row per node, and should not be modified during the running of simulations.</p> <p>Scenarios for testing</p> <p>As tests require different initial conditions, it is best practice to build new scenario files for each test instead of reusing or modifying the same scenario. Modification or reuse across test runs can cause the GeoDataFrame to become corrupted.</p> <p>An example using the <code>grid()</code> function:</p> <pre><code>from laser.generic.newutils import grid\n\nscenario = grid(M=1, N=1, population_fn=lambda i, j: 100000)\n</code></pre> <p>will produdce a GeoDataFrame with columns:</p> <ul> <li>nodeid 0 ... N-1, which uniquely identifies each node</li> <li>population, which is the initial population at that node</li> <li>geometry, a polygon representing the node boundary</li> <li>x,y, the centroid coordinates</li> </ul> <p>To create a multi-node scenario with a 5x5 grid of nodes each with a defined population,</p> <pre><code>scenario = grid(\n    M=5,\n    N=5,\n    node_size_km=10,\n    population_fn=lambda i, j: 5000 + (i+j)*100\n)\n</code></pre> <p>To give each node or patch its own initial counts for various disease states, assign those values as columns in the scenario. For example, if you want to configure:</p> <ul> <li>Node 0: 999 S, 1 I, 0 R</li> <li>Node 1: 990 S, 10 I, 0 R</li> <li>Node 2: 950 S, 50 I, 0 R</li> <li>All other nodes: 1000 S, 0 I, O R</li> </ul> <p>The code would be written as:</p> <pre><code>scenario[\"S\"] = [999, 990, 950, 1000, 1000, 1000, 1000, 1000, 1000]\nscenario[\"I\"] = [1, 10, 50, 0, 0, 0, 0, 0, 0]\nscenario[\"R\"] = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n</code></pre>"},{"location":"software-overview/scenario/#models","title":"Models","text":"<p>While the scenario is static information, the model is the behavior of the simulation. Models include a <code>PropertySet</code> custom object containing model parameters, a <code>LaserFrame</code> class to hold simulation data, and as a collection of LASER components which combine to operate on the scenario over time.</p> <p>Information contained in the <code>PropertySet</code> object includes:</p> <ul> <li>The transmission rate, Beta</li> <li>Infection durations</li> <li>The number of timesteps, <code>nticks</code></li> <li>The random seed generator</li> <li>Importation information for seeding infections</li> <li>Seasonality information (if relevant)</li> <li>Migration information (if relevant)</li> </ul> <p>Setting a global random seed</p> <p>To ensure reproducibility across draws in your simulation, including initial infection seeding, birth and death events, agent sampling, and timers and durations, it is important to set a global random seed. To do so, use the <code>laser.core.random.seed()</code> function, which will set the NumPy global PRNG and all Numba thread-local seeds.</p> <p>mkdFor example, <pre><code>from laser.core.random import seed\nfrom laser.generic import Model\nfrom laser.generic.utils import get_default_parameters\n\nseed(42)\n\nparams = get_default_parameters() | {\"nticks\": 365, \"beta\": 0.2}\nmodel = Model(scenario, params)\n</code></pre></p> <p>Information contained in the <code>LaserFrame</code> class (which acts as a DataFrame to hold dynamically allocated data) includes:</p> <ul> <li>Agent-level data such as state, timers, age, and node ID</li> <li>Node-level time series data such as updated disease states or incidence</li> <li>Any other agent or node properties with are updated over time</li> </ul> <p>Seeding infections</p> <p>Disease components (SI, SIR, SEIR, and others) initialize agent state internally based on the state columns in the scenario table. Do not manually assign states in <code>LaserFrame</code> as these will be overwritten during component initialization. Instead, the correct way to seed an outbreak is to modify the scenario:</p> <pre><code>scenario[\"S\"] = initial_susceptible\nscenario[\"I\"] = initial_infected\nscenario[\"R\"] = initial_recovered\n</code></pre> <p>LASER will create the <code>agent-level_state</code> and <code>_itimer</code> values automatically.</p> <p>Example components include:</p> <ul> <li>Transmission</li> <li>Exposure</li> <li>Infection</li> <li>Mortality estimators</li> <li>Birth rates</li> </ul> <p>Components act to update the data stored in <code>LaserFrame</code> over each timestep. When using components, it is important to remember that you should not manually modify agent-level properties directly, modify the scenario table as LASER will update agent properties automatically.</p> <p>It is important to add the desired transmission components prior to running simulations. The components must be passed as a list into <code>model.components</code> to avoid error messages from LASER.</p> <p>For example, for a model with SI dynamics,</p> <pre><code>model = Model(scenario, params)\nmodel.components = [\n    SI.Susceptible(model),\n    SI.TransmissionSIX(model),\n    SI.InfectiousSI(model),\n]\n</code></pre>"},{"location":"software-overview/transmission/","title":"Disease transmission","text":""},{"location":"software-overview/transmission/#transmission-modes","title":"Transmission modes","text":"<p>The LASER framework includes modules for canonical transmission dynamics, including SI, SIS, SIR, SIRS, SEIR, and SEIRS.</p> <p>To build and explore model dynamics, see the Tutorials section.</p>"},{"location":"software-overview/transmission/#immunization","title":"Immunization","text":"<p>Immunity can be introduced into the agent population through several component types.</p> <p>Routine immunization (RI) can be implemented, such that at specified time steps susceptible agents whose age falls within a specified age range will be selected through a binomial draw to be immunized. Routine immunization events can be set up as recurring events that will continuously sample agents in the specified age range at specified time steps to provide immunization coverage.</p> <p>Immunization campaigns can be implemented, such that agents within an age band can be targeted for specific immunization events.</p>"},{"location":"software-overview/demographics/","title":"Demographics","text":""},{"location":"software-overview/demographics/#age-structure","title":"Age structure","text":"<p>If you want to work with age structure for a short simulation which doesn\u2019t need births you can just give everyone an age (based on distribution) and increment it each timestep. The <code>laser_core.demographics.pyramid</code> module is provided to support the initialization of agents with plausible initial ages.</p>"},{"location":"software-overview/demographics/#births","title":"Births","text":""},{"location":"software-overview/demographics/#preborn-management-in-laser","title":"Preborn management in LASER","text":"<p>LASER\u2019s design philosophy emphasizes contiguous and fixed-size arrays, meaning all agents\u2014both currently active and preborn\u2014are created at the start of the simulation. Preborns are \u201cactivated\u201d as they are born, rather than being dynamically added. Several approaches to handling preborns while adhering to these principles are outlined below:</p> <p>Negative and Positive Birthdays:</p> <ul> <li>Assign <code>date_of_birth</code> values in the past (negative) for active agents.</li> <li>Assign <code>date_of_birth</code> values in the future (positive) for preborns.</li> </ul> <p>Unified Preborn Marker:</p> <ul> <li>Set all preborns\u2019 <code>date_of_birth</code> to a placeholder value (e.g., -1).</li> <li>Update the <code>date_of_birth</code> to the current timestep when a preborn is born.</li> </ul> <p>Active Flag Only (if not modeling age structure):</p> <ul> <li>If the model doesn\u2019t require age structure, you can skip date_of_birth entirely. Instead, use an active flag. Preborns start with <code>active = False</code> and are switched to <code>active = True</code> during the fertility step. This simplifies implementation while remaining consistent with LASER principles.</li> </ul>"},{"location":"software-overview/demographics/#calculating-age-from-birthday","title":"Calculating age from birthday","text":"<p>If calculating age isn\u2019t frequent or essential, you can avoid explicitly tracking an age property. Instead, compute age dynamically as the difference between the current timestep (now) and <code>date_of_birth</code>. For models that depend on age-specific dynamics (e.g., fertility rates by age group), consider adding a dedicated age property that updates at each timestep.</p>"},{"location":"software-overview/demographics/#deaths","title":"Deaths","text":"<p>The recommended way of doing mortality in LASER is by precalculating a lifespan for each agent, rather than probabilistically killing agents as the simulation runs. This can take different forms: If you prefer to track agent age, you can also have an agent lifespan. Alternatively, if you are just using <code>date_of_birth</code> you can have a <code>date_of_death</code>, where theses \u2018dates\u2019 are really simulation times (\u2018sim day of birth\u2019 and \u2018sim day of death\u2019).</p> <p>In LASER, we strive to leave the contiguous arrays of agent data in place, without adding or deleting elements (allocating or freeing). This means that to model mortality, we prefer to \u2018kill\u2019 agents by doing either:</p> <ol> <li> <p>check that their age is greater than their lifespan (or that the current timestep is greater than their \u2018sim day of death\u2019) in each component that cares, or</p> </li> <li> <p>Set an active flag to \"false\" or a dead flag to \"true.\"</p> </li> </ol> <p>The second approach is simpler, and avoids doing millions of comparison operations, at the cost of an additional property. Note that many component operations (step functions) can be done without checking whether the agent is alive, because, for example, as long as transmission never infects a dead person, decrementing all non-zero infection timers will only operate on live agents.</p> <p>Finally, while you can set lifespans using any algorithm you want, <code>laser_core.demographics.kmestimator</code> is provided to support these calculations.</p>"},{"location":"software-overview/demographics/#population-pyramids","title":"Population pyramids","text":"<p>The <code>AliasedDistribution</code> class provides a way to sample from a set of options with unequal probabilities, e.g., a population pyramid.</p> <p>The input to the <code>AliasedDistribution</code> constructor is an array of counts by bin as we would naturally get from a population pyramid (# of people in each age bin).</p> <p><code>AliasedDistribution.sample()</code> returns bin indices so it is up to the user to convert the values returned from <code>sample()</code> to actual ages.</p> <p>Expected format of the population pyramid CSV file for <code>load_pyramid_csv()</code>:</p> <pre><code>Header: Age,M,F\nstart-end,#males,#females\nstart-end,#males,#females\nstart-end,#males,#females\n\u2026\nstart-end,#males,#females\nmax+,#males,#females\n</code></pre> <p>For example,</p> <pre><code>Age,M,F\n0-4,9596708,9175309\n5-9,10361680,9904126\n10-14,10781688,10274310\n15-19,11448281,10950664\n\u2026\n90-94,757034,1281854\n95-99,172530,361883\n100+,27665,76635\n</code></pre> <p><code>load_pyramid_csv()</code> returns a 4 column NumPy array with the following columns:</p> <pre><code>0 - Lower bound of age bin, inclusive\n1 - Upper bound of age bin, inclusive\n2 - number of males in the age bin\n3 - number of females in the age bin\n</code></pre> Code example: Loading population pyramids from .csv files <pre><code>import numpy as np\nfrom laser_core.demographics import load_pyramid_csv, AliasedDistribution\nimport importlib.util\nimport os\n\nMCOL = 2\nFCOL = 3\n\nMINCOL = 0\nMAXCOL = 1\n\n# Access the bundled file dynamically\nlaser_core_path = importlib.util.find_spec(\"laser_core\").origin\nlaser_core_dir = os.path.dirname(laser_core_path)\npyramid_file = os.path.join(laser_core_dir, \"data/us-pyramid-2023.csv\")\n\npyramid = load_pyramid_csv(pyramid_file)\nsampler = AliasedDistribution(pyramid[:, MCOL])    # We'll use the male population in this example.\nn_agents = 100_000\nsamples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution.\n# samples will be bin indices, so we need to convert them to ages.\nbin_min_age_days = pyramid[:, MINCOL] * 365          # minimum age for bin, in days (include this value)\nbin_max_age_days = (pyramid[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value)\nmask = np.zeros(n_agents, dtype=bool)\nages = np.zeros(n_agents, dtype=np.int32)\nfor i in range(len(pyramid)):   # for each possible bin value...\n    mask[:] = samples == i      # ...find the agents that belong to this bin\n    # ...and assign a random age, in days, within the bin\n    ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())\n\n# in some LASER models we convert current ages to dates of birth by negating the age\n# dob = -ages\n</code></pre> <p>To explore working with age pyramids, see Age pyramid examples.</p>"},{"location":"software-overview/demographics/#kaplan-meier-estimators","title":"Kaplan-Meier estimators","text":"<p>The <code>KaplanMeierEstimator</code> is used to predict age or year of death. It takes an array of cumulative deaths and returns an object that will sample from the Kaplan-Meier distribution.</p> <p>A sample input array of cumulative deaths might look like this:</p> <pre><code>cd[0] = 687 # 687 deaths in the first year (age 0)\ncd[1] = 733 # +46 deaths in the second year (age 1)\ncd[2] = 767 # +34 deaths in the third year (age 2)\n...\ncd[100] = 100_000  # 100,000 deaths by end of year\n</code></pre> <p><code>predict_year_of_death()</code> takes an array of current ages (in years) and returns an array of predicted years of death based on the cumulative deaths input array.</p> <p>Note</p> <p><code>predict_year_of_death()</code> can use non-constant width age bins and will return predictions by age bin. In this case, it is up to the user to convert the returned bin indices to actual years.</p> <p>A sample non-constant width age bin input array might look like this:</p> <pre><code>cd[0] = 340 # 1/2 of first year deaths in the first 3 months\ncd[1] = 510 # another 1/4 (+170) of first year deaths in the next 3 months\ncd[2] = 687 # another 1/4 (+177) of first year deaths in the last 6 months\ncd[3] = 733 # 46 deaths in the second year (age 1)\ncd[4] = 767 # 34 deaths in the third year (age 2)\n...\ncd[103] = 100_000  # 100,000 deaths by end of year 100\n</code></pre> <p>In this example, values returned from predict_year_of_death() would need to be mapped as follows:</p> <pre><code>0 -&gt; (0, 3] months\n1 -&gt; (3, 6] months\n2 -&gt; (6, 12] months\n3 -&gt; 1 year\n4 -&gt; 2 years\n...\n102 -&gt; 100 years\n</code></pre> <p><code>predict_age_at_death()</code> takes an array of current ages (in days) and returns an array of predicted ages (in days) at death. The implementation assumes that the cumulative deaths input array to the estimator represents one year age bins. If you are using non-constant width age bins, you should manually convert bin indices returned from <code>predict_year_of_death()</code> to ages.</p> <p>To explore working with Kapaln-Meier estimators, see Non-disease death estimation.</p>"},{"location":"software-overview/demographics/#spatial-distributions-of-populations","title":"Spatial distributions of populations","text":"<p>For spatial models, LASER includes functions to distribute populations across nodes. Populations may be distributed in either a skewed or tapered pattern.</p> <p>For a skewed distribution, populations are distributed across nodes according to a simple exponential random distribution, with adjustments to ensure the total population and the specified fraction of rural population is adhered to.</p> <p>For a tapered distribution, populations are distributed following a logarithmic-like decay pattern where the first node (node 0) receives the largest subset of the population (typically half the population), and subsequent nodes receive progressively smaller proportions.</p>"},{"location":"software-overview/demographics/age_pyramid/","title":"Age pyramid examples","text":"In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\nfrom IPython.display import Image\nImage(filename=\"Nigeria-2024.png\")\nImage(filename=\"UnitedStates-2024.png\")\nimport numpy as np\n\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import load_pyramid_csv\n</pre> from pathlib import Path from IPython.display import Image Image(filename=\"Nigeria-2024.png\") Image(filename=\"UnitedStates-2024.png\") import numpy as np  from laser.core.demographics import AliasedDistribution from laser.core.demographics import load_pyramid_csv  In\u00a0[\u00a0]: Copied! <pre>MCOL = 2\nFCOL = 3\n\nMINCOL = 0\nMAXCOL = 1\n\nnigeria = load_pyramid_csv(Path.cwd() / \"Nigeria-2024.csv\")\nsampler = AliasedDistribution(nigeria[:, MCOL])    # We'll use the male population in this example.\nn_agents = 100_000\nsamples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution.\n# samples will be bin indices, so we need to convert them to ages.\nbin_min_age_days = nigeria[:, MINCOL] * 365          # minimum age for bin, in days (include this value)\nbin_max_age_days = (nigeria[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value)\nmask = np.zeros(n_agents, dtype=bool)\nages = np.zeros(n_agents, dtype=np.int32)\nfor i in range(len(nigeria)):   # for each possible bin value...\n    mask[:] = samples == i      # ...find the agents that belong to this bin\n    # ...and assign a random age, in days, within the bin\n    ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())\n</pre> MCOL = 2 FCOL = 3  MINCOL = 0 MAXCOL = 1  nigeria = load_pyramid_csv(Path.cwd() / \"Nigeria-2024.csv\") sampler = AliasedDistribution(nigeria[:, MCOL])    # We'll use the male population in this example. n_agents = 100_000 samples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution. # samples will be bin indices, so we need to convert them to ages. bin_min_age_days = nigeria[:, MINCOL] * 365          # minimum age for bin, in days (include this value) bin_max_age_days = (nigeria[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value) mask = np.zeros(n_agents, dtype=bool) ages = np.zeros(n_agents, dtype=np.int32) for i in range(len(nigeria)):   # for each possible bin value...     mask[:] = samples == i      # ...find the agents that belong to this bin     # ...and assign a random age, in days, within the bin     ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())  In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, ax1 = plt.subplots()\n\n# Plot histogram of samples on primary y-axis\n\nfraction = nigeria[:, MCOL]/nigeria[:, MCOL:FCOL+1].sum()\nax1.plot(fraction, color=\"green\")\nax1.set_xlabel(\"Age Bin\")\nbins = [f\"{i, j}\" for i, j in zip(nigeria[:, MINCOL], nigeria[:, MAXCOL])]\nplt.xticks(rotation=90)\nax1.set_xticks(ticks=range(len(bins)), labels=bins)\nax1.set_ylim(-0.01, 0.1)\nax1.set_ylabel(\"% Population (Input)\", color=\"green\")\n\n# Create secondary y-axis\nax2 = ax1.twinx()\n\n# We will calculate the histogram manually because the final bin isn't the same width as the others.\nhistogram = np.zeros(21, dtype=np.int32)\nfor i in range(histogram.shape[0]):\n    mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices\n    histogram[i] = mask.sum()\n\nscale = nigeria[:,MCOL].sum() / nigeria[:,MCOL:FCOL+1].sum()   # male / male+female\nfraction = (histogram*scale)/histogram.sum()\nax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\")\nax2.set_ylim(-0.01, 0.1)\nax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\")\n\nplt.title(\"Age Distribution in Nigeria\")\nplt.show()\n</pre> import matplotlib.pyplot as plt  fig, ax1 = plt.subplots()  # Plot histogram of samples on primary y-axis  fraction = nigeria[:, MCOL]/nigeria[:, MCOL:FCOL+1].sum() ax1.plot(fraction, color=\"green\") ax1.set_xlabel(\"Age Bin\") bins = [f\"{i, j}\" for i, j in zip(nigeria[:, MINCOL], nigeria[:, MAXCOL])] plt.xticks(rotation=90) ax1.set_xticks(ticks=range(len(bins)), labels=bins) ax1.set_ylim(-0.01, 0.1) ax1.set_ylabel(\"% Population (Input)\", color=\"green\")  # Create secondary y-axis ax2 = ax1.twinx()  # We will calculate the histogram manually because the final bin isn't the same width as the others. histogram = np.zeros(21, dtype=np.int32) for i in range(histogram.shape[0]):     mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices     histogram[i] = mask.sum()  scale = nigeria[:,MCOL].sum() / nigeria[:,MCOL:FCOL+1].sum()   # male / male+female fraction = (histogram*scale)/histogram.sum() ax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\") ax2.set_ylim(-0.01, 0.1) ax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\")  plt.title(\"Age Distribution in Nigeria\") plt.show() In\u00a0[\u00a0]: Copied! <pre>america = load_pyramid_csv(Path.cwd() / \"United States of America-2024.csv\")\nsampler = AliasedDistribution(america[:, FCOL])    # We'll use the female population in this example.\nn_agents = 100_000\nsamples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution.\n# samples will be bin indices, so we need to convert them to ages.\nbin_min_age_days = america[:, MINCOL] * 365          # minimum age for bin, in days (include this value)\nbin_max_age_days = (america[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value)\nmask = np.zeros(n_agents, dtype=bool)\nages = np.zeros(n_agents, dtype=np.int32)\nfor i in range(len(america)):   # for each possible bin value...\n    mask[:] = samples == i      # ...find the agents that belong to this bin\n    # ...and assign a random age, in days, within the bin\n    ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())\n</pre> america = load_pyramid_csv(Path.cwd() / \"United States of America-2024.csv\") sampler = AliasedDistribution(america[:, FCOL])    # We'll use the female population in this example. n_agents = 100_000 samples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution. # samples will be bin indices, so we need to convert them to ages. bin_min_age_days = america[:, MINCOL] * 365          # minimum age for bin, in days (include this value) bin_max_age_days = (america[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value) mask = np.zeros(n_agents, dtype=bool) ages = np.zeros(n_agents, dtype=np.int32) for i in range(len(america)):   # for each possible bin value...     mask[:] = samples == i      # ...find the agents that belong to this bin     # ...and assign a random age, in days, within the bin     ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())  In\u00a0[\u00a0]: Copied! <pre>fig, ax1 = plt.subplots()\n\n# Plot histogram of samples on primary y-axis\n\nfraction = america[:, FCOL]/america[:, MCOL:FCOL+1].sum()\nax1.plot(fraction, color=\"g\")\nax1.set_xlabel(\"Age Bin\")\nplt.xticks(rotation=90)\nbins = [f\"{i, j}\" for i, j in zip(america[:, MINCOL], america[:, MAXCOL])]\nax1.set_xticks(ticks=range(len(bins)), labels=bins)\nax1.set_ylim(-0.01, 0.05)\nax1.set_ylabel(\"% Population (Input)\", color=\"g\")\n\n# We will calculate the histogram manually because the final bin isn't the same width as the others.\nhistogram = np.zeros(21, dtype=np.int32)\nfor i in range(histogram.shape[0]):\n    mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices\n    histogram[i] = mask.sum()\n\n# Create secondary y-axis\nax2 = ax1.twinx()\nscale = america[:,FCOL].sum() / america[:,MCOL:FCOL+1].sum()   # female / male+female\nfraction = (histogram*scale)/histogram.sum()\nax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\")\nax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\")\nax2.set_ylim(-0.01, 0.05)\n\n\nplt.title(\"Age Distribution in the United States\")\nplt.show()\n</pre> fig, ax1 = plt.subplots()  # Plot histogram of samples on primary y-axis  fraction = america[:, FCOL]/america[:, MCOL:FCOL+1].sum() ax1.plot(fraction, color=\"g\") ax1.set_xlabel(\"Age Bin\") plt.xticks(rotation=90) bins = [f\"{i, j}\" for i, j in zip(america[:, MINCOL], america[:, MAXCOL])] ax1.set_xticks(ticks=range(len(bins)), labels=bins) ax1.set_ylim(-0.01, 0.05) ax1.set_ylabel(\"% Population (Input)\", color=\"g\")  # We will calculate the histogram manually because the final bin isn't the same width as the others. histogram = np.zeros(21, dtype=np.int32) for i in range(histogram.shape[0]):     mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices     histogram[i] = mask.sum()  # Create secondary y-axis ax2 = ax1.twinx() scale = america[:,FCOL].sum() / america[:,MCOL:FCOL+1].sum()   # female / male+female fraction = (histogram*scale)/histogram.sum() ax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\") ax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\") ax2.set_ylim(-0.01, 0.05)   plt.title(\"Age Distribution in the United States\") plt.show()"},{"location":"software-overview/demographics/age_pyramid/#age-pyramid-examples","title":"Age pyramid examples\u00b6","text":"<p>We will use a U.S. age pyramid and a Nigerian age pyramid for examples.</p>"},{"location":"software-overview/demographics/age_pyramid/#nigeria","title":"Nigeria\u00b6","text":"<p>Source: https://www.populationpyramid.net/nigeria/2024/</p> <p></p>"},{"location":"software-overview/demographics/age_pyramid/#united-states","title":"United States\u00b6","text":"<p>Source: https://www.populationpyramid.net/united-states-of-america/2024/</p> <p></p>"},{"location":"software-overview/demographics/kmestimator/","title":"Date of non-disease death estimation","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n\ncumulative = np.array([\n     8131,  9396, 10562, 11636, 12620, 13506, 14287, 14958, 15523, 15997,   # year  0.. 9\n    16400, 16756, 17083, 17401, 17725, 18067, 18437, 18837, 19268, 19726,   # year 10..19\n    20207, 20705, 21215, 21732, 22256, 22785, 23319, 23860, 24407, 24961,   # year 20..29\n    25522, 26091, 26668, 27252, 27845, 28446, 29059, 29684, 30324, 30979,   # year 30..39\n    31649, 32334, 33031, 33737, 34452, 35176, 35913, 36666, 37442, 38247,   # year 40..49\n    39085, 39959, 40869, 41815, 42795, 43811, 44866, 45966, 47118, 48330,   # year 50..59\n    49608, 50958, 52380, 53876, 55442, 57080, 58790, 60574, 62435, 64372,   # year 60..69\n    66380, 68451, 70569, 72719, 74880, 77039, 79179, 81288, 83353, 85355,   # year 70..79\n    87274, 89085, 90766, 92299, 93672, 94884, 95936, 96837, 97594, 98216,   # year 80..89\n    98713, 99097, 99383, 99590, 99735, 99833, 99897, 99939, 99965, 99980,   # year 90..99\n    100000, # year 100+\n], dtype=np.int32)\n</pre> import numpy as np  cumulative = np.array([      8131,  9396, 10562, 11636, 12620, 13506, 14287, 14958, 15523, 15997,   # year  0.. 9     16400, 16756, 17083, 17401, 17725, 18067, 18437, 18837, 19268, 19726,   # year 10..19     20207, 20705, 21215, 21732, 22256, 22785, 23319, 23860, 24407, 24961,   # year 20..29     25522, 26091, 26668, 27252, 27845, 28446, 29059, 29684, 30324, 30979,   # year 30..39     31649, 32334, 33031, 33737, 34452, 35176, 35913, 36666, 37442, 38247,   # year 40..49     39085, 39959, 40869, 41815, 42795, 43811, 44866, 45966, 47118, 48330,   # year 50..59     49608, 50958, 52380, 53876, 55442, 57080, 58790, 60574, 62435, 64372,   # year 60..69     66380, 68451, 70569, 72719, 74880, 77039, 79179, 81288, 83353, 85355,   # year 70..79     87274, 89085, 90766, 92299, 93672, 94884, 95936, 96837, 97594, 98216,   # year 80..89     98713, 99097, 99383, 99590, 99735, 99833, 99897, 99939, 99965, 99980,   # year 90..99     100000, # year 100+ ], dtype=np.int32) In\u00a0[\u00a0]: Copied! <pre>from laser.core.demographics import KaplanMeierEstimator\n\nestimator = KaplanMeierEstimator(cumulative)\nnagents = 100_000\ndobs = np.zeros(nagents)    # dates of birth, newborns = 0\ndods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days\n</pre> from laser.core.demographics import KaplanMeierEstimator  estimator = KaplanMeierEstimator(cumulative) nagents = 100_000 dobs = np.zeros(nagents)    # dates of birth, newborns = 0 dods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nhistogram = np.zeros(cumulative.shape[0]+1, np.int32)\nyods = dods // 365  # years of death\nfor i in range(cumulative.shape[0]+1):\n    histogram[i] = np.sum(yods == i)\n\nfig, ax1 = plt.subplots()\n\ncolor = \"tab:orange\"\nax1.set_xlabel(\"Age\")\nax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color)\nax1.plot(np.cumsum(histogram), color=color, marker=\"x\")\nax1.tick_params(axis=\"y\", labelcolor=color)\n\nax2 = ax1.twinx()\ncolor = \"tab:green\"\nax2.set_ylabel(\"Input Cumulative Deaths\", color=color)\nax2.plot(cumulative, color=color)\nax2.tick_params(axis=\"y\", labelcolor=color)\n\nfig.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt  histogram = np.zeros(cumulative.shape[0]+1, np.int32) yods = dods // 365  # years of death for i in range(cumulative.shape[0]+1):     histogram[i] = np.sum(yods == i)  fig, ax1 = plt.subplots()  color = \"tab:orange\" ax1.set_xlabel(\"Age\") ax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color) ax1.plot(np.cumsum(histogram), color=color, marker=\"x\") ax1.tick_params(axis=\"y\", labelcolor=color)  ax2 = ax1.twinx() color = \"tab:green\" ax2.set_ylabel(\"Input Cumulative Deaths\", color=color) ax2.plot(cumulative, color=color) ax2.tick_params(axis=\"y\", labelcolor=color)  fig.tight_layout() plt.show() In\u00a0[\u00a0]: Copied! <pre>nagents = 100_000 - cumulative[49]          # how many 50+ years old do we expect?\ndobs = np.full(nagents, 365*50)             # dates of birth, 50 years old\ndobs += np.random.randint(0, 365, nagents)  # add random days\ndods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days\n</pre> nagents = 100_000 - cumulative[49]          # how many 50+ years old do we expect? dobs = np.full(nagents, 365*50)             # dates of birth, 50 years old dobs += np.random.randint(0, 365, nagents)  # add random days dods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days In\u00a0[\u00a0]: Copied! <pre>histogram = np.zeros(cumulative.shape[0]+1, np.int32)\nyods = dods // 365  # years of death\nfor i in range(cumulative.shape[0]+1):\n    histogram[i] = np.sum(yods == i)\n\nfig, ax1 = plt.subplots()\n\ncolor = \"tab:orange\"\nax1.set_xlabel(\"Age\")\nax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color)\nax1.plot(np.cumsum(histogram), color=color, marker=\"x\")\nax1.tick_params(axis=\"y\", labelcolor=color)\n\nax2 = ax1.twinx()\ncolor = \"tab:green\"\nax2.set_ylabel(\"Input Cumulative Deaths (50+)\", color=color)\nsubsequent = np.maximum(cumulative - cumulative[49], 0)\nax2.plot(subsequent, color=color)\nax2.tick_params(axis=\"y\", labelcolor=color)\n\nfig.tight_layout()\nplt.show()\n</pre> histogram = np.zeros(cumulative.shape[0]+1, np.int32) yods = dods // 365  # years of death for i in range(cumulative.shape[0]+1):     histogram[i] = np.sum(yods == i)  fig, ax1 = plt.subplots()  color = \"tab:orange\" ax1.set_xlabel(\"Age\") ax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color) ax1.plot(np.cumsum(histogram), color=color, marker=\"x\") ax1.tick_params(axis=\"y\", labelcolor=color)  ax2 = ax1.twinx() color = \"tab:green\" ax2.set_ylabel(\"Input Cumulative Deaths (50+)\", color=color) subsequent = np.maximum(cumulative - cumulative[49], 0) ax2.plot(subsequent, color=color) ax2.tick_params(axis=\"y\", labelcolor=color)  fig.tight_layout() plt.show()"},{"location":"software-overview/demographics/kmestimator/#date-of-non-disease-death-estimation","title":"Date of non-disease death estimation\u00b6","text":"<p>The Kaplan-Meier estimator uses survival information to draw for a date of death based on current age.</p> <p>Current age may be non-zero for an initial population or zero for newborn agents.</p>"},{"location":"software-overview/demographics/kmestimator/#population-of-100000","title":"Population of 100,000\u00b6","text":"<p>The input to the Kaplan-Meier estimator is the cumulative number of deaths by bin/age.</p> <p>The following data from Nigeria follow a hypothetical 100,000-person population giving the cumulative number of deaths by each age.</p>"},{"location":"software-overview/demographics/kmestimator/#population-of-50000","title":"Population of 50,000\u00b6","text":"<p>The input to the Kaplan-Meier estimator is the cumulative number of deaths by bin/age.</p> <p>The following data from Nigeria follow a hypothetical 50,000-person population giving the cumulative number of deaths by each age.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>LASER provides a library of reusable epidemiological components as well as canonical transmission models: SI, SIS, SIR, SIRS, SEIR, SEIRS, spatial networks, and more. This flexible framework is customizable, able to be applied to a wide variety of epidemiological modeling questions. From simple transmission modes to complex spatial dynamics, there are numerous ways to combine and apply LASER modules.</p> <p>The following code examples and interactive Jupyter notebooks are designed to provide implementation suggestions and to help familiarize users with core LASER functionality. We encourage new users to explore LASER through the notebooks, and challenge them to create new methods for answering similar questions.</p> <p>The tutorials begin with a simple SIR model, with sample code demonstrating how to configure LASER to implement the <code>SIRModel</code> class. As the tutorial progresses, complexity is added to the model including spatial components and human migration. There is an additional example demonstrating how to use census-based tracking in SIR models.</p> <p>The notebook section contains a suite of interactive notebooks that progress through transmission modes, starting from SI models with no births and sequentially adding additional dynamics to create SIR models with vital dynamics and migration. In addition to the series of notebooks on transmission dynamics, there are notebooks which explore specific LASER features such as births, mortality, and seasonality. We recommend working through the transmission component notebooks prior to the feature notebooks.</p> <p>Suggested order:</p> <ol> <li>SI model with no demographics</li> <li>SI model with constant population demographics</li> <li>SIS model with no demographics</li> <li>Outbreak size in the SIR model</li> <li>Average age at infection in the SIR model</li> <li>Intrinsic periodicity of the SIR model</li> <li>Exploring the critical community size of an SIR model</li> <li>The relationship between coupling and incidence correlation in a 2-patch model</li> <li>Modeling the spread of rabies in one dimension</li> <li>Periodicity of measles in England and Wales</li> </ol> <p>Once you have completed the above notebooks, please explore the following notebooks in any desired order to learn how to implement and integrate custom components:</p> <ul> <li>England and Wales measles analysis</li> <li>SEI and SEIS model implementations</li> <li>Explore the vital dynamics births components</li> <li>Test constant population components</li> <li>Numba compatible distributions</li> <li>Grid function examples</li> <li>Explore the vital dynamics mortality components</li> <li>Explore routine immunization</li> <li>Seasonality in transmission</li> </ul>"},{"location":"tutorials/census_tracker_sir/","title":"Census-based SIR simulation","text":"<p>This script implements a clean, componentized Susceptible-Infectious-Recovered (SIR) model using census-based reporting. It avoids all flow-based tracking (<code>new_infections</code>, <code>incidence</code>, <code>force_of_infection</code>) and instead updates population states directly, recording per-timestep counts from agent states.</p>"},{"location":"tutorials/census_tracker_sir/#imports-and-configuration","title":"Imports and configuration","text":"<pre><code>import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom laser.core import PropertySet\nfrom laser.core.utils import grid\nfrom laser.core.distributions import poisson\nfrom laser.generic.model import Model\nfrom laser.generic import SIR\nfrom laser.generic.shared import State\nfrom laser.core import distributions as dists\n</code></pre> <ul> <li><code>laser.generic.shared.State</code> defines agent-level disease states.</li> <li><code>poisson(...)</code> returns a compiled duration sampler.</li> <li>We reuse <code>SIR.Susceptible</code> only to initialize state and <code>nodeid</code>.</li> </ul>"},{"location":"tutorials/census_tracker_sir/#parameters","title":"Parameters","text":"<pre><code>params = PropertySet({\n    \"nticks\": 160,\n    \"beta\": 0.8,\n    \"mean_infectious_period\": 7.0,\n    \"initial_infected\": 10,\n    \"seed\": 123\n})\n</code></pre> <p>Simulation parameters are wrapped in a <code>PropertySet</code> for consistency with LASER APIs.</p>"},{"location":"tutorials/census_tracker_sir/#scenario-and-model-initialization","title":"Scenario and model initialization","text":"<pre><code>scenario = grid(M=1, N=1, population_fn=lambda r, c: 50000)\nscenario[\"S\"] = scenario[\"population\"] - params.initial_infected\nscenario[\"R\"] = 0\n\nmodel = Model(scenario, params)\npeople = model.people\n</code></pre> <ul> <li>We use a 1x1 grid with 50,000 agents in a single node.</li> <li>Initially susceptible count is offset by <code>initial_infected</code>, which we will seed manually.</li> </ul>"},{"location":"tutorials/census_tracker_sir/#add-node-level-census-properties","title":"Add node-level census properties","text":"<pre><code>nnodes = model.nodes.count\nnticks = params.nticks + 1  # include t=0\n\nmodel.nodes.add_vector_property(\"I\", length=nticks, dtype=np.int32)\nmodel.nodes.add_vector_property(\"R\", length=nticks, dtype=np.int32)\n</code></pre> <ul> <li>LASER does not add <code>nodes.S</code>, <code>nodes.I</code>, or <code>nodes.R</code> by default unless using flow-based components.</li> <li>These vectors will store counts by timestep and node.</li> </ul>"},{"location":"tutorials/census_tracker_sir/#configure-the-infectious-duration-distribution","title":"Configure the infectious duration distribution","text":"<pre><code>infdurdist = poisson(params.mean_infectious_period)\n</code></pre> <p>Returns a Numba-compiled function that generates random infectious durations.</p>"},{"location":"tutorials/census_tracker_sir/#add-components","title":"Add components","text":"<ol> <li> <p><code>TransmissionCensusSI</code></p> <pre><code>class TransmissionCensusSI:\n    ...\n</code></pre> <ul> <li>Computes force of infection as <code>lambda_t = beta * I / N</code>.</li> <li>Infects susceptible agents probabilistically.</li> <li>Assigns state <code>S \u2192 I</code> and initializes <code>infection_timer</code>.</li> </ul> </li> <li> <p><code>InfectiousCensusIR</code></p> <pre><code>class InfectiousCensusIR:\n    ...\n</code></pre> <ul> <li>Decrements <code>infection_timer</code> for infectious agents.</li> <li>Transitions <code>I \u2192 R</code> once timers expire.</li> </ul> </li> <li> <p><code>CensusTracker</code></p> <pre><code>class CensusTracker:\n    ...\n</code></pre> <ul> <li>Counts <code>S</code>, <code>I</code>, and <code>R</code> per node per timestep.</li> <li>Updates <code>model.nodes.{S,I,R}[tick, node]</code> based on agent <code>state</code> and <code>nodeid</code>.</li> </ul> </li> <li> <p><code>SeedInitialInfections</code></p> <pre><code>class SeedInitialInfections:\n    ...\n</code></pre> <p>This component is defined but not used \u2014 infection seeding is done manually near the end of the script.</p> </li> </ol>"},{"location":"tutorials/census_tracker_sir/#component-registration","title":"Component registration","text":"<pre><code>model.components = [\n    SIR.Susceptible(model),\n    TransmissionCensusSI(model, beta=params.beta),\n    InfectiousCensusIR(model),\n    CensusTracker(model)\n]\n</code></pre> <ul> <li>We reuse <code>SIR.Susceptible</code> to create <code>people.state</code> and <code>nodeid</code>.</li> <li>All other components are custom-built to avoid flow-based tracking.</li> </ul>"},{"location":"tutorials/census_tracker_sir/#manually-seed-the-infection","title":"Manually seed the infection","text":"<pre><code>infected_ix = rng.choice(people.count, size=initial, replace=False)\npeople.state[infected_ix] = State.INFECTIOUS.value\n</code></pre> <ul> <li>Directly assigns a few agents to <code>INFECTIOUS</code> before the simulation starts.</li> <li>Could be moved to <code>SeedInitialInfections</code>, but left manual for clarity.</li> </ul>"},{"location":"tutorials/census_tracker_sir/#run-the-simulation","title":"Run the simulation","text":"<pre><code>model.run()\n</code></pre> <p>LASER runs <code>component.step(tick)</code> for each tick <code>0..nticks-1</code>.</p>"},{"location":"tutorials/census_tracker_sir/#save-results-to-csv","title":"Save results to CSV","text":"<pre><code>df = pd.DataFrame({\n    \"time\": np.arange(params.nticks),\n    \"S\": model.nodes.S[:params.nticks, 0],\n    \"I\": model.nodes.I[:params.nticks, 0],\n    \"R\": model.nodes.R[:params.nticks, 0],\n})\ndf.to_csv(\"sir_census.csv\", index=False)\n</code></pre> <ul> <li>Slices only ticks <code>0..159</code> (no extra row).</li> <li>Keeps output in sync with actual simulation ticks.</li> </ul>"},{"location":"tutorials/census_tracker_sir/#plot-results","title":"Plot results","text":"<pre><code>plt.plot(df[\"time\"], df[\"S\"], label=\"S\")\nplt.plot(df[\"time\"], df[\"I\"], label=\"I\")\nplt.plot(df[\"time\"], df[\"R\"], label=\"R\")\n...\nplt.show()\n</code></pre> <ul> <li>Classic SIR curve using matplotlib.</li> <li>Labels and grid added for readability.</li> </ul>"},{"location":"tutorials/census_tracker_sir/#design-notes","title":"Design Notes","text":"<ul> <li>Census-based modeling avoids all flows (<code>new_infections</code>, <code>incidence</code>, etc.).</li> <li>Agent state is the only source of truth; node-level stats are derived by counting.</li> <li>Recovery and transmission separated for clarity and testing.</li> <li>SIR.Susceptible reused only to avoid boilerplate property setup.</li> </ul>"},{"location":"tutorials/census_tracker_sir/#extensions","title":"Extensions","text":"<p>This design can be extended to:</p> <ul> <li>SEIR models with an <code>EXPOSED</code> state and incubation timer</li> <li>Multiple patches (nodes) by using a grid <code>M x N &gt; 1</code></li> <li>Age-structured populations by adding <code>date_of_birth</code> and age-bin logic</li> </ul>"},{"location":"tutorials/sir/","title":"Build SIR models","text":"<p>One of the simplest and most commonly used models to describe the progression of an outbreak or epidemic is the SIR (Susceptible - Infected - Recovered) model. We can use the SIR model to explore how to use the LASER framework, staring with a basic SIR model and adding complexity.</p> <p>This tutorial will:</p> <ul> <li>Demonstrate how the <code>LaserFrame</code> and <code>PropertySet</code> libraries are used</li> <li>Structure a basic disease transmission framework</li> <li>Track and visualize results</li> </ul> <p>As you progress through the sections, you will learn how to add spatial dynamics and migration into the disease model, using both synthetic and real-world data.</p>"},{"location":"tutorials/sir/#simple-sir","title":"Simple SIR","text":"<p>The SIR model presented here simulates disease dynamics within a closed population in a single node using the <code>LaserFrame</code> framework. The population starts with a defined number of susceptible and infected individuals, progresses over time with recovery and transmission components, and tracks results for visualization. This example serves as a practical guide for modeling simple epidemic dynamics. This simple example does not include vital dynamics, age-structured populations, vaccination, or other complex interactions.</p>"},{"location":"tutorials/sir/#model-components","title":"Model components","text":"<p>The <code>SIRModel</code> class is the core of the implementation. It initializes a population using <code>LaserFrame</code>, sets up disease state and recovery timer properties, and tracks results across timesteps.</p> Code example: Implementing <code>SIRModel</code> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom laser.core import LaserFrame\nfrom laser.core import PropertySet\n\nclass SIRModel:\n    def __init__(self, params):\n        # Model Parameters\n        self.params = params\n\n        # Initialize the population LaserFrame\n        self.population = LaserFrame(capacity=params.population_size,initial_count=params.population_size)\n\n        # Add disease state property (0 = Susceptible, 1 = Infected, 2 = Recovered)\n        self.population.add_scalar_property(\"disease_state\", dtype=np.int32, default=0)\n\n        # Add a recovery timer property (for intrahost progression, optional for timing)\n        self.population.add_scalar_property(\"recovery_timer\", dtype=np.int32, default=0)\n\n        # Results tracking\n        self.results = LaserFrame( capacity = 1 ) # number of nodes\n        self.results.add_vector_property( \"S\", length=params[\"timesteps\"], dtype=np.float32 )\n        self.results.add_vector_property( \"I\", length=params[\"timesteps\"], dtype=np.float32 )\n        self.results.add_vector_property( \"R\", length=params[\"timesteps\"], dtype=np.float32 )\n\n        # Components\n        self.components = []\n\n    def add_component(self, component):\n        self.components.append(component)\n\n    def track_results(self, tick):\n        susceptible = (self.population.disease_state == 0).sum()\n        infected = (self.population.disease_state == 1).sum()\n        recovered = (self.population.disease_state == 2).sum()\n        total = self.population.count\n        self.results.S[tick] = susceptible / total\n        self.results.I[tick] = infected / total\n        self.results.R[tick] = recovered / total\n\n    def run(self):\n        for tick in range(self.params.timesteps):\n            for component in self.components:\n                component.step()\n            self.track_results(tick)\n\n    def plot_results(self):\n        plt.figure(figsize=(10, 6))\n        plt.plot(self.results.S, label=\"Susceptible (S)\", color=\"blue\")\n        plt.plot(self.results.I, label=\"Infected (I)\", color=\"red\")\n        plt.plot(self.results.R, label=\"Recovered (R)\", color=\"green\")\n        plt.title(\"SIR Model Dynamics with LASER Components\")\n        plt.xlabel(\"Time (Timesteps)\")\n        plt.ylabel(\"Fraction of Population\")\n        plt.legend()\n        plt.grid()\n        plt.show()\n        plt.savefig(\"gpt_sir.png\")\n</code></pre> <p>The <code>IntrahostProgression</code> class manages recovery dynamics by updating infected individuals based on a given recovery rate.</p> Code example: Implementing <code>IntrahostProgression</code> <pre><code>class IntrahostProgression:\n    def __init__(self, model):\n        self.population = model.population\n\n        # Seed the infection\n        num_initial_infected = int(0.01 * params.population_size)  # e.g., 1% initially infected\n        infected_indices = np.random.choice(params.population_size, size=num_initial_infected, replace=False)\n        self.population.disease_state[infected_indices] = 1\n\n        # Initialize recovery timer for initially infected individuals\n        initially_infected = self.population.disease_state == 1\n        self.population.recovery_timer[initially_infected] = np.random.randint(5, 15, size=initially_infected.sum())\n\n    def step(self):\n        infected = self.population.disease_state == 1\n\n        # Decrement recovery timer\n        self.population.recovery_timer[infected] -= 1\n\n        # Recover individuals whose recovery_timer has reached 0\n        recoveries = infected &amp; (self.population.recovery_timer &lt;= 0)\n        self.population.disease_state[recoveries] = 2\n</code></pre> <p>The <code>Transmission</code> class manages disease spread by modeling interactions between susceptible and infected individuals.</p> Code example: Implementing <code>Transmission</code> <pre><code>class Transmission:\n    def __init__(self, model):\n        self.population = model.population\n        self.infection_rate = model.params.infection_rate\n\n    def step(self):\n        susceptible = self.population.disease_state == 0\n        infected = self.population.disease_state == 1\n\n        num_susceptible = susceptible.sum()\n        num_infected = infected.sum()\n        population_size = len(self.population)\n\n        # Fraction of infected and susceptible individuals\n        fraction_infected = num_infected / population_size\n\n        # Transmission logic: Probability of infection per susceptible individual\n        infection_probability = self.infection_rate * fraction_infected\n\n        # Apply infection probability to all susceptible individuals\n        new_infections = np.random.rand(num_susceptible) &lt; infection_probability\n\n        # Set new infections and initialize their recovery_timer\n        susceptible_indices = np.where(susceptible)[0]\n        newly_infected_indices = susceptible_indices[new_infections]\n        self.population.disease_state[newly_infected_indices] = 1\n        self.population.recovery_timer[newly_infected_indices] = np.random.randint(5, 15, size=newly_infected_indices.size)  # Random recovery time\n</code></pre> <p>The simulation parameters are defined using the <code>PropertySet</code> class.</p> Code example: Defining simulation parameters using <code>PropertySet</code> <pre><code>params = PropertySet({\n    \"population_size\": 100_000,\n    \"infection_rate\": 0.3,\n    \"timesteps\": 160\n})\n</code></pre> <p>The model is initialized with the defined parameters, components are added, and the simulation is run for the specified timesteps. Results are then visualized.</p> Code example: Initialize, run the simulation, and plot the results <pre><code># Initialize the model\nsir_model = SIRModel(params)\n\n# Initialize and add components\nsir_model.add_component(IntrahostProgression(sir_model))\nsir_model.add_component(Transmission(sir_model))\n\n# Run the simulation\nsir_model.run()\n\n# Plot results\nsir_model.plot_results()\n</code></pre>"},{"location":"tutorials/sir/#spatial-sir","title":"Spatial SIR","text":"<p>Building upon the simple SIR  model created above, we can add spatial complexity to the framework. Here the simple SIR model will spread the population across 20 nodes. The nodes are arranged in a 1-dimensional chain and infection spreads spatially from node 0 as agents migrate; migration is based on a migration matrix.</p> <p>In this example, two migration options are available:</p> <ol> <li>Sequential migration matrix: Agents can only move to the next node in the chain.</li> <li>Gravity model migration matrix: Agents can move in a 2-dimensional spatial dynamic, where migration probabilities depend on node distances and population sizes.</li> </ol> <p>For this example, the population is distributed across nodes using a rural-urban skew, and migration timers are assigned to control agent migration frequency.</p>"},{"location":"tutorials/sir/#model-components_1","title":"Model components","text":"<p>As above, the model will require the use of <code>LaserFrame</code>, but will now also include spatial components.</p> Code example: Initial model importations <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport csv\nfrom laser.core.laserframe import LaserFrame\nfrom laser.core.demographics.spatialpops import distribute_population_skewed as dps\nfrom laser.core.migration import gravity\n</code></pre> <p>Instead of using the <code>SIRModel</code>, we will use the <code>MultiNodeSIRModel</code>.</p> Code example: Creating a model using <code>MultiNodeSIRModel</code> <pre><code># Define the model\nclass MultiNodeSIRModel:\n    \"\"\"\n    A multi-node SIR (Susceptible-Infected-Recovered) disease transmission model.\n\n    Attributes:\n        params (dict): Configuration parameters for the model.\n        nodes (int): Number of nodes in the simulation.\n        population (LaserFrame): Represents the population with agent-level properties.\n        results (np.ndarray): Stores simulation results for S, I, and R per node.\n        components (list): List of components (e.g., Migration, Transmission) added to the model.\n    \"\"\"\n\n    def __init__(self, params):\n        \"\"\"\n        Initializes the SIR model with the given parameters.\n\n        Args:\n            params (dict): Dictionary containing parameters such as population size,\n                           number of nodes, timesteps, and rates for transmission/migration.\n        \"\"\"\n        self.components = []\n        self.params = params\n        self.nodes = params[\"nodes\"]\n        self.population = LaserFrame(capacity=params[\"population_size\"], initial_count=params[\"population_size\"])\n\n        # Define properties\n        self.population.add_scalar_property(\"node_id\", dtype=np.int32)\n        self.population.add_scalar_property(\"disease_state\", dtype=np.int32, default=0)  # 0=S, 1=I, 2=R\n        self.population.add_scalar_property(\"recovery_timer\", dtype=np.int32, default=0)\n        self.population.add_scalar_property(\"migration_timer\", dtype=np.int32, default=0)\n\n        # Initialize population distribution\n        node_pops = dps(params[\"population_size\"], self.nodes, frac_rural=0.3)\n        node_ids = np.concatenate([np.full(count, i) for i, count in enumerate(node_pops)])\n        np.random.shuffle(node_ids)\n        self.population.node_id[:params[\"population_size\"]] = node_ids\n\n        # Reporting structure: Use LaserFrame for reporting\n        self.results = LaserFrame( capacity=self.nodes ) # not timesteps for capacity\n        for state in [\"S\", \"I\", \"R\"]:\n            self.results.add_vector_property(state, length=params[\"timesteps\"], dtype=np.int32)\n\n        # Record results: reporting could actually be a component if we wanted. Or it can be\n        # done in a log/report function in the relevant component (e.g., Transmission)\n        self.results.S[self.current_timestep, :] = [\n            np.sum(self.population.disease_state[self.population.node_id == i] == 0)\n            for i in range(self.nodes)\n        ]\n        self.results.I[self.current_timestep, :] = [\n            np.sum(self.population.disease_state[self.population.node_id == i] == 1)\n            for i in range(self.nodes)\n        ]\n        self.results.R[self.current_timestep, :] = [\n            np.sum(self.population.disease_state[self.population.node_id == i] == 2)\n            for i in range(self.nodes)\n        ]\n\n    def add_component(self, component):\n        \"\"\"\n        Adds a component (e.g., Migration, Transmission, Recovery) to the model.\n\n        Args:\n            component: An instance of a component to be added.\n        \"\"\"\n        self.components.append(component)\n\n    def step(self):\n        \"\"\"\n        Advances the simulation by one timestep, updating all components and recording results.\n        \"\"\"\n        for component in self.components:\n            component.step()\n\n        # Record results\n        for i in range(self.nodes):\n            in_node = self.population.node_id == i\n            self.results[self.current_timestep, i, 0] = (self.population.disease_state[in_node] == 0).sum()\n            self.results[self.current_timestep, i, 1] = (self.population.disease_state[in_node] == 1).sum()\n            self.results[self.current_timestep, i, 2] = (self.population.disease_state[in_node] == 2).sum()\n\n    def run(self):\n        \"\"\"\n        Runs the simulation for the configured number of timesteps.\n        \"\"\"\n        from tqdm import tqdm\n        for self.current_timestep in tqdm(range(self.params[\"timesteps\"])):\n            self.step()\n\n    def save_results(self, filename):\n        \"\"\"\n        Saves the simulation results to a CSV file.\n\n        Args:\n            filename (str): Path to the output file.\n        \"\"\"\n        with open(filename, mode='w', newline='') as file:\n            writer = csv.writer(file)\n            writer.writerow([\"Timestep\", \"Node\", \"Susceptible\", \"Infected\", \"Recovered\"])\n            for t in range(self.params[\"timesteps\"]):\n                for node in range(self.nodes):\n                    writer.writerow([t, node, *self.results[t, node]])\n\n    def plot_results(self):\n        \"\"\"\n        Plots the prevalence of infected agents over time for all nodes.\n        \"\"\"\n        plt.figure(figsize=(10, 6))\n        for i in range(self.nodes):\n            prevalence = self.results.I[:, i] / (\n                self.results.S[:, i] +\n                self.results.I[:, i] +\n                self.results.R[:, i]\n            )\n            plt.plot(prevalence, label=f\"Node {i}\")\n\n        plt.title(\"Prevalence Across All Nodes\")\n        plt.xlabel(\"Timesteps\")\n        plt.ylabel(\"Prevalence of Infected Agents\")\n        plt.legend()\n        plt.show()\n</code></pre> <p>To add migration between nodes, we will need to select the type of migration model to use and import the component. Here, we will use the sequential migration matrix to move agents sequentially between nodes. The 0th node is the 'urban' node which contains the largest population and where we seed the infection. The infection will travel sequentially from node to node, but the below example breaks the connection at node 13 for demonstrative purposes.</p> Code example: Adding migration using the sequential migration matrix <pre><code>class MigrationComponent:\n    \"\"\"\n    Handles migration behavior of agents between nodes in the model.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n        migration_matrix (ndarray): A matrix representing migration probabilities between nodes.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the MigrationComponent.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n        # Set initial migration timers\n        max_timer = int(1 / model.params[\"migration_rate\"])\n        model.population.migration_timer[:] = np.random.randint(1, max_timer + 1, size=model.params[\"population_size\"])\n\n        self.migration_matrix = self.get_sequential_migration_matrix(model.nodes)\n\n        # Example customization: Disable migration from node 13 to 14\n        def break_matrix_node(matrix, from_node, to_node):\n            matrix[from_node][to_node] = 0\n        break_matrix_node(self.migration_matrix, 13, 14)\n\n    def get_sequential_migration_matrix(self, nodes):\n        \"\"\"\n        Creates a migration matrix where agents can only migrate to the next sequential node.\n\n        Args:\n            nodes (int): Number of nodes in the simulation.\n\n        Returns:\n            ndarray: A migration matrix where migration is allowed only to the next node.\n        \"\"\"\n        migration_matrix = np.zeros((nodes, nodes))\n        for i in range(nodes - 1):\n            migration_matrix[i, i + 1] = 1.0\n        return migration_matrix\n\n    def step(self):\n        \"\"\"\n        Updates the migration state of the population by determining which agents migrate\n        and their destinations based on the migration matrix.\n        \"\"\"\n        node_ids = self.model.population.node_id\n\n        # Decrement migration timers\n        self.model.population.migration_timer -= 1\n\n        # Identify agents ready to migrate\n        migrating_indices = np.where(self.model.population.migration_timer &lt;= 0)[0]\n        if migrating_indices.size == 0:\n            return\n\n        # Shuffle migrants and assign destinations based on migration matrix\n        np.random.shuffle(migrating_indices)\n        destinations = np.empty(len(migrating_indices), dtype=int)\n        for origin in range(self.model.nodes):\n            origin_mask = node_ids[migrating_indices] == origin\n            num_origin_migrants = origin_mask.sum()\n\n            if num_origin_migrants &gt; 0:\n                # Assign destinations proportionally to migration matrix\n                destination_counts = np.round(self.migration_matrix[origin] * num_origin_migrants).astype(int)\n                destination_counts = np.maximum(destination_counts, 0)  # Clip negative values\n                if destination_counts.sum() == 0:  # No valid destinations\n                    destinations[origin_mask] = origin  # Stay in the same node\n                    continue\n                destination_counts[origin] += num_origin_migrants - destination_counts.sum()  # Adjust rounding errors\n\n                # Create ordered destination assignments\n                destination_indices = np.repeat(np.arange(self.model.nodes), destination_counts)\n                destinations[origin_mask] = destination_indices[:num_origin_migrants]\n\n        # Update node IDs of migrants\n        node_ids[migrating_indices] = destinations\n\n        # Reset migration timers for migrated agents\n        self.model.population.migration_timer[migrating_indices] = np.random.randint(\n            1, int(1 / self.model.params[\"migration_rate\"]) + 1, size=migrating_indices.size\n        )\n</code></pre> <p>To create more complicated and more realistic migration dynamics, instead of using sequential migration we can use the gravity model to implement 2-D migration. Migration rates are proportional to population sizes, but the example still uses synthetic distances for ease of demonstration.</p> Code example: Adding migration using the gravity model of migration <pre><code>class MigrationComponent2D:\n    \"\"\"\n    Handles migration behavior of agents between nodes in the model.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n        migration_matrix (ndarray): A matrix representing migration probabilities between nodes.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the MigrationComponent.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n        # Set initial migration timers\n        max_timer = int(1 / model.params[\"migration_rate\"])\n        model.population.migration_timer[:] = np.random.randint(1, max_timer + 1, size=model.params[\"population_size\"])\n\n        self.migration_matrix = self.get_gravity_migration_matrix(model.nodes)\n\n    def get_gravity_migration_matrix(self, nodes):\n        \"\"\"\n        Generates a gravity-based migration matrix based on population and distances between nodes.\n\n        Args:\n            nodes (int): Number of nodes in the simulation.\n\n        Returns:\n            ndarray: A migration matrix where each row represents probabilities of migration to other nodes.\n        \"\"\"\n        pops = np.array([np.sum(self.model.population.node_id == i) for i in range(nodes)])\n        distances = np.ones((nodes, nodes)) - np.eye(nodes)\n        migration_matrix = gravity(pops, distances, k=1.0, a=0.5, b=0.5, c=2.0)\n        migration_matrix = migration_matrix / migration_matrix.sum(axis=1, keepdims=True)\n        return migration_matrix\n\n    def step(self):\n\n        \"\"\"\n        Executes the migration step for the agent-based model.\n\n        This function selects a fraction of agents to migrate based on expired migration timers.\n        It then changes their node_id according to the migration matrix, ensuring that movements\n        follow the prescribed probability distributions.\n\n        Steps:\n        - Selects a subset of the population for migration.\n        - Determines the origin nodes of migrating agents.\n        - Uses a multinomial draw to assign new destinations based on the migration matrix.\n        - Updates the agents' node assignments accordingly.\n\n        Returns:\n            None\n        \"\"\"\n        # Decrement migration timers\n        self.model.population.migration_timer -= 1\n\n        # Identify agents ready to migrate\n        migrating_indices = np.where(self.model.population.migration_timer &lt;= 0)[0]\n        if migrating_indices.size == 0:\n            return\n\n        np.random.shuffle(migrating_indices)\n\n        origins = model.population.node_id[migrating_indices]\n        origin_counts = np.bincount(origins, minlength=model.params[\"nodes\"])\n\n        offset = 0\n\n        for origin in range(model.params[\"nodes\"]):\n            count = origin_counts[origin]\n            if count == 0:\n                continue\n\n            origin_slice = migrating_indices[offset : offset + count]\n            offset += count\n\n            row = self.migration_matrix[origin]\n            row_sum = row.sum()\n            if row_sum &lt;= 0:\n                continue\n\n            fraction_row = row / row_sum\n            destination_counts = np.random.multinomial(count, fraction_row)\n            destinations = np.repeat(np.arange(model.params[\"nodes\"]), destination_counts)\n            model.population.node_id[origin_slice] = destinations[:count]\n\n        # Reset migration timers for migrated agents\n        self.model.population.migration_timer[migrating_indices] = np.random.randint(\n            1, int(1 / self.model.params[\"migration_rate\"]) + 1, size=migrating_indices.size\n        )\n</code></pre> <p>After selecting your desired migration patterns, you will need to add in a transmission component to create disease dynamics.</p> Code example: Adding in disease transmission <pre><code>class TransmissionComponent:\n    \"\"\"\n    Handles the disease transmission dynamics within the population.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the TransmissionComponent and infects initial agents.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n    def step(self):\n        \"\"\"\n        Simulates disease transmission for each node in the current timestep.\n        \"\"\"\n        for i in range(self.model.nodes):\n            in_node = self.model.population.node_id == i\n            susceptible = in_node &amp; (self.model.population.disease_state == 0)\n            infected = in_node &amp; (self.model.population.disease_state == 1)\n\n            num_susceptible = susceptible.sum()\n            num_infected = infected.sum()\n            total_in_node = in_node.sum()\n\n            if total_in_node &gt; 0 and num_infected &gt; 0 and num_susceptible &gt; 0:\n                infectious_fraction = num_infected / total_in_node\n                susceptible_fraction = num_susceptible / total_in_node\n\n                new_infections = int(\n                    self.model.params[\"transmission_rate\"] * infectious_fraction * susceptible_fraction * total_in_node\n                )\n\n                susceptible_indices = np.where(susceptible)[0]\n                newly_infected_indices = np.random.choice(susceptible_indices, size=new_infections, replace=False)\n\n                self.model.population.disease_state[newly_infected_indices] = 1\n                self.model.population.recovery_timer[newly_infected_indices] = np.random.randint(5, 15, size=new_infections)\n</code></pre> <p>Finally, we need to add recovery dynamics to the model to move agents through the disease progression.</p> Code example: Adding in recovery dynamics <pre><code>class RecoveryComponent:\n    \"\"\"\n    Handles the recovery dynamics of infected individuals in the population.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the RecoveryComponent.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n    def step(self):\n        \"\"\"\n        Updates the recovery state of infected individuals, moving them to the recovered state\n        if their recovery timer has elapsed.\n        \"\"\"\n        infected = self.model.population.disease_state == 1\n        self.model.population.recovery_timer[infected] -= 1\n        self.model.population.disease_state[(infected) &amp; (self.model.population.recovery_timer &lt;= 0)] = 2\n</code></pre> <p>To run the created model and visualize your output, we will need to set our model parameters and run the simulation.</p> Code example: Running your spatial SIR model <pre><code># Parameters\nparams = {\n    \"population_size\": 1_000_000,\n    \"nodes\": 20,\n    \"timesteps\": 600,\n    \"initial_infected_fraction\": 0.01,\n    \"transmission_rate\": 0.25,\n    \"migration_rate\": 0.001\n}\n\n# Run simulation\nmodel = MultiNodeSIRModel(params)\nmodel.add_component(MigrationComponent(model))\nmodel.add_component(TransmissionComponent(model))\nmodel.add_component(RecoveryComponent(model))\nmodel.run()\nmodel.save_results(\"simulation_results.csv\")\nmodel.plot_results()\n</code></pre>"},{"location":"tutorials/sir/#using-real-data","title":"Using real data","text":"<p>To utilize SIR models to understand real-world transmission dynamics, you will need to use real data. Model structure will be similar to what was presented above, but instead of using a synthetic population we will initialize the model using real population data. In this example, we will use data from Rwanda. You will want your data saved in a .csv file, with the following information:</p> <ul> <li>Region_id: node location, here each node is a city in Rwanda</li> <li>Population: the population of the node</li> <li>Centroid_lat and centroid-long: the latitude and longitude at the center of the node</li> <li>Birth_rate: the birth rate for the node</li> </ul> region_id population centroid_lat centroid_long birth_rate Ryansoro 46482.7 -3.70727 29.7988 11.6565 Ndava 72979.3 -3.39156 29.7534 15.8815 Buyengero 76468.8 -3.84874 29.533 12.5038 Bugarama 44571.9 -3.69048 29.4004 11.0256 Rumonge 300248 -3.96221 29.4571 19.5677 Burambi 63219.7 -3.79864 29.4524 9.19902 Kanyosha1 115018 -3.43097 29.4153 37.9514 Kabezi 71913.8 -3.5311 29.37 31.8319 Muhuta 88141.7 -3.62351 29.4152 21.5989 <p>The model code will be very similar to the code used above, but the population data will be loaded from the .csv file instead of created synthetically. In the following example, numbers are rounded and scaled down (which is optional), and each node is assigned an ID.</p> Code example: Creating a model using data loaded from a CSV <pre><code>class SpatialSIRModelRealData:\n    def __init__(self, params, population_data):\n        \"\"\"\n            Initialize the mode, LASER-style, using the population_data loaded from a csv file (pandas).\n            Create nodes and a migration_matrix based on populations and locations of each node.\n\n        \"\"\"\n        self.params = params\n        # We scale down population here from literal values but this may not be necessary.\n        population_data[\"scaled_population\"] = (population_data[\"population\"] / params[\"scale_factor\"]).round().astype(int)\n        total_population = int(population_data[\"scaled_population\"].sum())\n        print( f\"{total_population=}\" )\n\n        # Set up the properties as before\n        self.population = LaserFrame(capacity=total_population, initial_count=total_population)\n        self.population.add_scalar_property(\"node_id\", dtype=np.int32)\n        self.population.add_scalar_property(\"disease_state\", dtype=np.int32, default=0)\n        self.population.add_scalar_property(\"recovery_timer\", dtype=np.int32, default=0)\n        self.population.add_scalar_property(\"migration_timer\", dtype=np.int32, default=0)\n\n        node_pops = population_data[\"scaled_population\"].values\n        self.params[\"nodes\"] = len(node_pops)\n\n        node_ids = np.concatenate([np.full(count, i) for i, count in enumerate(node_pops)])\n        np.random.shuffle(node_ids)\n        self.population.node_id[:total_population] = node_ids\n\n        # seed in big node\n        big_node_id = np.argmax( node_pops )\n        available_population = population_data[\"scaled_population\"][big_node_id]\n        initial_infected = int(params[\"initial_infected_fraction\"] * available_population)\n        infection_indices = np.random.choice(np.where(self.population.node_id == big_node_id)[0], initial_infected, replace=False)\n        self.population.disease_state[infection_indices] = 1\n        self.population.recovery_timer[infection_indices] = np.random.uniform(params[\"recovery_time\"] - 3, params[\"recovery_time\"] + 3, size=initial_infected).astype(int)\n\n        pop_sizes = np.array(node_pops)\n        latitudes = population_data[\"centroid_lat\"].values\n        longitudes = population_data[\"centroid_long\"].values\n        distances = np.zeros((self.params[\"nodes\"], self.params[\"nodes\"]))\n\n        # Nested for loop here is optimized for readbility, not performance\n        for i in range(self.params[\"nodes\"]):\n            for j in range(self.params[\"nodes\"]):\n                if i != j:\n                    distances[i, j] = distance(latitudes[i], longitudes[i], latitudes[j], longitudes[j])\n\n        # Set up our migration_matrix based on gravity model and input data (pops &amp; distances)\n        self.distances = distances\n        self.migration_matrix = gravity(pop_sizes, distances, k=10.0, a=1.0, b=1.0, c=1.0)\n        self.migration_matrix /= self.migration_matrix.sum(axis=1, keepdims=True) # normalize\n</code></pre>"},{"location":"tutorials/sir/#alternative-migration-approach","title":"Alternative migration approach","text":"<p>In the above examples, we modeled migration by moving individual agents from node to node. An alternative approach is to model the migration of infection instead of individuals; this allows for computational efficiency while maintaining accurate disease transmission dynamics. Note that in this example, we do not use a <code>MigrationComponent</code> or <code>migration_timer</code>.</p> Code example: Modeling migration of infection instead of individuals <pre><code>import numpy as np\nfrom laser.core.migration import gravity\nfrom laser.core.utils import calc_distances\n\nclass TransmissionComponent:\n    \"\"\"\n    Transmission Component\n    =======================\n\n    This class models the transmission of disease using \"infection migration\"\n    instead of human movement. Instead of tracking individual movement,\n    infection is spread probabilistically based on a gravity-inspired network.\n\n    This approach can significantly improve computational efficiency for\n    large-scale spatial epidemic simulations.\n\n    Attributes:\n    ------------\n    model : object\n        The simulation model containing population and node information.\n    network : ndarray\n        A matrix representing the transmission probabilities between nodes.\n    locations : ndarray\n        Array of node latitude and longitude coordinates.\n    \"\"\"\n    def __init__(self, model):\n        \"\"\"\n        Initializes the transmission component by computing the infection migration network.\n\n        Parameters:\n        -----------\n        model : object\n            The simulation model containing population and node information.\n        \"\"\"\n        self.model = model\n        model.nodes.add_vector_property(\"network\", length=model.nodes.count, dtype=np.float32)\n        self.network = model.nodes.network\n\n        # Extract node locations and populations from model.population_data\n        self.locations = np.column_stack((model.population_data[\"centroid_lat\"], model.population_data[\"centroid_long\"]))\n        initial_populations = np.array(model.population_data[\"population\"])\n\n        # Initialize heterogeneous transmission factor per agent (0.5 to 2.0)\n        self.model.population.tx_hetero_factor = np.random.uniform(0.5, 2.0, size=model.population.capacity)\n\n        # Compute the infection migration network based on node populations.\n        a, b, c, k = self.model.params.a, self.model.params.b, self.model.params.c, self.model.params.k\n\n        # Compute all pairwise distances in one call (this speeds up initialization significantly)\n        # from laser.core.migration import gravity, row_normalizer\n        # from laser.core.utils import calc_distances\n        distances = calc_distances(self.locations[:, 0], self.locations[:, 1])\n        self.network = gravity(initial_populations, distances, k, a, b, c)\n        self.network /= np.power(initial_populations.sum(), c)  # Normalize\n        self.network = row_normalizer(self.network, 0.01) # 0.01=max_frac\n\n   def step(self):\n        \"\"\"\n        Simulates disease transmission and infection migration across the network.\n\n        New infections are determined deterministically based on contagion levels and susceptible fraction.\n        \"\"\"\n        contagious_indices = np.where(self.model.population.disease_state == 1)[0]\n        values = self.model.population.tx_hetero_factor[contagious_indices]  # Apply heterogeneity factor\n\n        # Compute contagion levels per node\n        contagion = np.bincount(\n            self.model.population.node_id[contagious_indices],\n            weights=values,\n            minlength=self.model.nodes.count\n        ).astype(np.float64)\n\n        # Apply network-based infection movement\n        transfer = (contagion * self.network).round().astype(np.float64)\n\n        # Ensure net contagion remains positive after movement\n        contagion += transfer.sum(axis=1) - transfer.sum(axis=0)\n        contagion = np.maximum(contagion, 0)  # Prevent negative contagion\n\n        # Infect susceptible individuals in each node deterministically\n        for i in range(self.model.nodes.count):\n            node_population = np.where(self.model.population.node_id == i)[0]\n            susceptible = node_population[self.model.population.disease_state[node_population] == 0]\n\n            if len(susceptible) &gt; 0:\n                # Compute new infections deterministically based on prevalence and susceptible fraction\n                num_new_infections = int(min(len(susceptible), (\n                    self.model.params.transmission_rate * contagion[i] * len(susceptible) / len(node_population)\n                )))\n\n                # Randomly select susceptible individuals for infection\n                new_infected_indices = np.random.choice(susceptible, size=num_new_infections, replace=False)\n                self.model.population.disease_state[new_infected_indices] = 1\n\n                # Assign recovery timers to newly infected individuals\n                self.model.population.recovery_timer[new_infected_indices] = np.random.randint(5, 15, size=num_new_infections)\n</code></pre>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/","title":"SI model with no demographics","text":"In\u00a0[1]: Copied! <pre>from laser.generic.utils import TimingStats as ts # noqa: I001\n\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom matplotlib import pyplot as plt\nfrom scipy.optimize import curve_fit\nfrom scipy.optimize import minimize\n\nimport laser.core\nimport laser.generic\nimport laser.generic.SI as SI\nfrom laser.generic import Model\nfrom laser.core.utils import grid\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> from laser.generic.utils import TimingStats as ts # noqa: I001  import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from matplotlib import pyplot as plt from scipy.optimize import curve_fit from scipy.optimize import minimize  import laser.core import laser.generic import laser.generic.SI as SI from laser.generic import Model from laser.core.utils import grid  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\") <pre>np.__version__='2.2.6'\nlaser.core.__version__='0.9.1'\nlaser.generic.__version__='0.0.0'\n</pre> <p>A note that order of the model components matters, because of how recording of relevant statistics into outputs occurs.  If transmission comes before susceptibility, then we have N=S+I+\u0394I, because we record I, record \u0394I, do transmission, then record S after the transmission process occurs.  With susceptibility first, we record S, then record I, then do transmission (and record \u0394I), and so we have N=S+I.</p> In\u00a0[2]: Copied! <pre>pop = 1e6\ninit_inf = 1\n# Seattle: 47\u00b036'35\" -122\u00b019'59\"\nlatitude = 47+(36+(35/60))/60\nlongitude = -(122+(19+(59/60))/60)\nscenario = grid(M=1,N=1, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude)\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\nparameters = PropertySet({\"prng_seed\": 6, \"nticks\": 730, \"verbose\": True, \"beta\": 0.05})\n\n# Run until we get an outbreak\noutbreak = False\nwhile not outbreak:\n\n    parameters.prng_seed += 1\n    model = Model(scenario, parameters)\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.Transmission(model),\n    ]\n\n    model.run()\n\n    outbreak = np.any(model.nodes.I[180] != 0)\n</pre> pop = 1e6 init_inf = 1 # Seattle: 47\u00b036'35\" -122\u00b019'59\" latitude = 47+(36+(35/60))/60 longitude = -(122+(19+(59/60))/60) scenario = grid(M=1,N=1, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude) scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf parameters = PropertySet({\"prng_seed\": 6, \"nticks\": 730, \"verbose\": True, \"beta\": 0.05})  # Run until we get an outbreak outbreak = False while not outbreak:      parameters.prng_seed += 1     model = Model(scenario, parameters)     model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.Transmission(model),     ]      model.run()      outbreak = np.any(model.nodes.I[180] != 0)  <pre>1,000,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1835.57it/s]\n</pre> In\u00a0[3]: Copied! <pre>plt.plot(model.nodes.I, lw=4)\nN = model.nodes.S + model.nodes.I\nplt.plot(N - model.nodes.S, \"--\", lw=3)\nplt.plot(init_inf + np.insert(np.cumsum(model.nodes.newly_infected[:-1]), 0, 0), \":\", lw=2, color=\"black\")\nplt.yscale(\"log\")\nplt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])\nplt.show()\n</pre> plt.plot(model.nodes.I, lw=4) N = model.nodes.S + model.nodes.I plt.plot(N - model.nodes.S, \"--\", lw=3) plt.plot(init_inf + np.insert(np.cumsum(model.nodes.newly_infected[:-1]), 0, 0), \":\", lw=2, color=\"black\") plt.yscale(\"log\") plt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"]) plt.show() <p>Introducing stochasticity into a model can have more effects on an individual model realization than just inducing noise around a mean trajectory - this simple model is a great example.  In the early stages of the outbreak, the infection count is low, and the timing of those first few infections dictates when the logistic growth really takes off.  This appears as a random time-shift in the entire outbreak trajectory.</p> <p>To illustrate this phenomenon, the below plot shows the model output, the expected logistic growth curve, and the expected logistic growth curve fit to the model with one free parameter -  an offset $t_0$.  The resulting plot should show good concordance between the model output and the expected logistic equation with the known model inputs $\\beta$ and population.</p> <p>The goodness of this fit will be turned into a strict pass/fail test down the line.</p> In\u00a0[4]: Copied! <pre>def SI_logistic(t, beta, size, t0):\n    return size / (1 + (size - 1) * np.exp(-beta * (t - t0)))\n\n\nplt.plot(model.nodes.I, lw=4)\n\nt = np.arange(model.params.nticks)\n\n\ndef objective(t0):\n    return np.sum((1 - SI_logistic(t, model.params.beta, pop, t0) / np.squeeze(model.nodes.I[1:])) ** 2)\n\n\nresult = minimize(objective, x0=10)\nt0_opt = result.x[0]\n\nplt.plot(t, SI_logistic(t, model.params.beta, pop, 0), \"--\", lw=2)\nplt.plot(t, SI_logistic(t, model.params.beta, pop, t0_opt), \"--\", lw=3, color=\"k\")\nplt.yscale(\"log\")\nplt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"])\nplt.show()\n</pre> def SI_logistic(t, beta, size, t0):     return size / (1 + (size - 1) * np.exp(-beta * (t - t0)))   plt.plot(model.nodes.I, lw=4)  t = np.arange(model.params.nticks)   def objective(t0):     return np.sum((1 - SI_logistic(t, model.params.beta, pop, t0) / np.squeeze(model.nodes.I[1:])) ** 2)   result = minimize(objective, x0=10) t0_opt = result.x[0]  plt.plot(t, SI_logistic(t, model.params.beta, pop, 0), \"--\", lw=2) plt.plot(t, SI_logistic(t, model.params.beta, pop, t0_opt), \"--\", lw=3, color=\"k\") plt.yscale(\"log\") plt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"]) plt.show() In\u00a0[5]: Copied! <pre>nticks = 730\nt = np.arange(730)\npop = 1e5\n\nseeds = list(range(10))\nbetas = [0.01 * i for i in range(2, 12)]\noutput = []\n\nscenario = grid(M=1,N=1, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude)\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\n\nfor seed, beta in zip(seeds, betas):\n    parameters = PropertySet({\"prng_seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta})\n    model = Model(scenario, parameters)\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.Transmission(model),\n    ]\n\n    model.run()\n    cases = [model.nodes.I[i][0] for i in range(nticks)]\n    popt, pcov = curve_fit(SI_logistic, t, cases, p0=[0.05, 1.1e5, 1])\n\n    output.append(\n        {\n            \"seed\": seed,\n            \"beta\": beta,\n            \"cases\": np.array(cases),\n            \"fitted_beta\": popt[0],\n            \"fitted_size\": popt[1],\n            \"fitted_t0\": popt[2],\n        }\n    )\n\noutput = pd.DataFrame(output)\n</pre> nticks = 730 t = np.arange(730) pop = 1e5  seeds = list(range(10)) betas = [0.01 * i for i in range(2, 12)] output = []  scenario = grid(M=1,N=1, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude) scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf  for seed, beta in zip(seeds, betas):     parameters = PropertySet({\"prng_seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta})     model = Model(scenario, parameters)     model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.Transmission(model),     ]      model.run()     cases = [model.nodes.I[i][0] for i in range(nticks)]     popt, pcov = curve_fit(SI_logistic, t, cases, p0=[0.05, 1.1e5, 1])      output.append(         {             \"seed\": seed,             \"beta\": beta,             \"cases\": np.array(cases),             \"fitted_beta\": popt[0],             \"fitted_size\": popt[1],             \"fitted_t0\": popt[2],         }     )  output = pd.DataFrame(output)  <pre>100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 5492.76it/s]\n100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 5926.73it/s]\n100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 6169.86it/s]\n100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 6510.84it/s]\n100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 6726.87it/s]\n100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 6703.57it/s]\n100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 6847.38it/s]\n100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 6253.11it/s]\n100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 6336.03it/s]\n100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 6652.82it/s]\n</pre> In\u00a0[6]: Copied! <pre>plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\")\nplt.xlabel(\"True beta\")\nplt.ylabel(\"Fitted beta\")\nplt.figure()\nplt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"], \"o\")\nplt.xlabel(\"True beta\")\nplt.ylabel(\"Relative error in fitted beta\")\n</pre> plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\") plt.xlabel(\"True beta\") plt.ylabel(\"Fitted beta\") plt.figure() plt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"], \"o\") plt.xlabel(\"True beta\") plt.ylabel(\"Relative error in fitted beta\") Out[6]: <pre>Text(0, 0.5, 'Relative error in fitted beta')</pre> In\u00a0[7]: Copied! <pre>print(\n    \"All fitted beta are within 5% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.05))\n)\n</pre> print(     \"All fitted beta are within 5% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.05)) ) <pre>All fitted beta are within 5% of known beta: True\n</pre>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#si-model-with-no-demographics","title":"SI model with no demographics\u00b6","text":"<p>We will begin with perhaps the simplest possible model of an infectious disease - the SI model without demography.  This model has two classes of individuals, the infective and the susceptible, and 1 parameter, $\\beta$, describing the per-timestep, per-infective person rate at which susceptibles transition to infectives.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} $$</p> <p>$$ \\dot{I} = \\frac{\\beta*S*I}{N} $$</p> <p>Noting that $S = N-I$, we can substitute $S$ in the second equation to get a standard form logistic equation</p> <p>$$ \\dot{I} = \\beta \\frac{(I-N)I}{N} = \\beta I (1 - \\frac{I}{N}) $$</p> <p>With solution $$ \\frac{N}{1+(\\frac{N}{I_0}-1)e^{-\\beta t}} $$</p> <p>To run the model in a discrete, constant time-step solver, the differential equation above is converted into a stochastic finite difference equation</p> <p>$$ \\Delta I = Bin(S_t, 1-exp^{-\\beta \\Delta t \\frac{I}{N}}) $$</p> <p>$$ S_{t+1} = S_t - \\Delta I $$</p> <p>$$ I_{t+1} = I_t + \\Delta I $$</p> <p>This notebook tests the implementation and behavior of the model as follows:</p>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#construct-the-model","title":"Construct the model\u00b6","text":"<p>In the first few cells, we import the <code>laser.generic.SI</code> model.  Then we construct a single-patch LASER model with two components: the Susceptible and Infected states, and the Transmission step in which Infecteds can infect Susceptibles. Finally, we initialize with a single infection and run.</p> <p>Note that LASER-generic has separate importable models for different generic model types (SI, SIS, SIR, SEIR, etc.).  Model code can be imported or copied over from one \"sub-package\" to another as desired, but maintaining this separation enables model-specific performance optimizations and cleaner code than requiring the components to \"know\" the global model configuration and change internal behvaior based on that (for example, whether agents in the <code>Infected</code> state need to cound down a timer or not; whether <code>Transmission</code> should send newly infected agents to the Infectious state as in the SI, SIS, SIR, or to an Exposed state as in an SEIR).</p>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test ensures certain basic constraints are being obeyed by the model.  We confirm that at each timestep, $S_t=N_t-I_t$.  We also confirm that $I_t = I_0 + \\sum_{t'=0}^t \\Delta I_{t'}$</p>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#scientific-test","title":"Scientific test\u00b6","text":"<p>Finally, we come to the scientific test.  We select a few values of $\\beta$, run the model, fit the outputs to the logistic equation, and compare the fitted value of $\\beta$ to the known value.  Because we are approximating continuously compounding growth, in the logistic equation, with a discrete time-step approximation, we expect the fitted values of $\\beta$ to be biased slightly downward - that is, the modeled trajectory is slightly slower than the continuous-time counterpart.  This error grows as $\\beta$ gets larger; the test fails if any of the fitted $\\beta$ values are more than 5% away from the known values.</p>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#constructing-the-model","title":"Constructing the model\u00b6","text":""},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#first-set-of-sanity-checks","title":"First set of sanity checks\u00b6","text":""},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#scientific-testing","title":"Scientific testing\u00b6","text":"<p>Finally, we run the model for a range of \u03b2  parameters, we freely fit the model output to the logistic equation, and we compare the known input parameters against the parameters fitted from output.</p> <p>Because we are approximating continuously compounding growth by discrete-time compounding growth, we should expect the fitted \u03b2  to consistently be slightly underestimated relative to the true \u03b2 , with the relative difference growing as \u03b2  gets larger.</p> <p>In the future, we could probably compute the expected error from this approximation.  But for now, to make this a pass-fail test, we will raise a flag if the fitted \u03b2 is more than 5% different than the known \u03b2.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/","title":"SI model with constant-population demographics","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import curve_fit\nfrom scipy.optimize import minimize\n\nimport laser.core\nimport laser.generic\n\nimport laser.generic.SI as SI\nfrom laser.generic import Model\nfrom laser.generic.utils import ValuesMap\nfrom laser.core.utils import grid\nfrom laser.generic.vitaldynamics import ConstantPopVitalDynamics\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.optimize import curve_fit from scipy.optimize import minimize  import laser.core import laser.generic  import laser.generic.SI as SI from laser.generic import Model from laser.generic.utils import ValuesMap from laser.core.utils import grid from laser.generic.vitaldynamics import ConstantPopVitalDynamics  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.2.6'\nlaser.core.__version__='0.8.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[\u00a0]: Copied! <pre>pop = 1e6\ninit_inf = 1\n# Just for fun, use coordinates of Seattle, WA\nlatitude = 47+(36+(35/60))/60\nlongitude = -(122+(19+(59/60))/60)\nscenario = grid(M=1, N=1, node_size_degs=0.08983, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude)\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\nparameters = PropertySet({\"prng_seed\": 314159265, \"nticks\": 730, \"verbose\": True, \"beta\": 0.04, \"cbr\": 40.0})\n# Question - if I provide a scalar birth rate, should the demographics steps know to convert that to a ratemap behind the scenes?\nbirthrates = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=1)\n\n# Run until we see an outbreak\noutbreak = False\n\nwhile not outbreak:\n    parameters.prng_seed += 1\n    model = Model(scenario, parameters, birthrates=ValuesMap.from_scalar(0.0, nticks=parameters.nticks, nnodes=1))\n\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        ConstantPopVitalDynamics(model, birthrates),\n        SI.Transmission(model),\n        ]\n\n    model.run()\n\n    outbreak = np.any(model.nodes.I[200] &gt; 0)\n</pre> pop = 1e6 init_inf = 1 # Just for fun, use coordinates of Seattle, WA latitude = 47+(36+(35/60))/60 longitude = -(122+(19+(59/60))/60) scenario = grid(M=1, N=1, node_size_degs=0.08983, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude) scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf parameters = PropertySet({\"prng_seed\": 314159265, \"nticks\": 730, \"verbose\": True, \"beta\": 0.04, \"cbr\": 40.0}) # Question - if I provide a scalar birth rate, should the demographics steps know to convert that to a ratemap behind the scenes? birthrates = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=1)  # Run until we see an outbreak outbreak = False  while not outbreak:     parameters.prng_seed += 1     model = Model(scenario, parameters, birthrates=ValuesMap.from_scalar(0.0, nticks=parameters.nticks, nnodes=1))      model.components = [         SI.Susceptible(model),         SI.Infectious(model),         ConstantPopVitalDynamics(model, birthrates),         SI.Transmission(model),         ]      model.run()      outbreak = np.any(model.nodes.I[200] &gt; 0) <pre>1,000,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 770.66it/s] \n</pre> In\u00a0[3]: Copied! <pre>plt.plot(model.nodes.I.astype(\"int\"), lw=4)\nN = model.nodes.S + model.nodes.I\nplt.plot(N - model.nodes.S, \"--\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])\n\nprint(\"S = N-I:  \" + str(np.isclose(model.nodes.S, N - model.nodes.I).all()))\n</pre> plt.plot(model.nodes.I.astype(\"int\"), lw=4) N = model.nodes.S + model.nodes.I plt.plot(N - model.nodes.S, \"--\", lw=3) plt.yscale(\"log\") plt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])  print(\"S = N-I:  \" + str(np.isclose(model.nodes.S, N - model.nodes.I).all())) <pre>S = N-I:  True\n</pre> <p>The below plot shows the model output, the expected logistic growth curve, and the expected logistic growth curve fit to the model with a free offset $t_0$ to account for stochasticity in when the outbreak takes off.  The resulting plot should show good concordance between the model output and the expected logistic equation with the known model inputs $\\beta$ and population. The goodness of this fit could be turned into a strict pass/fail test down the line.</p> In\u00a0[4]: Copied! <pre>def SI_logistic(t, beta, popsize, cbr, t0):\n    mu = (1 + cbr / 1000) ** (1 / 365) - 1\n    x = 1 - mu / beta\n    return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))\n\n\nt = np.arange(model.params.nticks)\n\n\ndef objective(t0):\n    return np.sum((1 - SI_logistic(t, model.params.beta, pop, model.params.cbr, t0) / np.squeeze(model.nodes.I[1:,:])) ** 2)\n\n\nresult = minimize(objective, x0=10)\nt0_opt = result.x[0]\n\nplt.plot(model.nodes.I, lw=4)\nplt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, 0), lw=3)\nplt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, t0_opt), \"r:\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"])\nplt.show()\n</pre> def SI_logistic(t, beta, popsize, cbr, t0):     mu = (1 + cbr / 1000) ** (1 / 365) - 1     x = 1 - mu / beta     return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))   t = np.arange(model.params.nticks)   def objective(t0):     return np.sum((1 - SI_logistic(t, model.params.beta, pop, model.params.cbr, t0) / np.squeeze(model.nodes.I[1:,:])) ** 2)   result = minimize(objective, x0=10) t0_opt = result.x[0]  plt.plot(model.nodes.I, lw=4) plt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, 0), lw=3) plt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, t0_opt), \"r:\", lw=3) plt.yscale(\"log\") plt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"]) plt.show() In\u00a0[\u00a0]: Copied! <pre>NTESTS = 10\nseeds = [42 + i for i in range(NTESTS)]\npop = 1e5\nnticks = 5 * 365\nbetas = [0.005 + 0.005 * i for i in range(1, NTESTS+1)]\ncbrs = np.random.randint(15, 50, NTESTS)\n\nscenario = grid(M=1, N=1, node_size_degs=0.08983, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude)\ninit_inf = 5\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\n\noutput = []\nfor i, (seed, beta, cbr) in enumerate(zip(seeds, betas, cbrs)):\n\n    parameters = PropertySet({\"prng_seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"cbr\": cbr})\n    recyclerates = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=1)\n    model = Model(scenario, parameters, birthrates=ValuesMap.from_scalar(0.0, nticks=parameters.nticks, nnodes=1))\n\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        ConstantPopVitalDynamics(model, recyclerates),\n        SI.Transmission(model),\n        ]\n    model.run(label=f\"SI Model {i+1:2} of {NTESTS} (beta={beta:0.05f}, cbr={cbr:3})\")\n    cases = model.nodes.I[:-1, 0]\n    popt, pcov = curve_fit(\n        SI_logistic,\n        np.arange(nticks),\n        cases,\n        p0=[beta * (1 + 0.1 * np.random.normal()), pop, cbr * (1 + 0.1 * np.random.normal()), 1],\n        bounds=([0, pop - 1, 0, -100], [1, pop + 1, 600, 100]),\n    )\n    # Pandas complains about concatenating rows to an empty DataFrame, so build a list of dicts and convert at the end\n    output.append({\n        \"seed\": seed,\n        \"beta\": beta,\n        \"cbr\": cbr,\n        \"cases\": np.array(cases),\n        \"fitted_beta\": popt[0],\n        \"fitted_size\": popt[1],\n        \"fitted_cbr\": popt[2],\n        \"fitted_t0\": popt[3],\n        \"births\": np.array(model.nodes.births[:-1, 0])\n    })\n\noutput = pd.DataFrame(output)\n</pre> NTESTS = 10 seeds = [42 + i for i in range(NTESTS)] pop = 1e5 nticks = 5 * 365 betas = [0.005 + 0.005 * i for i in range(1, NTESTS+1)] cbrs = np.random.randint(15, 50, NTESTS)  scenario = grid(M=1, N=1, node_size_degs=0.08983, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude) init_inf = 5 scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf  output = [] for i, (seed, beta, cbr) in enumerate(zip(seeds, betas, cbrs)):      parameters = PropertySet({\"prng_seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"cbr\": cbr})     recyclerates = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=1)     model = Model(scenario, parameters, birthrates=ValuesMap.from_scalar(0.0, nticks=parameters.nticks, nnodes=1))      model.components = [         SI.Susceptible(model),         SI.Infectious(model),         ConstantPopVitalDynamics(model, recyclerates),         SI.Transmission(model),         ]     model.run(label=f\"SI Model {i+1:2} of {NTESTS} (beta={beta:0.05f}, cbr={cbr:3})\")     cases = model.nodes.I[:-1, 0]     popt, pcov = curve_fit(         SI_logistic,         np.arange(nticks),         cases,         p0=[beta * (1 + 0.1 * np.random.normal()), pop, cbr * (1 + 0.1 * np.random.normal()), 1],         bounds=([0, pop - 1, 0, -100], [1, pop + 1, 600, 100]),     )     # Pandas complains about concatenating rows to an empty DataFrame, so build a list of dicts and convert at the end     output.append({         \"seed\": seed,         \"beta\": beta,         \"cbr\": cbr,         \"cases\": np.array(cases),         \"fitted_beta\": popt[0],         \"fitted_size\": popt[1],         \"fitted_cbr\": popt[2],         \"fitted_t0\": popt[3],         \"births\": np.array(model.nodes.births[:-1, 0])     })  output = pd.DataFrame(output)  <pre>SI Model  1 of 10 (beta=0.01000, cbr= 35): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1825/1825 [00:01&lt;00:00, 1794.48it/s]\nSI Model  2 of 10 (beta=0.01500, cbr= 39): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1825/1825 [00:00&lt;00:00, 2490.88it/s]\nSI Model  3 of 10 (beta=0.02000, cbr= 44): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1825/1825 [00:00&lt;00:00, 2423.67it/s]\nSI Model  4 of 10 (beta=0.02500, cbr= 36): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1825/1825 [00:00&lt;00:00, 2585.27it/s]\nSI Model  5 of 10 (beta=0.03000, cbr= 24): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1825/1825 [00:00&lt;00:00, 2550.20it/s]\nSI Model  6 of 10 (beta=0.03500, cbr= 20): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1825/1825 [00:00&lt;00:00, 2560.97it/s]\nSI Model  7 of 10 (beta=0.04000, cbr= 43): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1825/1825 [00:00&lt;00:00, 2466.55it/s]\nSI Model  8 of 10 (beta=0.04500, cbr= 43): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1825/1825 [00:00&lt;00:00, 2597.58it/s]\nSI Model  9 of 10 (beta=0.05000, cbr= 24): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1825/1825 [00:00&lt;00:00, 2605.91it/s]\nSI Model 10 of 10 (beta=0.05500, cbr= 30): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1825/1825 [00:00&lt;00:00, 2611.21it/s]\n</pre> In\u00a0[6]: Copied! <pre>plt.figure()\nplt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\")\nplt.xlim(0.00, 0.06)\nplt.ylim(0.00, 0.06)\nplt.figure()\nplt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"fitted_beta\"], \"o\")\nplt.xlim(0.00, 0.06)\nplt.ylim(-0.1, 0.10)\nplt.figure()\nplt.plot(output[\"cbr\"], output[\"fitted_cbr\"], \"o\")\nplt.xlim(15, 50)\nplt.ylim(15, 50)\nplt.figure()\nplt.plot(output[\"cbr\"], (output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"fitted_cbr\"], \"o\")\nplt.xlim(15, 50)\nplt.ylim(-0.2, 0.2)\n</pre> plt.figure() plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\") plt.xlim(0.00, 0.06) plt.ylim(0.00, 0.06) plt.figure() plt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"fitted_beta\"], \"o\") plt.xlim(0.00, 0.06) plt.ylim(-0.1, 0.10) plt.figure() plt.plot(output[\"cbr\"], output[\"fitted_cbr\"], \"o\") plt.xlim(15, 50) plt.ylim(15, 50) plt.figure() plt.plot(output[\"cbr\"], (output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"fitted_cbr\"], \"o\") plt.xlim(15, 50) plt.ylim(-0.2, 0.2) Out[6]: <pre>(-0.2, 0.2)</pre> In\u00a0[7]: Copied! <pre>print(\n    r\"All fitted beta are within 10% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.10))\n)\nprint(r\"All fitted CBR are within 10% of known CBR: \" + str(np.all(np.abs((output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"cbr\"]) &lt; 0.10)))\n</pre> print(     r\"All fitted beta are within 10% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.10)) ) print(r\"All fitted CBR are within 10% of known CBR: \" + str(np.all(np.abs((output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"cbr\"]) &lt; 0.10))) <pre>All fitted beta are within 10% of known beta: False\nAll fitted CBR are within 10% of known CBR: False\n</pre> In\u00a0[8]: Copied! <pre>output\n</pre> output Out[8]: seed beta cbr cases fitted_beta fitted_size fitted_cbr fitted_t0 births 0 42 0.010 35 [5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, ... 0.009940 99999.007591 34.565326 -70.529155 [10, 8, 11, 12, 13, 11, 8, 7, 13, 5, 9, 7, 7, ... 1 43 0.015 39 [5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, ... 0.014991 99999.626398 39.390367 -41.963303 [9, 9, 11, 15, 13, 13, 9, 8, 13, 6, 7, 6, 7, 6... 2 44 0.020 44 [5, 5, 5, 5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, ... 0.019905 99999.976583 44.884177 -55.130534 [11, 10, 14, 16, 16, 14, 11, 9, 17, 10, 7, 6, ... 3 45 0.025 36 [5, 5, 5, 5, 5, 5, 5, 7, 7, 8, 8, 8, 8, 8, 9, ... 0.024765 100000.951336 36.605541 -84.486835 [11, 6, 12, 10, 12, 9, 10, 9, 14, 6, 6, 5, 7, ... 4 46 0.030 24 [5, 5, 5, 5, 6, 6, 6, 8, 8, 9, 9, 9, 9, 9, 10,... 0.029834 100000.057103 23.669753 -50.351108 [8, 5, 10, 6, 9, 8, 5, 6, 8, 7, 4, 4, 3, 4, 7,... 5 47 0.035 20 [5, 5, 5, 5, 6, 6, 6, 8, 8, 9, 9, 9, 9, 9, 9, ... 0.034823 100000.253809 20.099099 -36.224436 [6, 4, 8, 6, 9, 8, 2, 4, 6, 6, 2, 5, 2, 4, 6, ... 6 48 0.040 43 [5, 5, 5, 5, 6, 6, 7, 9, 9, 10, 11, 11, 11, 12... 0.046975 99999.505145 49.318404 -3.509135 [12, 9, 13, 16, 16, 10, 7, 9, 15, 12, 7, 11, 8... 7 49 0.045 43 [5, 5, 5, 5, 6, 6, 7, 9, 9, 10, 11, 11, 11, 12... 0.044259 99999.153032 41.945374 -43.982684 [12, 9, 11, 14, 16, 10, 8, 10, 15, 12, 8, 13, ... 8 50 0.050 24 [5, 5, 5, 5, 6, 6, 7, 8, 8, 9, 10, 10, 10, 11,... 0.049637 100000.781621 23.789704 -34.963477 [8, 6, 8, 4, 13, 7, 5, 5, 6, 7, 5, 5, 4, 6, 9,... 9 51 0.055 30 [5, 5, 5, 5, 6, 6, 7, 8, 8, 9, 10, 10, 10, 11,... 0.054339 100000.691986 29.663588 -28.076344 [9, 9, 9, 7, 15, 8, 8, 5, 7, 6, 6, 7, 8, 6, 10... In\u00a0[9]: Copied! <pre>row = output.iloc[9]\ncases_row = row[\"cases\"]\nfitted_beta = row[\"fitted_beta\"]\nfitted_size = row[\"fitted_size\"]\nfitted_cbr = row[\"fitted_cbr\"]\nfitted_t0 = row[\"fitted_t0\"]\n\nplt.figure()\nplt.plot(cases_row, label=\"Case Trace\")\nplt.plot(SI_logistic(np.arange(nticks), fitted_beta, fitted_size, fitted_cbr, fitted_t0), label=\"Logistic Fit\", ls=\"--\")\nplt.legend()\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Cases\")\nplt.title(\"Case Trace and Logistic Fit for Row 0\")\n# plt.ylim(9.8e5, 1e6)\nplt.show()\n</pre> row = output.iloc[9] cases_row = row[\"cases\"] fitted_beta = row[\"fitted_beta\"] fitted_size = row[\"fitted_size\"] fitted_cbr = row[\"fitted_cbr\"] fitted_t0 = row[\"fitted_t0\"]  plt.figure() plt.plot(cases_row, label=\"Case Trace\") plt.plot(SI_logistic(np.arange(nticks), fitted_beta, fitted_size, fitted_cbr, fitted_t0), label=\"Logistic Fit\", ls=\"--\") plt.legend() plt.xlabel(\"Time (days)\") plt.ylabel(\"Cases\") plt.title(\"Case Trace and Logistic Fit for Row 0\") # plt.ylim(9.8e5, 1e6) plt.show() <p>Just an interesting note - because I kicked the simulations off with 3 infections rather than 1 (to ensure that the initial infection doesn't die before infecting someone), we consistently get a negative fit value for t0, and one that is a larger negative value for the lowest \u03b2 values.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#si-model-with-constant-population-demographics","title":"SI model with constant-population demographics\u00b6","text":"<p>Building up from the SI model without demography, we next explore the addition of basic demographics - adding a birth rate &amp; an equivalent, age-independent mortality rate $\\mu$ to keep constant total population.  The disease model remains the SI model.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\mu N - \\mu S $$</p> <p>$$ \\dot{I} = \\frac{\\beta*S*I}{N} - \\mu I $$</p> <p>With a bit of manipulation as in the previous example, this can be worked back into the form of a generalized logistic growth differential equation $$ \\dot{I} = \\beta I (1-\\frac{\\mu}{\\beta}-\\frac{I}{N})$$</p> <p>With solution $$ \\frac{Nx}{1+(\\frac{Nx}{I_0}-1)e^{-\\beta x t}} $$</p> <p>$$ x = (1-\\frac{\\mu}{\\beta}) $$</p> <p>This notebook tests the implementation and behavior of the model as follows:</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#construct-the-model","title":"Construct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Then we construct a single-patch LASER model with four components: the <code>Susceptible</code> and <code>Infected</code> states, and the <code>Transmission</code>, and <code>ConstantPopVitalDynamics</code> \"flows\" between states.  Finally, we initialize with a single infection and run.  The <code>Susceptible</code>, <code>Infected</code> and <code>Transmission</code> components are described in the the model with no births.  <code>ConstantPopVitalDynamics</code> enables births and deaths while strictly enforcing constant population rather than having separate stochastic birth and death processes that induce population variance over time.  To do this, births are implemented by randomly choosing an existing agent and re-initializing them as a newborn; in this way, each birth of a new agent is exactly offset by the death of an existing one.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test ensures certain basic constraints are being obeyed by the model.  We confirm that at each timestep, $S_t=N_t-I_t$.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#scientific-test","title":"Scientific test\u00b6","text":"<p>Finally, we come to the scientific test.  First, we run a basic test on a single model, and show the result matches expectation with known inputs.  Then, as before, we select a few values of \u03b2 and \u03bc, run the model, fit the outputs to the logistic equation, and compare the fitted values of the parameters to the known value.  The equation above makes it clear that attempting to fit \u03b2, \u03bc and N all together will be degenerate - the logistic equation has two parameters, not three; in this case those two are the products Nx and \u03b2x.  Thus, we fix the total population size N in the fit to focus on the more interesting \u03b2 and \u03bc parameters.  And as before, because we are approximating continuously compounding growth, in the logistic equation, with a discrete time-step approximation, we expect the fitted values of \u03b2 to be biased slightly downward - that is, the modeled trajectory is slightly slower than the continuous-time counterpart.  This error grows as \u03b2 gets larger; the test fails if any of the fitted \u03b2 values are more than 5% away from the known values.  Furthermore, if the outbreak is seeded by only one infection, it is possible that that one infection dies prior to infecting anyone else; we therefore seed with a few infections rather than one.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>Check that the relationships between susceptible, infected, and total population hold.  In the version with no births, we could also test that the infected = the sum of past incidence, but with births now playing a role that no longer holds.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#scientific-testing","title":"Scientific testing\u00b6","text":"<p>Finally, we run the model for a range of \u03b2 &amp; birth rate  parameters, we freely fit the model output to the logistic equation, and we compare the known input parameters against the parameters fitted from output.</p> <p>Because we are approximating continuously compounding growth by discrete-time compounding growth, we should expect the fitted \u03b2  to consistently be slightly underestimated relative to the true \u03b2 , with the relative difference growing as \u03b2  gets larger.</p> <p>In the future, we could probably compute the expected error from this approximation.  But for now, to make this a pass-fail test, we will raise a flag if the fitted parameters are more than 5% different than the known ones.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/","title":"SIS model with no demographics","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numba as nb\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import curve_fit\nfrom scipy.optimize import minimize\n\nimport laser.core\nimport laser.generic\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import matplotlib.pyplot as plt import numba as nb import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.optimize import curve_fit from scipy.optimize import minimize  import laser.core import laser.generic  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.5'\nlaser.core.__version__='0.8.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>import laser.core.distributions as dists\nimport laser.generic.SIS as SIS\nfrom laser.generic import Model\nfrom laser.core.utils import grid\n</pre> import laser.core.distributions as dists import laser.generic.SIS as SIS from laser.generic import Model from laser.core.utils import grid <p>To make sure we don't accumulate lots of finite time-step error, make inf mean quite long in units of timestep</p> In\u00a0[3]: Copied! <pre>pop = 3e5\n\nscenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 1\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\nparameters = PropertySet({\"prng_seed\": 42, \"nticks\": 3000, \"beta\": 0.1, \"inf_mean\": 32})\n\ninfdurdist = dists.exponential(scale=parameters.inf_mean)\n</pre> pop = 3e5  scenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 1 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected parameters = PropertySet({\"prng_seed\": 42, \"nticks\": 3000, \"beta\": 0.1, \"inf_mean\": 32})  infdurdist = dists.exponential(scale=parameters.inf_mean)  In\u00a0[4]: Copied! <pre># Run until we get an outbreak\noutbreak = False\nwhile not outbreak:\n    parameters.prng_seed += 1\n    model = Model(scenario, parameters)\n\n    model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]\n\n    model.run()\n    outbreak = np.any(model.nodes.I[200] &gt; 0)\n</pre> # Run until we get an outbreak outbreak = False while not outbreak:     parameters.prng_seed += 1     model = Model(scenario, parameters)      model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]      model.run()     outbreak = np.any(model.nodes.I[200] &gt; 0)  <pre>300,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1976.46it/s]\n300,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1950.55it/s]\n</pre> In\u00a0[5]: Copied! <pre>fig, axs = plt.subplots(1, 2, figsize=(18, 5))\n\n# Panel 2: Susceptible over time\naxs[0].plot(model.nodes.S[1:], lw=4)\naxs[0].plot(model.nodes.S[:-1] + model.nodes.newly_recovered[:-1] - model.nodes.newly_infected[:-1])\naxs[0].set_yscale(\"log\")\naxs[0].set_title(\"Susceptible over time\")\naxs[0].set_xlabel(\"Time\")\naxs[0].set_ylabel(\"Susceptible\")\n\n# Panel 3: Population minus cumulative infections (incidence)\naxs[1].plot(model.nodes.I[1:], lw=4)\naxs[1].plot(model.nodes.I[:-1] - model.nodes.newly_recovered[:-1] + model.nodes.newly_infected[:-1])\naxs[1].set_yscale(\"log\")\naxs[1].set_title(\"Population minus cumulative infections\")\naxs[1].set_xlabel(\"Time\")\naxs[1].set_ylabel(\"Incidence\")\n\nplt.tight_layout()\n\nprint(\"S[t] = S[t-1] + recovered[t-1] - incidence[t-1]: \", np.allclose(model.nodes.S[1:], model.nodes.S[:-1] + model.nodes.newly_recovered[:-1] - model.nodes.newly_infected[:-1]))\nprint(\"I[t] = I[t-1] - recovered[t-1] + incidence[t-1]: \", np.allclose(model.nodes.I[1:], model.nodes.I[:-1] - model.nodes.newly_recovered[:-1] + model.nodes.newly_infected[:-1]))\n</pre> fig, axs = plt.subplots(1, 2, figsize=(18, 5))  # Panel 2: Susceptible over time axs[0].plot(model.nodes.S[1:], lw=4) axs[0].plot(model.nodes.S[:-1] + model.nodes.newly_recovered[:-1] - model.nodes.newly_infected[:-1]) axs[0].set_yscale(\"log\") axs[0].set_title(\"Susceptible over time\") axs[0].set_xlabel(\"Time\") axs[0].set_ylabel(\"Susceptible\")  # Panel 3: Population minus cumulative infections (incidence) axs[1].plot(model.nodes.I[1:], lw=4) axs[1].plot(model.nodes.I[:-1] - model.nodes.newly_recovered[:-1] + model.nodes.newly_infected[:-1]) axs[1].set_yscale(\"log\") axs[1].set_title(\"Population minus cumulative infections\") axs[1].set_xlabel(\"Time\") axs[1].set_ylabel(\"Incidence\")  plt.tight_layout()  print(\"S[t] = S[t-1] + recovered[t-1] - incidence[t-1]: \", np.allclose(model.nodes.S[1:], model.nodes.S[:-1] + model.nodes.newly_recovered[:-1] - model.nodes.newly_infected[:-1])) print(\"I[t] = I[t-1] - recovered[t-1] + incidence[t-1]: \", np.allclose(model.nodes.I[1:], model.nodes.I[:-1] - model.nodes.newly_recovered[:-1] + model.nodes.newly_infected[:-1]))  <pre>S[t] = S[t-1] + recovered[t-1] - incidence[t-1]:  True\nI[t] = I[t-1] - recovered[t-1] + incidence[t-1]:  True\n</pre> In\u00a0[6]: Copied! <pre>def SIS_logistic(t, beta, popsize, gamma, t0):\n    x = 1 - gamma / beta\n    return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))\n\n\nt = np.arange(model.params.nticks+1)\n\n\ndef objective(t0):\n    return np.sum(\n        (1 - SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0) / np.squeeze(model.nodes.I)) ** 2\n    )\n\n\nresult = minimize(objective, x0=10)\nt0_opt = result.x[0]\n\nplt.plot(model.nodes.I, lw=4)\nplt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, 0), lw=3)\nplt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0_opt), \"r:\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"])\n</pre> def SIS_logistic(t, beta, popsize, gamma, t0):     x = 1 - gamma / beta     return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))   t = np.arange(model.params.nticks+1)   def objective(t0):     return np.sum(         (1 - SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0) / np.squeeze(model.nodes.I)) ** 2     )   result = minimize(objective, x0=10) t0_opt = result.x[0]  plt.plot(model.nodes.I, lw=4) plt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, 0), lw=3) plt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0_opt), \"r:\", lw=3) plt.yscale(\"log\") plt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"]) Out[6]: <pre>&lt;matplotlib.legend.Legend at 0x124a66360&gt;</pre> In\u00a0[7]: Copied! <pre>NTESTS = 10\nnticks = 730\nt = np.arange(nticks)\nbetarange = [0.02, 0.1]\ngammarange = [1 / 300, 1 / 100]\nseeds = list(range(NTESTS))\npop = 1e5\nbetas = np.random.uniform(betarange[0], betarange[1], NTESTS)\ngammas = np.random.uniform(gammarange[0], gammarange[1], NTESTS)\nscenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 3\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\n\noutput = []\nfor i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):\n    parameters = PropertySet({\"prng_seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})\n\n    model = Model(scenario, parameters)\n\n    infdurdist = dists.exponential(scale=parameters.inf_mean)\n\n    model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]\n\n    model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed}, beta={beta:.3f}, gamma={gamma:.5f}\")\n    cases = model.nodes.I[1:,0]\n    popt, pcov = curve_fit(\n        SIS_logistic,\n        t,\n        cases,\n        p0=[np.mean(betarange), pop, np.mean(gammarange), 1],\n        bounds=([betarange[0] / 2, pop - 1, gammarange[0] / 2, -300], [betarange[1] * 2, pop + 1, gammarange[1] * 2, 300]),\n    )\n\n    output.append(\n        {\n            \"seed\": seed,\n            \"beta\": beta,\n            \"gamma\": gamma,\n            \"cases\": [np.array(cases)],\n            \"fitted_beta\": popt[0],\n            \"fitted_gamma\": popt[2],\n            \"fitted_t0\": popt[3],\n            \"recovered\": [np.array(model.nodes.newly_recovered[1:,0])]\n        }\n    )\n\noutput = pd.DataFrame(output)\n</pre> NTESTS = 10 nticks = 730 t = np.arange(nticks) betarange = [0.02, 0.1] gammarange = [1 / 300, 1 / 100] seeds = list(range(NTESTS)) pop = 1e5 betas = np.random.uniform(betarange[0], betarange[1], NTESTS) gammas = np.random.uniform(gammarange[0], gammarange[1], NTESTS) scenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 3 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected  output = [] for i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):     parameters = PropertySet({\"prng_seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})      model = Model(scenario, parameters)      infdurdist = dists.exponential(scale=parameters.inf_mean)      model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]      model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed}, beta={beta:.3f}, gamma={gamma:.5f}\")     cases = model.nodes.I[1:,0]     popt, pcov = curve_fit(         SIS_logistic,         t,         cases,         p0=[np.mean(betarange), pop, np.mean(gammarange), 1],         bounds=([betarange[0] / 2, pop - 1, gammarange[0] / 2, -300], [betarange[1] * 2, pop + 1, gammarange[1] * 2, 300]),     )      output.append(         {             \"seed\": seed,             \"beta\": beta,             \"gamma\": gamma,             \"cases\": [np.array(cases)],             \"fitted_beta\": popt[0],             \"fitted_gamma\": popt[2],             \"fitted_t0\": popt[3],             \"recovered\": [np.array(model.nodes.newly_recovered[1:,0])]         }     )  output = pd.DataFrame(output)  <pre>SIS  1 of 10, seed=0, beta=0.030, gamma=0.00478: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1600.42it/s]\nSIS  2 of 10, seed=1, beta=0.066, gamma=0.00870: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1832.14it/s]\nSIS  3 of 10, seed=2, beta=0.089, gamma=0.00488: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1870.13it/s]\nSIS  4 of 10, seed=3, beta=0.068, gamma=0.00471: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1859.55it/s]\nSIS  5 of 10, seed=4, beta=0.064, gamma=0.00768: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1555.22it/s]\nSIS  6 of 10, seed=5, beta=0.050, gamma=0.00816: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1819.16it/s]\nSIS  7 of 10, seed=6, beta=0.100, gamma=0.00864: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1840.22it/s]\nSIS  8 of 10, seed=7, beta=0.081, gamma=0.00601: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1833.60it/s]\nSIS  9 of 10, seed=8, beta=0.086, gamma=0.00476: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1865.35it/s]\nSIS 10 of 10, seed=9, beta=0.080, gamma=0.00903: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1862.75it/s]\n</pre> In\u00a0[8]: Copied! <pre>plt.figure()\nplt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\")\nplt.xlim(betarange[0], betarange[1])\nplt.ylim(betarange[0], betarange[1])\nplt.figure()\nplt.plot(output[\"beta\"], 1 - output[\"beta\"] / output[\"fitted_beta\"], \"o\")\nplt.xlim(betarange[0], betarange[1])\nplt.ylim(-0.25, 0.25)\nplt.figure()\nplt.plot(output[\"gamma\"], output[\"fitted_gamma\"], \"o\")\nplt.xlim(gammarange[0]*0.9, gammarange[1]*1.1)\nplt.ylim(gammarange[0]*0.9, gammarange[1]*1.1)\nplt.figure()\nplt.plot(output[\"gamma\"], 1 - output[\"gamma\"] / output[\"fitted_gamma\"], \"o\")\nplt.xlim(gammarange[0]*0.9, gammarange[1]*1.1)\nplt.ylim(-0.25, 0.25)\n</pre> plt.figure() plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\") plt.xlim(betarange[0], betarange[1]) plt.ylim(betarange[0], betarange[1]) plt.figure() plt.plot(output[\"beta\"], 1 - output[\"beta\"] / output[\"fitted_beta\"], \"o\") plt.xlim(betarange[0], betarange[1]) plt.ylim(-0.25, 0.25) plt.figure() plt.plot(output[\"gamma\"], output[\"fitted_gamma\"], \"o\") plt.xlim(gammarange[0]*0.9, gammarange[1]*1.1) plt.ylim(gammarange[0]*0.9, gammarange[1]*1.1) plt.figure() plt.plot(output[\"gamma\"], 1 - output[\"gamma\"] / output[\"fitted_gamma\"], \"o\") plt.xlim(gammarange[0]*0.9, gammarange[1]*1.1) plt.ylim(-0.25, 0.25) Out[8]: <pre>(-0.25, 0.25)</pre> In\u00a0[9]: Copied! <pre>print(\n    \"All fitted beta are within 10% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.10))\n)\nprint(\n    \"All fitted gamma are within 20% of known gamma: \"\n    + str(np.all(np.abs((output[\"gamma\"] - output[\"fitted_gamma\"]) / output[\"gamma\"]) &lt; 0.20))\n)\n</pre> print(     \"All fitted beta are within 10% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.10)) ) print(     \"All fitted gamma are within 20% of known gamma: \"     + str(np.all(np.abs((output[\"gamma\"] - output[\"fitted_gamma\"]) / output[\"gamma\"]) &lt; 0.20)) ) <pre>All fitted beta are within 10% of known beta: True\nAll fitted gamma are within 20% of known gamma: True\n</pre> In\u00a0[10]: Copied! <pre>output\n</pre> output Out[10]: seed beta gamma cases fitted_beta fitted_gamma fitted_t0 recovered 0 0 0.029660 0.004783 [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 5, 5, 5, 5,... 0.029353 0.004690 -28.519006 [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,... 1 1 0.066200 0.008704 [[4, 4, 4, 4, 5, 6, 7, 8, 8, 9, 10, 12, 12, 12... 0.064577 0.008226 -30.855025 [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,... 2 2 0.088750 0.004881 [[4, 4, 4, 6, 7, 9, 10, 10, 10, 12, 16, 19, 19... 0.086452 0.004554 -24.615804 [[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,... 3 3 0.067663 0.004713 [[4, 4, 4, 4, 5, 6, 7, 8, 8, 9, 10, 12, 12, 12... 0.065749 0.004419 -27.636157 [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,... 4 4 0.063574 0.007682 [[4, 4, 4, 4, 5, 6, 7, 8, 9, 10, 12, 14, 14, 1... 0.061765 0.007219 -38.782883 [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,... 5 5 0.049859 0.008158 [[3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 4, 6, 6, 6, 6,... 0.048996 0.007822 -38.706199 [[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,... 6 6 0.099783 0.008644 [[4, 4, 4, 6, 7, 7, 8, 8, 8, 10, 13, 15, 15, 1... 0.097077 0.008029 -18.788862 [[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,... 7 7 0.080933 0.006014 [[3, 3, 3, 3, 4, 4, 5, 6, 7, 8, 10, 11, 10, 10... 0.079083 0.005661 -18.898113 [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,... 8 8 0.086307 0.004760 [[4, 3, 3, 3, 4, 4, 5, 6, 7, 8, 9, 9, 10, 10, ... 0.084231 0.004460 -13.418348 [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,... 9 9 0.080437 0.009030 [[3, 3, 3, 3, 4, 4, 5, 6, 7, 8, 9, 9, 10, 10, ... 0.078341 0.008463 -13.544913 [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,... In\u00a0[11]: Copied! <pre># %%capture\n\ngammas = [1 / infmean for infmean in [1, 1.5, 2, 2.5, 3, 6, 12, 18, 30, 45, 60, 90, 120, 180, 240, 300]]\nbetas = [3 * gamma for gamma in gammas]\n\nNTESTS = len(gammas)\nnticks = 3000\nseeds = list(range(NTESTS))\npop = 1e5\nfinal_expected = np.array([])\nfinal_observed = np.array([])\nscenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 20\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\n\nfor i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):\n    parameters = PropertySet({\"prng_seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})\n\n    model = Model(scenario, parameters)\n\n    infdurdist = dists.exponential(scale=parameters.inf_mean)\n\n    model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]\n\n    model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed:2}, beta={beta:.3f}, gamma={gamma:.5f}\")\n    final_observed = np.append(final_observed, model.nodes.I[-1,0])\n    final_expected = np.append(final_expected, pop * (1 - gamma / beta))\n</pre> # %%capture  gammas = [1 / infmean for infmean in [1, 1.5, 2, 2.5, 3, 6, 12, 18, 30, 45, 60, 90, 120, 180, 240, 300]] betas = [3 * gamma for gamma in gammas]  NTESTS = len(gammas) nticks = 3000 seeds = list(range(NTESTS)) pop = 1e5 final_expected = np.array([]) final_observed = np.array([]) scenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 20 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected  for i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):     parameters = PropertySet({\"prng_seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})      model = Model(scenario, parameters)      infdurdist = dists.exponential(scale=parameters.inf_mean)      model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]      model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed:2}, beta={beta:.3f}, gamma={gamma:.5f}\")     final_observed = np.append(final_observed, model.nodes.I[-1,0])     final_expected = np.append(final_expected, pop * (1 - gamma / beta)) <pre>SIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1816.37it/s]\nSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1822.22it/s]\nSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1791.96it/s]\nSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1783.50it/s]\nSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1914.60it/s]\nSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2145.71it/s]\nSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2372.33it/s]\nSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2414.61it/s]\nSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2282.53it/s]\nSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2495.26it/s]\nSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2527.17it/s]\nSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2563.65it/s]\nSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2569.93it/s]\nSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2420.63it/s]\nSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2557.22it/s]\nSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 2612.99it/s]\n</pre> In\u00a0[\u00a0]: Copied! <pre>plt.plot(gammas, np.abs(1 - final_observed / final_expected), \"o\")\nplt.xlabel(r\"$\\gamma$\")\nplt.ylabel(\"$| 1 - \\\\frac{I(\\\\infty)_{obs}}{I(\\\\infty)_{exp}} |$\")\nplt.title(r\"Error in equilibrium infected fraction increases roughly linearly in $\\gamma \\Delta t$\")\nplt.show()\n</pre> plt.plot(gammas, np.abs(1 - final_observed / final_expected), \"o\") plt.xlabel(r\"$\\gamma$\") plt.ylabel(\"$| 1 - \\\\frac{I(\\\\infty)_{obs}}{I(\\\\infty)_{exp}} |$\") plt.title(r\"Error in equilibrium infected fraction increases roughly linearly in $\\gamma \\Delta t$\") plt.show() Out[\u00a0]: <pre>Text(0.5, 1.0, 'Error in equilibrium infected fraction increases roughly linearly in $\\\\gamma \\\\Delta t$')</pre> In\u00a0[13]: Copied! <pre># Validate for each row that mean(recovered / cases) is close to gamma\nfor idx, row in output.iterrows():\n    cases_arr = np.array(row[\"cases\"][0])\n    recovered_arr = np.array(row[\"recovered\"][0])\n    # Avoid division by zero\n    valid = cases_arr &gt; 0\n    avg_ratio = np.mean(recovered_arr[valid] / cases_arr[valid])\n    print(f\"Row {idx}: gamma={row['gamma']:.6f}, avg(recovered/cases)={avg_ratio:.6f}, diff={abs(avg_ratio - row['gamma']):.6f}\")\n</pre> # Validate for each row that mean(recovered / cases) is close to gamma for idx, row in output.iterrows():     cases_arr = np.array(row[\"cases\"][0])     recovered_arr = np.array(row[\"recovered\"][0])     # Avoid division by zero     valid = cases_arr &gt; 0     avg_ratio = np.mean(recovered_arr[valid] / cases_arr[valid])     print(f\"Row {idx}: gamma={row['gamma']:.6f}, avg(recovered/cases)={avg_ratio:.6f}, diff={abs(avg_ratio - row['gamma']):.6f}\")  <pre>Row 0: gamma=0.004783, avg(recovered/cases)=0.004250, diff=0.000533\nRow 1: gamma=0.008704, avg(recovered/cases)=0.008376, diff=0.000329\nRow 2: gamma=0.004881, avg(recovered/cases)=0.004815, diff=0.000065\nRow 3: gamma=0.004713, avg(recovered/cases)=0.004469, diff=0.000245\nRow 4: gamma=0.007682, avg(recovered/cases)=0.007357, diff=0.000325\nRow 5: gamma=0.008158, avg(recovered/cases)=0.008077, diff=0.000081\nRow 6: gamma=0.008644, avg(recovered/cases)=0.008481, diff=0.000163\nRow 7: gamma=0.006014, avg(recovered/cases)=0.005878, diff=0.000136\nRow 8: gamma=0.004760, avg(recovered/cases)=0.004952, diff=0.000192\nRow 9: gamma=0.009030, avg(recovered/cases)=0.008840, diff=0.000190\n</pre>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#sis-model-with-no-demographics","title":"SIS model with no demographics\u00b6","text":"<p>Moving on from the SI model to something slighlty more complex, we will add a state transition from infected back to susceptible, with no period of immunity - this is the SIS model.  It turns out that the equations governing this will be analogous to the SI model with demography - rather than births &amp; mortality providing routes to add susceptibles and subtract infectives, this transition from infective -&gt; susceptible will provide essentially the same mechanism.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\gamma I $$</p> <p>$$ \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I $$</p> <p>As before, subbing $S = N-I$ into the second equation gives us</p> <p>$$ \\dot{I} = \\beta I ( 1-\\frac{\\gamma}{\\beta}-\\frac{I}{N})$$</p> <p>And comparing against the SI model with births, it is clear this equation is of the same form, with solution $$ \\frac{Nx}{1+(\\frac{Nx}{I_0}-1)e^{-\\beta x t}} $$</p> <p>$$ x = (1-\\frac{\\gamma}{\\beta}) $$</p> <p>This notebook tests the implementation and behavior of the model as follows:</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#construct-the-model","title":"Construct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Then we construct a single-patch LASER model with three components: <code>Susceptibility</code>, <code>Transmission</code>, and <code>Infection_SIS</code> - this component will require a new agent property <code>itimer</code>, and upon expiration of <code>itimer</code> agents will return to the susceptible state.  Finally, we initialize with a single infection and run.  The <code>Susceptibility</code> and <code>Transmission</code> components are previously described.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test ensures certain basic constraints are being obeyed by the model.  We confirm that at each timestep, $S_t=N_t-I_t$.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#scientific-test","title":"Scientific test\u00b6","text":"<p>Finally, we come to the scientific test.  As before, we first test on a single instance of the model and show that the expected output is recovered.  Then, we select a few values of $\\beta$ and $\\gamma$, run the model, fit the outputs to the logistic equation, and compare the fitted value of $\\beta$ and $\\gamma$ to the known values; all of the considerations noted in the SI with births model, in terms of how to approach this fit, are echoed again here.  Of particular concern is the approximation of an exponential transition from infected back to susceptible - as we are doing a first-order finite timestep integration here, that approximation will probably produce an error linear in $\\gamma \\Delta t$ between the analytic result and the modeled result.  In fact, in a lot of real disease models, we have compartment dwell times in the exposed and infective states that are only a handful of $\\Delta t$ long, but when doing real epi modeling and calibrating model parameters to uncertain data, this is generally not likely to be a dominant source of bias, uncertainty, etc.  But when comparing specifically against an analytic result, it can become significant.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>Check that the relationships between susceptible, infected, and total population hold.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#single-simulation-check","title":"Single-simulation check\u00b6","text":"<p>As before, starting with a single infection induces some stochasticity in terms of when the outbreak really starts to take off, and so we fit the expected behavior with a free offset parameter below.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#scientific-testing","title":"Scientific testing\u00b6","text":"<p>Finally, we run the model for a range of $\\beta$ &amp; $\\gamma$  parameters, we freely fit the model output to the logistic equation, and we compare the known input parameters against the parameters fitted from output.</p> <p>We will use only relatively large values of $\\gamma$ for this procedure.  The reason why will become clear in a second test, where we demonstrate that there is an error between the expected final size and the modeled final size, and that this error shrinks with $\\gamma \\Delta t$, as we would expect a first-order approximation error to.</p> <p>To make this a pass-fail test, we will raise a flag if the fitted parameters are more than 5% different than the known ones.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#quick-demonstration-of-first-order-error-accumulation","title":"Quick demonstration of first-order error accumulation\u00b6","text":"<p>As noted before, for $\\gamma \\Delta t$ large, first-order integration like we are doing here can accumulate substantial error.  Calculating exactly how error will accumulate in an integrator for a dynamic process like this is beyond the scope here, and probably depends on a lot of details.  E.g., the ordering of steps - in a given step, does the <code>transmission</code> update from S-&gt;I state occur before or after the <code>infection</code> update that sends agents from I-&gt;S?  Do we use midpoint methods, timer countdowns, or take advantage of the unique memorylessness of the exponential distribution to simply remove a random fraction each time?  All that is beyond scope here, but just want to demonstrate that the error in the equilibrium value $I(t \\rightarrow \\infty)$ becomes large when the mean infectious period $\\frac{1}{\\gamma}$ is on the same order as $\\Delta t$</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/","title":"Outbreak size in the SIR model (Kermack-McKendrick relation)","text":"In\u00a0[1]: Copied! <pre>import itertools\n\nimport matplotlib.pyplot as plt\nimport numba as nb\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import fsolve\nfrom scipy.special import lambertw\n\nimport laser.core\nimport laser.generic\nimport laser.core.distributions as dists\nfrom laser.generic import SIR\nfrom laser.generic import Model\nfrom laser.generic.utils import ValuesMap\nfrom laser.core.utils import grid\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import itertools  import matplotlib.pyplot as plt import numba as nb import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.optimize import fsolve from scipy.special import lambertw  import laser.core import laser.generic import laser.core.distributions as dists from laser.generic import SIR from laser.generic import Model from laser.generic.utils import ValuesMap from laser.core.utils import grid  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.2.6'\nlaser.core.__version__='0.9.1'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>def create_single_node_model(population: int, init_inf: int = 0, init_rec: int = 0, parameters: PropertySet = None) -&gt; Model:\n\n    scenario = grid(M=1, N=1, population_fn=lambda x,y: population, origin_x=0, origin_y=0)\n    scenario[\"S\"] = scenario.population - (init_inf + init_rec)\n    assert np.all(scenario[\"S\"] &gt;= 0), \"Initial susceptible population cannot be negative.\"\n    scenario[\"I\"] = init_inf\n    scenario[\"R\"] = init_rec\n\n    params = parameters or PropertySet({\"prng_seed\": 20251017, \"nticks\": 365, \"beta\": 4.0/3.0, \"inf_mean\": 7.0, \"cbr\": 0.0, \"cdr\": 0.0})\n    for key in [\"beta\", \"inf_mean\"]:\n        assert key in params, f\"Parameter '{key}' must be specified.\"\n\n    model = Model(scenario, params)\n\n    infdurdist = dists.exponential(scale=params.inf_mean)\n\n    model.components = [SIR.Susceptible(model), SIR.Recovered(model), SIR.Infectious(model, infdurdist), SIR.Transmission(model, infdurdist)]\n\n    return model\n</pre> def create_single_node_model(population: int, init_inf: int = 0, init_rec: int = 0, parameters: PropertySet = None) -&gt; Model:      scenario = grid(M=1, N=1, population_fn=lambda x,y: population, origin_x=0, origin_y=0)     scenario[\"S\"] = scenario.population - (init_inf + init_rec)     assert np.all(scenario[\"S\"] &gt;= 0), \"Initial susceptible population cannot be negative.\"     scenario[\"I\"] = init_inf     scenario[\"R\"] = init_rec      params = parameters or PropertySet({\"prng_seed\": 20251017, \"nticks\": 365, \"beta\": 4.0/3.0, \"inf_mean\": 7.0, \"cbr\": 0.0, \"cdr\": 0.0})     for key in [\"beta\", \"inf_mean\"]:         assert key in params, f\"Parameter '{key}' must be specified.\"      model = Model(scenario, params)      infdurdist = dists.exponential(scale=params.inf_mean)      model.components = [SIR.Susceptible(model), SIR.Recovered(model), SIR.Infectious(model, infdurdist), SIR.Transmission(model, infdurdist)]      return model In\u00a0[3]: Copied! <pre>pop = 1e5\ninitial_infected = 3\n# R0 = beta * inf_mean = 0.2 * 15 = 3.0 - expected attack fraction is just under 80%\nparameters = PropertySet({\"prng_seed\": 2, \"nticks\": 730, \"verbose\": True, \"beta\": 0.2, \"inf_mean\": 15})\n\n# Run simulations until we get an outbreak\noutbreak = False\nwhile not outbreak:\n\n    parameters.prng_seed += 1\n    model = create_single_node_model(\n        population=pop,\n        init_inf=initial_infected,\n        init_rec=0,\n        parameters=parameters,\n    )\n\n    model.run()\n    outbreak = np.any(model.nodes.R[200] &gt;= 10)\n\nplt.plot(model.nodes.I)\nplt.show()\n</pre> pop = 1e5 initial_infected = 3 # R0 = beta * inf_mean = 0.2 * 15 = 3.0 - expected attack fraction is just under 80% parameters = PropertySet({\"prng_seed\": 2, \"nticks\": 730, \"verbose\": True, \"beta\": 0.2, \"inf_mean\": 15})  # Run simulations until we get an outbreak outbreak = False while not outbreak:      parameters.prng_seed += 1     model = create_single_node_model(         population=pop,         init_inf=initial_infected,         init_rec=0,         parameters=parameters,     )      model.run()     outbreak = np.any(model.nodes.R[200] &gt;= 10)  plt.plot(model.nodes.I) plt.show() <pre>100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1333.86it/s]\n</pre> In\u00a0[4]: Copied! <pre># Estimate the outbreak size (attack fraction) using the final size equation\nR0 = parameters.beta * parameters.inf_mean\nS0 = (pop - initial_infected) / pop\nS_inf = -1 / R0 * lambertw(-R0 * S0 * np.exp(-R0)).real\nA = 1 - S_inf  # Attack fraction\nfinal_R = A * pop + initial_infected\n\nplt.plot(model.nodes.S, color=\"blue\")\nplt.plot(model.nodes.I, color=\"red\")\nplt.plot(model.nodes.R, color=\"green\")\nplt.plot(model.nodes.newly_recovered, color=\"orange\", linestyle=\"dashed\")\nplt.axhline(final_R, color=\"darkgray\", linestyle=\"dashed\")\nplt.legend([\"S\", \"I\", \"R\", \"recoveries\", \"Est. R(\u221e)\"])\nplt.xlabel(\"Days\")\nplt.ylabel(\"Number of People\")\nplt.title(\"SIR Model with No Births or Deaths\")\nplt.show()\n</pre> # Estimate the outbreak size (attack fraction) using the final size equation R0 = parameters.beta * parameters.inf_mean S0 = (pop - initial_infected) / pop S_inf = -1 / R0 * lambertw(-R0 * S0 * np.exp(-R0)).real A = 1 - S_inf  # Attack fraction final_R = A * pop + initial_infected  plt.plot(model.nodes.S, color=\"blue\") plt.plot(model.nodes.I, color=\"red\") plt.plot(model.nodes.R, color=\"green\") plt.plot(model.nodes.newly_recovered, color=\"orange\", linestyle=\"dashed\") plt.axhline(final_R, color=\"darkgray\", linestyle=\"dashed\") plt.legend([\"S\", \"I\", \"R\", \"recoveries\", \"Est. R(\u221e)\"]) plt.xlabel(\"Days\") plt.ylabel(\"Number of People\") plt.title(\"SIR Model with No Births or Deaths\") plt.show()  In\u00a0[5]: Copied! <pre>print(\"S+I+R = N:  \" + str(np.isclose(model.nodes.S + model.nodes.I + model.nodes.R, pop).all()))\nprint(\"S = N - sum(deltaI): \" + str(np.isclose(pop - np.squeeze(model.nodes.S)[1:], initial_infected+np.cumsum(model.nodes.newly_infected)[:-1]).all()))  # Account for 1 timestep offset here\nprint(\"R = sum(deltaR): \" + str(np.isclose(np.squeeze(model.nodes.R)[1:], np.cumsum(model.nodes.newly_recovered)[:-1]).all()))  # Account for 1 timestep offset here\n</pre> print(\"S+I+R = N:  \" + str(np.isclose(model.nodes.S + model.nodes.I + model.nodes.R, pop).all())) print(\"S = N - sum(deltaI): \" + str(np.isclose(pop - np.squeeze(model.nodes.S)[1:], initial_infected+np.cumsum(model.nodes.newly_infected)[:-1]).all()))  # Account for 1 timestep offset here print(\"R = sum(deltaR): \" + str(np.isclose(np.squeeze(model.nodes.R)[1:], np.cumsum(model.nodes.newly_recovered)[:-1]).all()))  # Account for 1 timestep offset here <pre>S+I+R = N:  True\nS = N - sum(deltaI): True\nR = sum(deltaR): True\n</pre> In\u00a0[6]: Copied! <pre>def KM_limit(z, R0, S0, I0):\n    if R0 * S0 &lt; 1:\n        return 0\n    else:\n        return z - S0 * (1 - np.exp(-R0 * (z + I0)))\n</pre> def KM_limit(z, R0, S0, I0):     if R0 * S0 &lt; 1:         return 0     else:         return z - S0 * (1 - np.exp(-R0 * (z + I0))) In\u00a0[7]: Copied! <pre># %%capture\n\npopulation = 1e5\ninf_mean = 20\ninit_inf = 20\n\nR0s = np.concatenate((np.linspace(0.2, 1.0, 5), np.linspace(1.5, 10.0, 18)))\nS0s = [1.0, 0.8, 0.6, 0.4, 0.2]\noutput = pd.DataFrame(list(itertools.product(R0s, S0s)), columns=[\"R0\", \"S0\"])\noutput[\"I_inf_exp\"] = [\n    fsolve(KM_limit, 0.5 * (R0 * S0 &gt;= 1), args=(R0, S0, init_inf / population))[0] for R0, S0 in zip(output[\"R0\"], output[\"S0\"])\n]\noutput[\"S_inf_exp\"] = output[\"S0\"] - output[\"I_inf_exp\"]\noutput[\"I_inf_obs\"] = np.nan\noutput[\"S_inf_obs\"] = np.nan\n\n\nfor index, row in output.iterrows():\n\n    parameters = PropertySet({\"prng_seed\": 2, \"nticks\": 1460, \"verbose\": True, \"inf_mean\": inf_mean, \"beta\": row[\"R0\"] / inf_mean})\n    model = create_single_node_model(\n        population=population,\n        init_inf=init_inf,\n        init_rec=int((1 - row[\"S0\"]) * population),\n        parameters=parameters,\n    )\n\n    model.run(f\"SIR Model {index+1:3}/{len(output)}\")\n\n    output.loc[index, \"I_inf_obs\"] = (\n        np.sum(model.nodes.newly_infected) + init_inf\n    ) / population  # newly_infected doesn't count the imported infections\n    output.loc[index, \"S_inf_obs\"] = model.nodes.S[-1] / population\n</pre> # %%capture  population = 1e5 inf_mean = 20 init_inf = 20  R0s = np.concatenate((np.linspace(0.2, 1.0, 5), np.linspace(1.5, 10.0, 18))) S0s = [1.0, 0.8, 0.6, 0.4, 0.2] output = pd.DataFrame(list(itertools.product(R0s, S0s)), columns=[\"R0\", \"S0\"]) output[\"I_inf_exp\"] = [     fsolve(KM_limit, 0.5 * (R0 * S0 &gt;= 1), args=(R0, S0, init_inf / population))[0] for R0, S0 in zip(output[\"R0\"], output[\"S0\"]) ] output[\"S_inf_exp\"] = output[\"S0\"] - output[\"I_inf_exp\"] output[\"I_inf_obs\"] = np.nan output[\"S_inf_obs\"] = np.nan   for index, row in output.iterrows():      parameters = PropertySet({\"prng_seed\": 2, \"nticks\": 1460, \"verbose\": True, \"inf_mean\": inf_mean, \"beta\": row[\"R0\"] / inf_mean})     model = create_single_node_model(         population=population,         init_inf=init_inf,         init_rec=int((1 - row[\"S0\"]) * population),         parameters=parameters,     )      model.run(f\"SIR Model {index+1:3}/{len(output)}\")      output.loc[index, \"I_inf_obs\"] = (         np.sum(model.nodes.newly_infected) + init_inf     ) / population  # newly_infected doesn't count the imported infections     output.loc[index, \"S_inf_obs\"] = model.nodes.S[-1] / population <pre>SIR Model   1/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2323.67it/s]\nSIR Model   2/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2924.20it/s]\nSIR Model   3/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2935.81it/s]\nSIR Model   4/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2989.50it/s]\nSIR Model   5/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3281.22it/s]\nSIR Model   6/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2873.21it/s]\nSIR Model   7/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2890.61it/s]\nSIR Model   8/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2927.86it/s]\nSIR Model   9/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3006.62it/s]\nSIR Model  10/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3135.89it/s]\nSIR Model  11/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2986.93it/s]\nSIR Model  12/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2738.14it/s]\nSIR Model  13/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2958.82it/s]\nSIR Model  14/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2976.54it/s]\nSIR Model  15/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3142.02it/s]\nSIR Model  16/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2947.44it/s]\nSIR Model  17/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2820.64it/s]\nSIR Model  18/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2924.33it/s]\nSIR Model  19/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2988.45it/s]\nSIR Model  20/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3177.85it/s]\nSIR Model  21/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2964.57it/s]\nSIR Model  22/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3003.42it/s]\nSIR Model  23/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2911.01it/s]\nSIR Model  24/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2932.40it/s]\nSIR Model  25/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3179.34it/s]\nSIR Model  26/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2958.17it/s]\nSIR Model  27/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2899.43it/s]\nSIR Model  28/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2971.92it/s]\nSIR Model  29/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2956.70it/s]\nSIR Model  30/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3128.93it/s]\nSIR Model  31/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2866.97it/s]\nSIR Model  32/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3048.16it/s]\nSIR Model  33/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2884.93it/s]\nSIR Model  34/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2937.07it/s]\nSIR Model  35/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3184.51it/s]\nSIR Model  36/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3213.18it/s]\nSIR Model  37/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2915.23it/s]\nSIR Model  38/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2987.38it/s]\nSIR Model  39/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3021.40it/s]\nSIR Model  40/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3138.81it/s]\nSIR Model  41/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3145.93it/s]\nSIR Model  42/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3392.12it/s]\nSIR Model  43/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3209.20it/s]\nSIR Model  44/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3080.63it/s]\nSIR Model  45/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3159.51it/s]\nSIR Model  46/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3377.29it/s]\nSIR Model  47/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3379.32it/s]\nSIR Model  48/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3126.97it/s]\nSIR Model  49/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3116.38it/s]\nSIR Model  50/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3211.42it/s]\nSIR Model  51/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3439.46it/s]\nSIR Model  52/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3358.16it/s]\nSIR Model  53/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3342.42it/s]\nSIR Model  54/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3161.52it/s]\nSIR Model  55/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3175.81it/s]\nSIR Model  56/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3373.08it/s]\nSIR Model  57/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3437.35it/s]\nSIR Model  58/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3307.00it/s]\nSIR Model  59/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3318.86it/s]\nSIR Model  60/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3193.30it/s]\nSIR Model  61/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3527.83it/s]\nSIR Model  62/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3486.89it/s]\nSIR Model  63/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3479.09it/s]\nSIR Model  64/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3352.31it/s]\nSIR Model  65/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3272.56it/s]\nSIR Model  66/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3573.39it/s]\nSIR Model  67/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3602.93it/s]\nSIR Model  68/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3217.47it/s]\nSIR Model  69/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3458.12it/s]\nSIR Model  70/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3191.35it/s]\nSIR Model  71/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3512.50it/s]\nSIR Model  72/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3404.90it/s]\nSIR Model  73/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3455.92it/s]\nSIR Model  74/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3263.40it/s]\nSIR Model  75/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3343.08it/s]\nSIR Model  76/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3599.09it/s]\nSIR Model  77/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3513.90it/s]\nSIR Model  78/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3608.71it/s]\nSIR Model  79/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3547.43it/s]\nSIR Model  80/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3330.96it/s]\nSIR Model  81/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3413.99it/s]\nSIR Model  82/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3604.07it/s]\nSIR Model  83/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3484.95it/s]\nSIR Model  84/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3506.52it/s]\nSIR Model  85/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3528.20it/s]\nSIR Model  86/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3447.58it/s]\nSIR Model  87/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3282.00it/s]\nSIR Model  88/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3375.94it/s]\nSIR Model  89/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3559.61it/s]\nSIR Model  90/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3463.71it/s]\nSIR Model  91/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3657.89it/s]\nSIR Model  92/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3777.31it/s]\nSIR Model  93/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3634.24it/s]\nSIR Model  94/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3533.77it/s]\nSIR Model  95/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3535.41it/s]\nSIR Model  96/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3692.07it/s]\nSIR Model  97/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3795.09it/s]\nSIR Model  98/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3728.96it/s]\nSIR Model  99/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3821.83it/s]\nSIR Model 100/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3589.31it/s]\nSIR Model 101/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3580.00it/s]\nSIR Model 102/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3756.82it/s]\nSIR Model 103/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3753.32it/s]\nSIR Model 104/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3654.64it/s]\nSIR Model 105/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3564.68it/s]\nSIR Model 106/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3750.19it/s]\nSIR Model 107/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3020.35it/s]\nSIR Model 108/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3516.11it/s]\nSIR Model 109/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3627.43it/s]\nSIR Model 110/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3489.94it/s]\nSIR Model 111/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3460.41it/s]\nSIR Model 112/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3532.48it/s]\nSIR Model 113/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3409.73it/s]\nSIR Model 114/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3134.51it/s]\nSIR Model 115/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3452.48it/s]\n</pre> In\u00a0[8]: Copied! <pre>plt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n    plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_exp\"], color=color)\n    plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_obs\"], \".\", label=\"_nolegend_\", color=color)\nplt.xlabel(\"$R_{0}$\")\nplt.ylabel(\"$I(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"I Expected and Observed v R0\")\n\nplt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n\n    plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_exp\"], color=color)\n    plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_obs\"], \".\", label=\"_nolegend_\", color=color)\nplt.xlabel(\"$R_{0}$\")\nplt.ylabel(\"$S(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"S Expected and Observed v R0\")\n\nplt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n\n    plt.plot(\n        output[condition][\"R0\"] * S0,\n        (output[condition][\"I_inf_exp\"] - output[condition][\"I_inf_obs\"]),\n        \".\",\n        label=f\"Observed S0={S0}\",\n        color=color,\n    )\nplt.xlabel(\"$R_{eff}(t=0)$\")\nplt.ylabel(\"$I_{exp}(t \\\\rightarrow {\\\\infty}) - I_{obs}(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"I Expected - Observed v R0\")\n\nplt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\n\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n\n    plt.plot(\n        output[condition][\"R0\"] * S0,\n        (output[condition][\"S_inf_exp\"] - output[condition][\"S_inf_obs\"]),\n        \".\",\n        label=f\"Observed S0={S0}\",\n        color=color,\n    )\nplt.xlabel(\"$R_{eff}(t=0)$\")\nplt.ylabel(\"$S_{exp}(t \\\\rightarrow {\\\\infty}) - S_{obs}(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"S Expected - Observed v R0\")\n</pre> plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]) for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)     plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_exp\"], color=color)     plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_obs\"], \".\", label=\"_nolegend_\", color=color) plt.xlabel(\"$R_{0}$\") plt.ylabel(\"$I(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"I Expected and Observed v R0\")  plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]) for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)      plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_exp\"], color=color)     plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_obs\"], \".\", label=\"_nolegend_\", color=color) plt.xlabel(\"$R_{0}$\") plt.ylabel(\"$S(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"S Expected and Observed v R0\")  plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]) for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)      plt.plot(         output[condition][\"R0\"] * S0,         (output[condition][\"I_inf_exp\"] - output[condition][\"I_inf_obs\"]),         \".\",         label=f\"Observed S0={S0}\",         color=color,     ) plt.xlabel(\"$R_{eff}(t=0)$\") plt.ylabel(\"$I_{exp}(t \\\\rightarrow {\\\\infty}) - I_{obs}(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"I Expected - Observed v R0\")  plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])  for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)      plt.plot(         output[condition][\"R0\"] * S0,         (output[condition][\"S_inf_exp\"] - output[condition][\"S_inf_obs\"]),         \".\",         label=f\"Observed S0={S0}\",         color=color,     ) plt.xlabel(\"$R_{eff}(t=0)$\") plt.ylabel(\"$S_{exp}(t \\\\rightarrow {\\\\infty}) - S_{obs}(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"S Expected - Observed v R0\") Out[8]: <pre>Text(0.5, 1.0, 'S Expected - Observed v R0')</pre> In\u00a0[9]: Copied! <pre>print(\n    \"S expected - S observed &lt; 0.05: \" + str((np.isclose(output[\"S_inf_exp\"], output[\"S_inf_obs\"], atol=0.05)).all())\n)  # Account for 1 timestep offset here\nprint(\n    \"I expected - I observed &lt; 0.05: \" + str((np.isclose(output[\"I_inf_exp\"], output[\"I_inf_obs\"], atol=0.05)).all())\n)  # Account for 1 timestep offset here\n</pre> print(     \"S expected - S observed &lt; 0.05: \" + str((np.isclose(output[\"S_inf_exp\"], output[\"S_inf_obs\"], atol=0.05)).all()) )  # Account for 1 timestep offset here print(     \"I expected - I observed &lt; 0.05: \" + str((np.isclose(output[\"I_inf_exp\"], output[\"I_inf_obs\"], atol=0.05)).all()) )  # Account for 1 timestep offset here <pre>S expected - S observed &lt; 0.05: True\nI expected - I observed &lt; 0.05: True\n</pre>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#outbreak-size-in-the-sir-model-kermack-mckendrick-relation","title":"Outbreak size in the SIR model (Kermack-McKendrick relation)\u00b6","text":"<p>We move next to the Susceptible-Infected-Recovered model, the first of these canonical test models that actually provides a decent, coarse, representation of many vaccine-preventable diseases that we are interested in.  This test will explore the size of acute outbreaks; in this situation, the role of demography is pretty small and serves only to complicate the analysis, so we will work without demography.  The model contains three agent states and two transitions: susceptible -&gt; infected -&gt; recovered, with the recovered state assumed to be lifelong.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} $$</p> <p>$$ \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I $$</p> <p>$$ \\dot{R} = \\gamma I $$</p> <p>As before, we discretize this as: $$ \\Delta I = Bin(S_t, 1-exp^{-\\beta \\Delta t \\frac{I}{N}}) $$</p> <p>$$ \\Delta R = Bin(I_t, 1-exp^{-\\gamma \\Delta t}) $$</p> <p>$$ S_{t+1} = S_t - \\Delta I_t $$</p> <p>$$ I_{t+1} = I_t + \\Delta I_t -\\Delta R_t $$</p> <p>$$ R_{t+1} = R_t + \\Delta R_t $$</p> <p>Note: As written, the dwell time of individuals in the infectious state is strictly exponentially distributed.  Without introducing substantially more complexity (delay-differential or integro-differential equations, the Generalized Linear Chain Trick), this is a general feature of ODE systems.  In agent-based models, however, the distribution of the dwell time in the Infectious state can be chosen from an arbitrary distribution, in which case the discretization as written no longer holds.  For the purposes of comparability with analytic results, we choose to draw from an exponential distribution in the below.</p> <p>Analysis of the SIR system can be found in other sources, and closed-form analytic solutions to the system dyanmics are elusive and generally too complicated to provide much insight - more generally useful are results about the equilibrium states as  $t \\rightarrow \\infty$.  We'll focus here on one of these, the size of an outbreak introduced into a closed population, given by the implicit formula</p> <p>$$  Z =  \\begin{cases}     S_0(1-e^{-R_0[Z+I_0]}), &amp; \\text{if} \\:\\:  R_0S(0)&gt;1 \\\\     0, &amp;\\text{if} \\:\\:  R_0S(0)&lt;=1 \\end{cases} $$</p> <p>$$ Z = \\sum_{t=0}^\\infty I(t) = S_0 - S_\\infty $$</p> <p>$$ R_0 = \\frac{\\beta}{\\gamma} $$</p> <p>One can obtain an approximate analytic solution for the outbreak curve itself, shown below. However, the approximation employed in deriving this is that $R_0 R(t)$ is small, which likely to be violated during the peak of the outbreak.  And it's immediately clear upon looking at this formula that it doesn't exactly offer some intuitive interpretation for the dynamics.</p> <p>$$ \\frac{dR}{dt} = \\frac{\\gamma \\alpha^2}{2S(0)R_0^2}\\text{sech}^2\\left(\\frac{\\alpha \\gamma t}{2} - \\phi\\right) $$</p> <p>$$ \\phi = \\text{tanh}^{-1}\\left(\\frac{S(0)(R_0-1)}{\\alpha}\\right) $$</p> <p>$$ \\alpha = \\sqrt{S(0)^2(R_0-1)^2 + 2S(0)I(0)R_0^2} $$</p> <p>This notebook will focus on testing the final size prediction and for now, ignore testing the approximate formula for the whole outbreak curve.</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#construct-the-model","title":"Construct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Then we construct a single-patch LASER model with four components: the states <code>Susceptible</code>, <code>Recovered</code>, and <code>Infectious</code>, and the <code>Transmission</code> process.  The <code>Susceptible</code> and <code>Transmission</code> components look largely the same as the SI and SIS models.  The <code>Infectious</code> component now moves people into a <code>Recovered</code> state when <code>itimer</code> expires, instead of sending them back to <code>Susceptible</code> as in the SIS model.  As there are no vital dynamics in this model, the <code>Recovered</code> state is a terminal state - these agents have no further dynamics and participate only by being part of the total population denominator in the <code>Transmission</code> component.</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test, as always, ensures that certain basic constraints are being obeyed by the model.  We can check that $S_t = N_t - \\sum{\\Delta I_t}$, that $R_t = \\sum{\\Delta R_t}$, and the total population is constant and equal to $S_t + I_t + R_t$ for all timesteps.</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#scientific-test","title":"Scientific test\u00b6","text":"<p>The scientific test will loop over a set of $(R_0, S(0))$ pairs and confirm that the final outbreak size matches the expectation given in the equation above.  As this is a stochastic model, the main concern is that when $R_0S(0)$ is close to one, the outbreak may fail to take off or truncate at a slightly smaller final size.</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>Check that the expected relationships between susceptible, infected, recovered, and total population hold.</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#scientific-test","title":"Scientific test\u00b6","text":"<p>We will now loop over a few values of R-zero and initial susceptibility, and compare the size of the outbreak against the expected size given by the equation in the introduction</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/","title":"Average age at infection in the SIR model","text":"In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import curve_fit\nfrom scipy.stats import expon\nfrom scipy.stats import kstest\nfrom sklearn.metrics import mean_squared_error\nfrom functools import partial\n\nimport laser.core.distributions as dists\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nfrom laser.generic import SIR\nfrom laser.generic import Model\nfrom laser.generic.utils import ValuesMap\nfrom laser.core.utils import grid\n\nimport laser.core\nimport laser.generic\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.optimize import curve_fit from scipy.stats import expon from scipy.stats import kstest from sklearn.metrics import mean_squared_error from functools import partial  import laser.core.distributions as dists from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator from laser.generic import SIR from laser.generic import Model from laser.generic.utils import ValuesMap from laser.core.utils import grid  import laser.core import laser.generic  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>done\nnp.__version__='2.2.6'\nlaser.core.__version__='0.9.1'\nlaser.generic.__version__='0.0.0'\n</pre> <p>Here we build the modified Transmission class, to record date of infection.</p> In\u00a0[2]: Copied! <pre>import numba as nb\nfrom laser.generic import State\n\nclass TransmissionWithDOI(SIR.Transmission):\n    def __init__(self, model, infdurdist, infdurmin: int =1):\n        super().__init__(model, infdurdist, infdurmin)\n        #After calling the superclass constructor, add an agent property \"doi\" to record date of infection\n        self.model.people.add_scalar_property(\"doi\", dtype=np.int32)  # Date of Infection\n        self.model.people.doi[:] = -1\n        \n    #Next, define the Numba-accelerated transmission function - this looks like exactly like the one from the transmission class, \n    #but takes in the additional \"doi\" parameter and fills it with the current timestep upon infection\n    @staticmethod\n    @nb.njit(\n        nogil=True,\n        parallel=True,\n    )\n    def nb_transmission_doi(states, nodeids, ft, inf_by_node, itimers, infdurdist, infdurmin, tick, dois):\n        for i in nb.prange(len(states)):\n            if states[i] == State.SUSCEPTIBLE.value:\n                # Check for infection\n                draw = np.random.rand()\n                nid = nodeids[i]\n                if draw &lt; ft[nid]:\n                    states[i] = State.INFECTIOUS.value\n                    dois[i] = tick  # Set date of infection\n                    itimers[i] = np.maximum(np.round(infdurdist(tick, nid)), infdurmin)  # Set the infection timer\n                    inf_by_node[nb.get_thread_id(), nid] += 1\n\n        return\n\n    #Finally, we define the step function, which again mirrors that of the Transmission class but calls the new nb_transmission_doi function and passes \n    #doi to it appropriately\n    def step(self, tick: int) -&gt; None:\n        ft = self.model.nodes.forces[tick]\n\n        N = self.model.nodes.S[tick] + (I := self.model.nodes.I[tick])  # noqa: E741\n        # Shouldn't be any exposed (E), because this is an S-&gt;I model\n        # Might have R.  \n        if hasattr(self.model.nodes, \"R\"):\n            N += self.model.nodes.R[tick]\n\n        ft[:] = self.model.params.beta * I / N\n        transfer = ft[:, None] * self.model.network\n        ft += transfer.sum(axis=0)\n        ft -= transfer.sum(axis=1)\n        ft = -np.expm1(-ft)  # Convert to probability of infection\n\n        inf_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.uint32)\n        self.nb_transmission_doi(\n            self.model.people.state, self.model.people.nodeid, ft, inf_by_node, self.model.people.itimer, self.infdurdist, self.infdurmin,\n            tick, self.model.people.doi # DOI specific parameters\n        )\n        inf_by_node = inf_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads\n\n        # state(t+1) = state(t) + \u2206state(t)\n        self.model.nodes.S[tick + 1] -= inf_by_node\n        self.model.nodes.I[tick + 1] += inf_by_node\n        # Record today's \u2206\n        self.model.nodes.newly_infected[tick] = inf_by_node\n\n        return\n</pre> import numba as nb from laser.generic import State  class TransmissionWithDOI(SIR.Transmission):     def __init__(self, model, infdurdist, infdurmin: int =1):         super().__init__(model, infdurdist, infdurmin)         #After calling the superclass constructor, add an agent property \"doi\" to record date of infection         self.model.people.add_scalar_property(\"doi\", dtype=np.int32)  # Date of Infection         self.model.people.doi[:] = -1              #Next, define the Numba-accelerated transmission function - this looks like exactly like the one from the transmission class,      #but takes in the additional \"doi\" parameter and fills it with the current timestep upon infection     @staticmethod     @nb.njit(         nogil=True,         parallel=True,     )     def nb_transmission_doi(states, nodeids, ft, inf_by_node, itimers, infdurdist, infdurmin, tick, dois):         for i in nb.prange(len(states)):             if states[i] == State.SUSCEPTIBLE.value:                 # Check for infection                 draw = np.random.rand()                 nid = nodeids[i]                 if draw &lt; ft[nid]:                     states[i] = State.INFECTIOUS.value                     dois[i] = tick  # Set date of infection                     itimers[i] = np.maximum(np.round(infdurdist(tick, nid)), infdurmin)  # Set the infection timer                     inf_by_node[nb.get_thread_id(), nid] += 1          return      #Finally, we define the step function, which again mirrors that of the Transmission class but calls the new nb_transmission_doi function and passes      #doi to it appropriately     def step(self, tick: int) -&gt; None:         ft = self.model.nodes.forces[tick]          N = self.model.nodes.S[tick] + (I := self.model.nodes.I[tick])  # noqa: E741         # Shouldn't be any exposed (E), because this is an S-&gt;I model         # Might have R.           if hasattr(self.model.nodes, \"R\"):             N += self.model.nodes.R[tick]          ft[:] = self.model.params.beta * I / N         transfer = ft[:, None] * self.model.network         ft += transfer.sum(axis=0)         ft -= transfer.sum(axis=1)         ft = -np.expm1(-ft)  # Convert to probability of infection          inf_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.uint32)         self.nb_transmission_doi(             self.model.people.state, self.model.people.nodeid, ft, inf_by_node, self.model.people.itimer, self.infdurdist, self.infdurmin,             tick, self.model.people.doi # DOI specific parameters         )         inf_by_node = inf_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads          # state(t+1) = state(t) + \u2206state(t)         self.model.nodes.S[tick + 1] -= inf_by_node         self.model.nodes.I[tick + 1] += inf_by_node         # Record today's \u2206         self.model.nodes.newly_infected[tick] = inf_by_node          return <p>Now we define the <code>Importation</code> class, which will periodically infect a few susceptibles to prevent die-out.</p> In\u00a0[3]: Copied! <pre>class Importation:\n    def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3):\n        self.model = model\n        self.infdurdist = infdurdist\n        self.infdurmin = infdurmin\n        self.period = period\n        self.count = count\n\n        self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)\n\n        return\n    \n    def step(self, tick: int) -&gt; None:\n        if tick &gt; 0 and tick % self.period == 0:\n            i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]\n            if len(i_susceptible) &gt; 0:\n                count = min(self.count, len(i_susceptible))\n                i_infect = np.random.choice(i_susceptible, size=count, replace=False)\n                self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value\n                samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))\n                samples = np.round(samples)\n                samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)\n                self.model.people.itimer[i_infect] = samples\n                inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)\n                self.model.nodes.S[tick + 1] -= inf_by_node\n                self.model.nodes.I[tick + 1] += inf_by_node\n                self.model.nodes.imports[tick] = inf_by_node\n            # else:\n            #     print(f\"No susceptibles to infect at tick {tick}\")\n\n        return\n</pre> class Importation:     def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3):         self.model = model         self.infdurdist = infdurdist         self.infdurmin = infdurmin         self.period = period         self.count = count          self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)          return          def step(self, tick: int) -&gt; None:         if tick &gt; 0 and tick % self.period == 0:             i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]             if len(i_susceptible) &gt; 0:                 count = min(self.count, len(i_susceptible))                 i_infect = np.random.choice(i_susceptible, size=count, replace=False)                 self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value                 samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))                 samples = np.round(samples)                 samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)                 self.model.people.itimer[i_infect] = samples                 inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)                 self.model.nodes.S[tick + 1] -= inf_by_node                 self.model.nodes.I[tick + 1] += inf_by_node                 self.model.nodes.imports[tick] = inf_by_node             # else:             #     print(f\"No susceptibles to infect at tick {tick}\")          return  In\u00a0[\u00a0]: Copied! <pre>from laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator\n\npop=3e5\nscenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=-(122+(19+(59/60))/60), origin_y=47+(36+(35/60))/60)\ninitial_infected = 1\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\nscenario[\"R\"] = 0\nparameters = PropertySet(\n    # {\"seed\": 4, \"nticks\": 18250, \"verbose\": True, \"beta\": 0.1, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3}\n    {\"seed\": 4, \"nticks\": 30*365, \"verbose\": True, \"beta\": 12/60, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3}\n)\n\nbirthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))\nmodel = Model(scenario, parameters, birthrates=birthrate_map)\ninfdurdist = dists.exponential(scale=parameters.inf_mean)\nrate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators.\nstable_age_dist = np.array(1000*np.exp(-rate_const*np.arange(89)))\npyramid = AliasedDistribution(stable_age_dist)\nsurvival = KaplanMeierEstimator(stable_age_dist.cumsum())\nmodel.components = [\n    SIR.Susceptible(model),\n    SIR.Recovered(model),\n    SIR.Infectious(model, infdurdist),\n    Importation(model, infdurdist),\n    # SIR.Transmission(model, infdurdist),\n    TransmissionWithDOI(model, infdurdist),\n    BirthsByCBR(model, birthrate_map, pyramid=pyramid),\n    MortalityByEstimator(model, estimator=survival),\n]\n\nmodel.run()\nplt.plot(model.nodes.S, color=\"blue\")\nplt.plot(model.nodes.I, color=\"red\")\nplt.plot(model.nodes.R, color=\"green\")\nplt.plot(model.nodes.S+model.nodes.I+model.nodes.R, color=\"black\")\nplt.legend([\"S\", \"I\", \"R\", \"N\"])\nplt.figure()\ncut = (model.people.doi &gt;= 365*28) \nplt.hist(model.people.doi[cut] - model.people.dob[cut], 40)\nplt.show()\n</pre> from laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator  pop=3e5 scenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=-(122+(19+(59/60))/60), origin_y=47+(36+(35/60))/60) initial_infected = 1 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected scenario[\"R\"] = 0 parameters = PropertySet(     # {\"seed\": 4, \"nticks\": 18250, \"verbose\": True, \"beta\": 0.1, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3}     {\"seed\": 4, \"nticks\": 30*365, \"verbose\": True, \"beta\": 12/60, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3} )  birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario)) model = Model(scenario, parameters, birthrates=birthrate_map) infdurdist = dists.exponential(scale=parameters.inf_mean) rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators. stable_age_dist = np.array(1000*np.exp(-rate_const*np.arange(89))) pyramid = AliasedDistribution(stable_age_dist) survival = KaplanMeierEstimator(stable_age_dist.cumsum()) model.components = [     SIR.Susceptible(model),     SIR.Recovered(model),     SIR.Infectious(model, infdurdist),     Importation(model, infdurdist),     # SIR.Transmission(model, infdurdist),     TransmissionWithDOI(model, infdurdist),     BirthsByCBR(model, birthrate_map, pyramid=pyramid),     MortalityByEstimator(model, estimator=survival), ]  model.run() plt.plot(model.nodes.S, color=\"blue\") plt.plot(model.nodes.I, color=\"red\") plt.plot(model.nodes.R, color=\"green\") plt.plot(model.nodes.S+model.nodes.I+model.nodes.R, color=\"black\") plt.legend([\"S\", \"I\", \"R\", \"N\"]) plt.figure() cut = (model.people.doi &gt;= 365*28)  plt.hist(model.people.doi[cut] - model.people.dob[cut], 40) plt.show() <pre>300,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10950/10950 [00:10&lt;00:00, 1073.57it/s]\n</pre> Out[\u00a0]: <pre>(array([1.0895e+04, 8.4550e+03, 6.2160e+03, 4.7340e+03, 3.6110e+03,\n        2.5050e+03, 2.0470e+03, 1.5200e+03, 1.1860e+03, 9.0300e+02,\n        6.8400e+02, 4.8800e+02, 3.3100e+02, 2.7900e+02, 2.3000e+02,\n        1.5300e+02, 1.2700e+02, 9.0000e+01, 7.9000e+01, 4.4000e+01,\n        3.1000e+01, 3.7000e+01, 2.9000e+01, 1.4000e+01, 9.0000e+00,\n        6.0000e+00, 4.0000e+00, 5.0000e+00, 2.0000e+00, 3.0000e+00,\n        4.0000e+00, 0.0000e+00, 3.0000e+00, 1.0000e+00, 0.0000e+00,\n        0.0000e+00, 0.0000e+00, 1.0000e+00, 0.0000e+00, 2.0000e+00]),\n array([1.000000e+00, 1.018250e+02, 2.026500e+02, 3.034750e+02,\n        4.043000e+02, 5.051250e+02, 6.059500e+02, 7.067750e+02,\n        8.076000e+02, 9.084250e+02, 1.009250e+03, 1.110075e+03,\n        1.210900e+03, 1.311725e+03, 1.412550e+03, 1.513375e+03,\n        1.614200e+03, 1.715025e+03, 1.815850e+03, 1.916675e+03,\n        2.017500e+03, 2.118325e+03, 2.219150e+03, 2.319975e+03,\n        2.420800e+03, 2.521625e+03, 2.622450e+03, 2.723275e+03,\n        2.824100e+03, 2.924925e+03, 3.025750e+03, 3.126575e+03,\n        3.227400e+03, 3.328225e+03, 3.429050e+03, 3.529875e+03,\n        3.630700e+03, 3.731525e+03, 3.832350e+03, 3.933175e+03,\n        4.034000e+03]),\n &lt;BarContainer object of 40 artists&gt;)</pre> In\u00a0[5]: Copied! <pre>mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\nR0 = model.params.beta / (1 / model.params.inf_mean + mu)\nA = 1 / (R0 * mu) / 365\na = np.arange(0, 15, 1/12)\n\ndef fit_age_at_infection(model, cutpos=5000):\n    cut = model.people.doi &gt; cutpos\n    data = (model.people.doi[cut] - model.people.dob[cut]) / 365\n    expfit = expon.fit(data)\n    fitqual = kstest(data, expon.cdf, expfit)\n    return data, expfit, fitqual\n\ndata, expfit, fitqual = fit_age_at_infection(model)\n\nplt.hist(data, bins=a, density=True)\nplt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4)\nplt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\")\nplt.xlabel(\"Age at infection (years)\")\nplt.ylabel(\"Density\")\nplt.legend(\n    [\n        f\"Expected exponential distribution - A = {A:.2f} years\",\n        f\"Best fit age of infection, A = {expfit[1]:.2f} years\",\n        \"Ages from simulation\",\n    ]\n)\nplt.show()\nfitqual\n</pre> mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1 R0 = model.params.beta / (1 / model.params.inf_mean + mu) A = 1 / (R0 * mu) / 365 a = np.arange(0, 15, 1/12)  def fit_age_at_infection(model, cutpos=5000):     cut = model.people.doi &gt; cutpos     data = (model.people.doi[cut] - model.people.dob[cut]) / 365     expfit = expon.fit(data)     fitqual = kstest(data, expon.cdf, expfit)     return data, expfit, fitqual  data, expfit, fitqual = fit_age_at_infection(model)  plt.hist(data, bins=a, density=True) plt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4) plt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\") plt.xlabel(\"Age at infection (years)\") plt.ylabel(\"Density\") plt.legend(     [         f\"Expected exponential distribution - A = {A:.2f} years\",         f\"Best fit age of infection, A = {expfit[1]:.2f} years\",         \"Ages from simulation\",     ] ) plt.show() fitqual Out[5]: <pre>KstestResult(statistic=np.float64(0.003316425350068257), pvalue=np.float64(0.000590975775692332), statistic_location=np.float64(0.0410958904109589), statistic_sign=np.int8(1))</pre> In\u00a0[6]: Copied! <pre>A2 = 1 / ((R0 - 1) * mu) / 365\n\n\ndef Scurve(x, lam):\n    return np.exp(-x / lam)\n\n\ndef fit_susceptibility_vs_age(model, cutpos=5000):\n    cut = (model.people.state == State.SUSCEPTIBLE.value) &amp; (model.people.dob &gt; cutpos)\n    bins = np.linspace(0, 15, 180)\n    age_years = (np.max(model.people.dob) - model.people.dob) / 365\n    n1 = np.histogram(age_years, bins=bins)[0]\n    n2 = np.histogram(age_years[cut], bins=bins)[0]\n    n1[n1 == 0] = 1\n    y1 = n2 / n1\n    popt, pcov = curve_fit(Scurve, bins[1:], y1, p0=2.5)\n    mse = mean_squared_error(y1, Scurve(bins[1:], *popt))\n    return y1, bins, popt, pcov, mse\n\ndata, bins, popt, pcov, mse = fit_susceptibility_vs_age(model)\n\n# Plotting is a little more complicated here, want to plot at the bin centers and force y=1 at x=0\nplt.plot([0, *bins[1:]], [1, *data], \".\")\nplt.plot([0, *bins[1:]], [1, *(Scurve(bins[1:], A2))], lw=4)\nplt.plot([0, *bins[1:]], [1, *(Scurve(bins[1:], *popt))], \"k--\")\nplt.legend(\n    [\"Fraction susceptible at age\", f\"Expected exponential distribution - A = {A2:.3f} years\", f\"Best fit mean age of susceptibility, A = {popt[0]:.3f} years\"]\n)\nplt.xlabel(\"Age (years)\")\nplt.xlim(0, 15)\nplt.ylabel(\"Fraction of individuals susceptible at age\")\nplt.show()\nprint(\"RMSE = \", np.sqrt(mse))\n</pre> A2 = 1 / ((R0 - 1) * mu) / 365   def Scurve(x, lam):     return np.exp(-x / lam)   def fit_susceptibility_vs_age(model, cutpos=5000):     cut = (model.people.state == State.SUSCEPTIBLE.value) &amp; (model.people.dob &gt; cutpos)     bins = np.linspace(0, 15, 180)     age_years = (np.max(model.people.dob) - model.people.dob) / 365     n1 = np.histogram(age_years, bins=bins)[0]     n2 = np.histogram(age_years[cut], bins=bins)[0]     n1[n1 == 0] = 1     y1 = n2 / n1     popt, pcov = curve_fit(Scurve, bins[1:], y1, p0=2.5)     mse = mean_squared_error(y1, Scurve(bins[1:], *popt))     return y1, bins, popt, pcov, mse  data, bins, popt, pcov, mse = fit_susceptibility_vs_age(model)  # Plotting is a little more complicated here, want to plot at the bin centers and force y=1 at x=0 plt.plot([0, *bins[1:]], [1, *data], \".\") plt.plot([0, *bins[1:]], [1, *(Scurve(bins[1:], A2))], lw=4) plt.plot([0, *bins[1:]], [1, *(Scurve(bins[1:], *popt))], \"k--\") plt.legend(     [\"Fraction susceptible at age\", f\"Expected exponential distribution - A = {A2:.3f} years\", f\"Best fit mean age of susceptibility, A = {popt[0]:.3f} years\"] ) plt.xlabel(\"Age (years)\") plt.xlim(0, 15) plt.ylabel(\"Fraction of individuals susceptible at age\") plt.show() print(\"RMSE = \", np.sqrt(mse))  <pre>RMSE =  0.00653116128761858\n</pre> In\u00a0[7]: Copied! <pre># Test that population age distribution is correct\ndef fit_population_age_distribution(model, max_age_years=100):\n    tick = model.params.nticks\n    cut = model.people.dod &gt; tick\n    age_years = (tick - model.people.dob[cut]) / 365\n    expfit = expon.fit(age_years[age_years &lt;= max_age_years])\n    fitqual = kstest(age_years[age_years &lt;= max_age_years], expon.cdf, expfit)\n    return age_years, expfit, fitqual\n\n\nage_years, expfit, fitqual = fit_population_age_distribution(model)\nmu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\nA = 1 / mu / 365\na = np.arange(0, 60, 0.1)\n\nplt.hist(age_years, bins=a, density=True)\nplt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4)\nplt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\")\nplt.xlabel(\"Population age distribution (years)\")\nplt.ylabel(\"Density\")\nplt.legend(\n    [f\"Expected exponential distribution - A = {A:.2f} years\", f\"Best fit age distribution, A = {expfit[1]:.2f} years\", \"Simulation output\"]\n)\nplt.show()\nfitqual\n</pre> # Test that population age distribution is correct def fit_population_age_distribution(model, max_age_years=100):     tick = model.params.nticks     cut = model.people.dod &gt; tick     age_years = (tick - model.people.dob[cut]) / 365     expfit = expon.fit(age_years[age_years &lt;= max_age_years])     fitqual = kstest(age_years[age_years &lt;= max_age_years], expon.cdf, expfit)     return age_years, expfit, fitqual   age_years, expfit, fitqual = fit_population_age_distribution(model) mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1 A = 1 / mu / 365 a = np.arange(0, 60, 0.1)  plt.hist(age_years, bins=a, density=True) plt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4) plt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\") plt.xlabel(\"Population age distribution (years)\") plt.ylabel(\"Density\") plt.legend(     [f\"Expected exponential distribution - A = {A:.2f} years\", f\"Best fit age distribution, A = {expfit[1]:.2f} years\", \"Simulation output\"] ) plt.show() fitqual  Out[7]: <pre>KstestResult(statistic=np.float64(0.004452976731299074), pvalue=np.float64(2.3525039838407847e-05), statistic_location=np.float64(6.16986301369863), statistic_sign=np.int8(-1))</pre> In\u00a0[8]: Copied! <pre>cbrs = 70 + 30 * np.random.rand(25)\nR0s = 5 + 10 * np.random.rand(25)\npop = 1e5\ninitial_infected = 1\ninf_mean = 90\noutput = pd.DataFrame(data={\"cbr\": cbrs, \"R0\": R0s})\noutput[\"Average_Iage_observed\"] = np.nan\noutput[\"Average_Iage_expected\"] = np.nan\noutput[\"Average_Sage_observed\"] = np.nan\noutput[\"Average_Sage_expected\"] = np.nan\noutput[\"Average_age_expected\"] = np.nan\noutput[\"Average_age_expected\"] = np.nan\n\nfor index, row in output.iterrows():\n    parameters = PropertySet(\n        {\n            \"seed\": 2,\n            \"nticks\": 365*50,\n            \"verbose\": True,\n            \"beta\": row[\"R0\"] * (mu + 1 / inf_mean),\n            \"inf_mean\": inf_mean,\n            \"cbr\": row[\"cbr\"],\n            \"importation_period\": 180,\n            \"importation_count\": 3,\n        }\n    )\n    scenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\n    scenario[\"I\"] = initial_infected\n    scenario[\"R\"] = np.round(pop * (1 / row[\"R0\"] - 0.05)).astype(np.int32)\n    scenario[\"S\"] = scenario.population - scenario[\"I\"] - scenario[\"R\"]\n\n    parameters = PropertySet(\n        {\"seed\": index, \"nticks\": 365*50, \"verbose\": True, \"beta\": parameters.beta, \"inf_mean\": parameters.inf_mean, \"cbr\": parameters.cbr, \"importation_period\": 180, \"importation_count\": 3}\n    )\n    birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))\n    model = Model(scenario, parameters, birthrates=birthrate_map)\n\n    infdurdist = dists.exponential(scale=parameters.inf_mean)\n    rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators.\n    pyramid = AliasedDistribution(stable_age_dist:=np.array(1000*np.exp(-rate_const*np.arange(89))))\n    survival = KaplanMeierEstimator(stable_age_dist.cumsum())\n\n    model.components = [\n        SIR.Susceptible(model),\n        SIR.Recovered(model),\n        SIR.Infectious(model, infdurdist),\n        Importation(model, infdurdist),\n        TransmissionWithDOI(model, infdurdist),\n        BirthsByCBR(model, birthrate_map, pyramid=pyramid),\n        MortalityByEstimator(model, estimator=survival),\n    ]\n\n    model.run(f\"Running model {index+1} of {len(output)} with R0={row['R0']:.2f}, cbr={row['cbr']:.2f}\")\n    mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\n    _, expfit, _ = fit_age_at_infection(model, 365*40)\n\n    output.loc[index, \"Average_Iage_expected\"] = 1 / (row[\"R0\"] * mu) / 365\n    output.loc[index, \"Average_Iage_observed\"] = expfit[1]\n\n    # _, _, popt, _, _ = fit_susceptibility_vs_age(model, 365*20)\n    # output.loc[index, \"Average_Sage_expected\"] = 1 / ((row[\"R0\"] - 1) * mu) / 365\n    # output.loc[index, \"Average_Sage_observed\"] = popt[0]\n\n    # _, expfit, _ = fit_population_age_distribution(model)\n    # output.loc[index, \"Average_age_expected\"] = 1 / mu / 365\n    # output.loc[index, \"Average_age_observed\"] = expfit[1]\n</pre> cbrs = 70 + 30 * np.random.rand(25) R0s = 5 + 10 * np.random.rand(25) pop = 1e5 initial_infected = 1 inf_mean = 90 output = pd.DataFrame(data={\"cbr\": cbrs, \"R0\": R0s}) output[\"Average_Iage_observed\"] = np.nan output[\"Average_Iage_expected\"] = np.nan output[\"Average_Sage_observed\"] = np.nan output[\"Average_Sage_expected\"] = np.nan output[\"Average_age_expected\"] = np.nan output[\"Average_age_expected\"] = np.nan  for index, row in output.iterrows():     parameters = PropertySet(         {             \"seed\": 2,             \"nticks\": 365*50,             \"verbose\": True,             \"beta\": row[\"R0\"] * (mu + 1 / inf_mean),             \"inf_mean\": inf_mean,             \"cbr\": row[\"cbr\"],             \"importation_period\": 180,             \"importation_count\": 3,         }     )     scenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)     scenario[\"I\"] = initial_infected     scenario[\"R\"] = np.round(pop * (1 / row[\"R0\"] - 0.05)).astype(np.int32)     scenario[\"S\"] = scenario.population - scenario[\"I\"] - scenario[\"R\"]      parameters = PropertySet(         {\"seed\": index, \"nticks\": 365*50, \"verbose\": True, \"beta\": parameters.beta, \"inf_mean\": parameters.inf_mean, \"cbr\": parameters.cbr, \"importation_period\": 180, \"importation_count\": 3}     )     birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))     model = Model(scenario, parameters, birthrates=birthrate_map)      infdurdist = dists.exponential(scale=parameters.inf_mean)     rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators.     pyramid = AliasedDistribution(stable_age_dist:=np.array(1000*np.exp(-rate_const*np.arange(89))))     survival = KaplanMeierEstimator(stable_age_dist.cumsum())      model.components = [         SIR.Susceptible(model),         SIR.Recovered(model),         SIR.Infectious(model, infdurdist),         Importation(model, infdurdist),         TransmissionWithDOI(model, infdurdist),         BirthsByCBR(model, birthrate_map, pyramid=pyramid),         MortalityByEstimator(model, estimator=survival),     ]      model.run(f\"Running model {index+1} of {len(output)} with R0={row['R0']:.2f}, cbr={row['cbr']:.2f}\")     mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1     _, expfit, _ = fit_age_at_infection(model, 365*40)      output.loc[index, \"Average_Iage_expected\"] = 1 / (row[\"R0\"] * mu) / 365     output.loc[index, \"Average_Iage_observed\"] = expfit[1]      # _, _, popt, _, _ = fit_susceptibility_vs_age(model, 365*20)     # output.loc[index, \"Average_Sage_expected\"] = 1 / ((row[\"R0\"] - 1) * mu) / 365     # output.loc[index, \"Average_Sage_observed\"] = popt[0]      # _, expfit, _ = fit_population_age_distribution(model)     # output.loc[index, \"Average_age_expected\"] = 1 / mu / 365     # output.loc[index, \"Average_age_observed\"] = expfit[1]  <pre>Running model 1 of 25 with R0=11.54, cbr=85.98: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1232.25it/s]\nRunning model 2 of 25 with R0=11.84, cbr=78.35: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1269.88it/s]\nRunning model 3 of 25 with R0=14.15, cbr=94.57: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1283.06it/s]\nRunning model 4 of 25 with R0=11.99, cbr=95.82: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1267.16it/s]\nRunning model 5 of 25 with R0=5.49, cbr=81.61: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1236.26it/s]\nRunning model 6 of 25 with R0=13.30, cbr=78.38: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1281.16it/s]\nRunning model 7 of 25 with R0=12.02, cbr=80.48: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1268.92it/s]\nRunning model 8 of 25 with R0=6.81, cbr=72.19: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1233.07it/s]\nRunning model 9 of 25 with R0=10.93, cbr=70.94: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1263.84it/s]\nRunning model 10 of 25 with R0=9.33, cbr=80.18: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1248.86it/s]\nRunning model 11 of 25 with R0=8.04, cbr=86.15: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1250.44it/s]\nRunning model 12 of 25 with R0=12.84, cbr=72.16: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1256.66it/s]\nRunning model 13 of 25 with R0=12.86, cbr=84.02: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1270.37it/s]\nRunning model 14 of 25 with R0=14.67, cbr=97.83: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1268.64it/s]\nRunning model 15 of 25 with R0=12.67, cbr=97.89: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1237.17it/s]\nRunning model 16 of 25 with R0=9.16, cbr=92.04: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1224.49it/s]\nRunning model 17 of 25 with R0=14.68, cbr=97.68: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1254.20it/s]\nRunning model 18 of 25 with R0=13.51, cbr=88.97: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1253.70it/s]\nRunning model 19 of 25 with R0=8.24, cbr=77.20: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1234.85it/s]\nRunning model 20 of 25 with R0=5.45, cbr=83.32: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1217.16it/s]\nRunning model 21 of 25 with R0=13.46, cbr=84.72: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1273.55it/s]\nRunning model 22 of 25 with R0=11.51, cbr=89.34: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1258.22it/s]\nRunning model 23 of 25 with R0=12.37, cbr=74.80: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1239.25it/s]\nRunning model 24 of 25 with R0=6.05, cbr=94.90: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1222.81it/s]\nRunning model 25 of 25 with R0=14.69, cbr=97.27: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18250/18250 [00:14&lt;00:00, 1274.46it/s]\n</pre> In\u00a0[9]: Copied! <pre># Plotting the expected and observed values\nfig, axes = plt.subplots(3, 1, figsize=(10, 15))\n\n# Plot for Average_Iage\naxes[0].scatter(output[\"Average_Iage_expected\"], output[\"Average_Iage_observed\"], c=\"blue\")\naxes[0].plot(\n    [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],\n    [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],\n    \"r--\",\n)\naxes[0].set_xlabel(\"Average_Iage_expected\")\naxes[0].set_ylabel(\"Average_Iage_observed\")\naxes[0].set_title(\"Average_Iage: Expected vs Observed\")\n\n# # Plot for Average_Sage\n# axes[1].scatter(output[\"Average_Sage_expected\"], output[\"Average_Sage_observed\"], c=\"green\")\n# axes[1].plot(\n#     [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()],\n#     [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()],\n#     \"r--\",\n# )\n# axes[1].set_xlabel(\"Average_Sage_expected\")\n# axes[1].set_ylabel(\"Average_Sage_observed\")\n# axes[1].set_title(\"Average_Sage: Expected vs Observed\")\n\n# # Plot for Average_age\n# axes[2].scatter(output[\"Average_age_expected\"], output[\"Average_age_observed\"], c=\"purple\")\n# axes[2].plot(\n#     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],\n#     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],\n#     \"r--\",\n# )\n# axes[2].set_xlabel(\"Average_age_expected\")\n# axes[2].set_ylabel(\"Average_age_observed\")\n# axes[2].set_title(\"Average_age: Expected vs Observed\")\n\nplt.tight_layout()\nplt.show()\n\n# Testing whether the expected and observed values are within 10% of each other\nwithin_10_percent_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"] &lt;= 0.1\n#within_10_percent_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"] &lt;= 0.1\n#within_10_percent_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"] &lt;= 0.1\n# Calculate deviations\ndeviation_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"]\n#deviation_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"]\n#deviation_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"]\n\n# Print average fractional deviation\nprint(f\"Average fractional deviation for Iage: {deviation_Iage.mean()}\")\n#print(f\"Average fractional deviation for Sage: {deviation_Sage.mean()}\")\n#print(f\"Average fractional deviation for age: {deviation_age.mean()}\")\n\n# Print max deviation\nprint(f\"Max deviation for Iage: {deviation_Iage.max()}\")\n#print(f\"Max deviation for Sage: {deviation_Sage.max()}\")\n#print(f\"Max deviation for age: {deviation_age.max()}\")\n\n# Print number of sims &gt;5% and 10% away from expectation\nprint(f\"Number of sims &gt;5% away for Iage: {(deviation_Iage &gt; 0.05).sum()}\")\nprint(f\"Number of sims &gt;10% away for Iage: {(deviation_Iage &gt; 0.1).sum()}\")\n#print(f\"Number of sims &gt;5% away for Sage: {(deviation_Sage &gt; 0.05).sum()}\")\n#print(f\"Number of sims &gt;10% away for Sage: {(deviation_Sage &gt; 0.1).sum()}\")\n#print(f\"Number of sims &gt;5% away for age: {(deviation_age &gt; 0.05).sum()}\")\n#print(f\"Number of sims &gt;10% away for age: {(deviation_age &gt; 0.1).sum()}\")\n</pre> # Plotting the expected and observed values fig, axes = plt.subplots(3, 1, figsize=(10, 15))  # Plot for Average_Iage axes[0].scatter(output[\"Average_Iage_expected\"], output[\"Average_Iage_observed\"], c=\"blue\") axes[0].plot(     [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],     [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],     \"r--\", ) axes[0].set_xlabel(\"Average_Iage_expected\") axes[0].set_ylabel(\"Average_Iage_observed\") axes[0].set_title(\"Average_Iage: Expected vs Observed\")  # # Plot for Average_Sage # axes[1].scatter(output[\"Average_Sage_expected\"], output[\"Average_Sage_observed\"], c=\"green\") # axes[1].plot( #     [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()], #     [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()], #     \"r--\", # ) # axes[1].set_xlabel(\"Average_Sage_expected\") # axes[1].set_ylabel(\"Average_Sage_observed\") # axes[1].set_title(\"Average_Sage: Expected vs Observed\")  # # Plot for Average_age # axes[2].scatter(output[\"Average_age_expected\"], output[\"Average_age_observed\"], c=\"purple\") # axes[2].plot( #     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()], #     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()], #     \"r--\", # ) # axes[2].set_xlabel(\"Average_age_expected\") # axes[2].set_ylabel(\"Average_age_observed\") # axes[2].set_title(\"Average_age: Expected vs Observed\")  plt.tight_layout() plt.show()  # Testing whether the expected and observed values are within 10% of each other within_10_percent_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"] &lt;= 0.1 #within_10_percent_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"] &lt;= 0.1 #within_10_percent_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"] &lt;= 0.1 # Calculate deviations deviation_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"] #deviation_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"] #deviation_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"]  # Print average fractional deviation print(f\"Average fractional deviation for Iage: {deviation_Iage.mean()}\") #print(f\"Average fractional deviation for Sage: {deviation_Sage.mean()}\") #print(f\"Average fractional deviation for age: {deviation_age.mean()}\")  # Print max deviation print(f\"Max deviation for Iage: {deviation_Iage.max()}\") #print(f\"Max deviation for Sage: {deviation_Sage.max()}\") #print(f\"Max deviation for age: {deviation_age.max()}\")  # Print number of sims &gt;5% and 10% away from expectation print(f\"Number of sims &gt;5% away for Iage: {(deviation_Iage &gt; 0.05).sum()}\") print(f\"Number of sims &gt;10% away for Iage: {(deviation_Iage &gt; 0.1).sum()}\") #print(f\"Number of sims &gt;5% away for Sage: {(deviation_Sage &gt; 0.05).sum()}\") #print(f\"Number of sims &gt;10% away for Sage: {(deviation_Sage &gt; 0.1).sum()}\") #print(f\"Number of sims &gt;5% away for age: {(deviation_age &gt; 0.05).sum()}\") #print(f\"Number of sims &gt;10% away for age: {(deviation_age &gt; 0.1).sum()}\") <pre>Average fractional deviation for Iage: 0.005952376697369108\nMax deviation for Iage: 0.013101594653640043\nNumber of sims &gt;5% away for Iage: 0\nNumber of sims &gt;10% away for Iage: 0\n</pre> In\u00a0[10]: Copied! <pre>model.params.beta*90\n</pre> model.params.beta*90 Out[10]: <pre>np.float64(15.019753725016873)</pre> In\u00a0[11]: Copied! <pre>output\n</pre> output Out[11]: cbr R0 Average_Iage_observed Average_Iage_expected Average_Sage_observed Average_Sage_expected Average_age_expected 0 85.982348 11.541424 1.053437 1.050308 NaN NaN NaN 1 78.352124 11.835540 1.113214 1.119952 NaN NaN NaN 2 94.574587 14.153259 0.791026 0.781782 NaN NaN NaN 3 95.824595 11.987251 0.899588 0.911530 NaN NaN NaN 4 81.605498 5.485394 2.335996 2.323656 NaN NaN NaN 5 78.376489 13.295939 0.989437 0.996641 NaN NaN NaN 6 80.480542 12.017599 1.069197 1.074886 NaN NaN NaN 7 72.191892 6.809706 2.101361 2.106522 NaN NaN NaN 8 70.937054 10.929013 1.331440 1.334972 NaN NaN NaN 9 80.181433 9.330705 1.384899 1.389383 NaN NaN NaN 10 86.150877 8.040972 1.497542 1.504704 NaN NaN NaN 11 72.160409 12.836432 1.109104 1.117977 NaN NaN NaN 12 84.019793 12.855215 0.972663 0.964112 NaN NaN NaN 13 97.825868 14.665762 0.729589 0.730484 NaN NaN NaN 14 97.892352 12.669930 0.836221 0.845005 NaN NaN NaN 15 92.044757 9.155130 1.225405 1.240351 NaN NaN NaN 16 97.682221 14.679613 0.726888 0.730819 NaN NaN NaN 17 88.973760 13.513917 0.869642 0.868053 NaN NaN NaN 18 77.201035 8.243124 1.621558 1.631132 NaN NaN NaN 19 83.323379 5.454713 2.274522 2.290385 NaN NaN NaN 20 84.717467 13.458195 0.912957 0.913629 NaN NaN NaN 21 89.337468 11.513124 1.023889 1.014930 NaN NaN NaN 22 74.799681 12.366528 1.120772 1.120902 NaN NaN NaN 23 94.904526 6.048482 1.806037 1.823264 NaN NaN NaN 24 97.274629 14.691271 0.729959 0.733161 NaN NaN NaN"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#average-age-at-infection-in-the-sir-model","title":"Average age at infection in the SIR model\u00b6","text":"<p>Continuing our investigation of the Susceptible-Infected-Recovered model, we will add demographics and investigate the behavior of the model in and around the endemic equilibrium.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\mu N - \\mu S $$</p> <p>$$ \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I - \\mu I $$</p> <p>$$ \\dot{R} = \\gamma I - \\mu R $$</p> <p>Analysis of this system can be found in other sources (ref. Keeling/Rohani).  Setting the derivatives to zero and doing a bit of algebra gets you to the endemic equilbrium</p> <p>$$ (S^*, \\: I^*, \\: R^*) = (\\frac{1}{R_0}, \\:\\: \\frac{\\mu (R_0-1)}{\\beta}, \\: \\: 1-\\frac{1}{R_0} - \\frac{\\mu (R_0-1)}{\\beta}) $$</p> <p>$$ \\text{where} \\:\\: R_0 = \\frac{\\beta}{\\gamma + \\mu} $$</p> <p>An individual susceptible's mean time to infection will then be the inverse of the total force of infection, $\\beta I^*$.</p> <p>$$ \\tau_{S \\rightarrow I} = \\frac{1}{\\mu (R_0 -1)} $$</p> <p>The equation above is often also described as the average age at infection.  However, it is key to remember that the measured age at infection will be censored by non-disease deaths occurring at a rate $\\mu$.  You can work through the impact of this, but in the simple case of constant mortality, it turns out to exactly balance out the $-1$ in the above equation, and so our observed average age at infection will be $\\frac{1}{\\mu R_0}$.  Since the hazard is constant at equilibrium, this implies an exponential distribution:</p> <p>$$P(a | S-&gt;I) \\sim \\mu R_0 e^{-\\mu R_0 a}$$</p> <p>Alternatively, we can correct for the influence of mortality by observing the fraction of children who are susceptible at age A, which necessarily conditions on survival to age A.  This will look like the cumulative distribution of an exponential distributed according to the mean time to infection above:</p> <p>$$P(R | a) \\sim 1 - e^{(-a \\mu (R_0-1))}$$</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#construct-the-model","title":"Construct the model\u00b6","text":"<p>In this notebook, we will reproduce this dependence, and to do so, we will demonstrate how a LASER user can construct new model components on the fly for use with one of the packaged models. First, we note that the SIR model as built here does not actually output the needed information on the age at infection, only the dates of birth and death. The infection event happens in the <code>Transmission</code> step, so we will construct a new derived class (<code>TransmissionWithDOI</code>) to reproduce transmission behavior but also add and record a date of infection property for agents. Second, because this distribution is an equilibrium property of this system, we will build a model component to periodically import new infections, to ensure that infections don't burn out after the initial outbreak, and we are able to establish an endemic equilibrium (we could, instead, opt to initialize the model as near the endemic equilibrium as possible, but it is nicer to show that the model naturally goes there). Finally, we also need to model a large enough population to sustain the infection endemically (this population is known as the Critical Community Size and will be treated in notebook 7). The primary driver of the critical community size is actually not $R_0$ but the duration of infection, so setting the duration of infection to relatively long values ($\\gamma = \\frac {1} {60 \\text {days}}$ ) prevents us from needing huge agent populations. Finally, we construct a single-patch LASER model with five components: <code>VitalDynamics</code>, <code>Susceptibility</code>, <code>TransmissionWithDOI</code>, <code>Infection</code>, and <code>Importation</code>.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test, as always, ensures that certain basic constraints are being obeyed by the model.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#scientific-test","title":"Scientific test\u00b6","text":"<p>The scientific test will sample a set of $(\\mu, \\gamma, R_0)$ tuples and confirm that both the age at infection and the fraction of susceptibles at a given age are well-described by exponential distributions and that the associated rate constant is as expected.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>As always, check that we haven't broken anything - S+I+R = N at all times.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#first-scientific-test-check","title":"First scientific test check\u00b6","text":"<p>As usual, we will test this on a single simulation instance and demonstrate the analysis, before moving on to testing over a range of input values. Here, we are interested in equilibrium behavior, so I first place a cut to exclude all infections that occur before day 10000. We then plot the data, an exponential distribution with the expected value of $\\frac{1}{R_0 \\mu}$, a best-fit exponential distribution to the data, and perform a KS test.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#second-scientific-test-check","title":"Second scientific test check\u00b6","text":"<p>As noted above, because of the censoring that mortality induces, the distributions of age at infection vs. fraction susceptible at a given age will both follow exponential behavior but with a slight difference in the mean of the distribution - for the fraction susceptible, that value will be $\\frac{1}{\\mu (R_0-1)}$.  We develop this second test below.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#third-scientific-test","title":"Third scientific test\u00b6","text":"<p>As long as we are here, let's test that the age distribution of the population is correct.  With constant birth rate, equal to death rate, the population should have exponentially distributed ages with parameter $\\frac{1}{\\mu}$</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#larger-test-suite","title":"Larger test suite\u00b6","text":"<p>OK, so now we are going to replicate the above for many values of $R_0$ and cbr, as a scientific validity test.</p> <p>We choose extremely high birth rates (7-10% per year) and $R_0$ (5-15), to give us systems that should equilibrate relatively quickly and prevent us from having to run for very long times.</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/","title":"Intrinsic periodicity of the SIR system","text":"In\u00a0[1]: Copied! <pre>import math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\n\nimport laser.core\nimport laser.generic\nimport laser.core.distributions as dists\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nfrom laser.generic import SIR\nfrom laser.generic import Model\nfrom laser.generic.utils import ValuesMap\nfrom laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator\nfrom laser.core.utils import grid\n\nfrom scipy.ndimage import gaussian_filter1d\nfrom scipy.signal import find_peaks\n\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import math  import matplotlib.pyplot as plt import numpy as np import pandas as pd from laser.core.propertyset import PropertySet  import laser.core import laser.generic import laser.core.distributions as dists from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator from laser.generic import SIR from laser.generic import Model from laser.generic.utils import ValuesMap from laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator from laser.core.utils import grid  from scipy.ndimage import gaussian_filter1d from scipy.signal import find_peaks   print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\") <pre>np.__version__='2.2.6'\nlaser.core.__version__='0.9.1'\nlaser.generic.__version__='0.0.0'\n</pre> <p>There will be a couple of challenges in testing here. We want to capture enough oscillations to get a stable signal but would also like to limit runtime. So aiming to sample a region in which oscillation periods will be order 1-3 years, so that we get plenty of cycles in a few decade simulation. Second is that there are lots of transient signals so we have to throw out some of the initial data. Lastly, and most importantly - the analysis above does rely on a bit of a linearization around the equilibrium point of the system, but this system is fundamentally a stochastic non-linear oscillator and is subject to lots of fun dynamics that can complicate empirically observing the fundamental periodicity.</p> <p>To ameliorate these, we will: Try to start relatively close to equilibrium values of S, I, R. Use two methods to estimate frequency - \"peak finding\" in the time-domain, and autocorrelation spectrum in the frequency domain. And instead of looking for the period of maximum power, specifically look for a peak in the power spectrum in the vicinity of the expected period.</p> In\u00a0[2]: Copied! <pre>class Importation:\n    def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3):\n        self.model = model\n        self.infdurdist = infdurdist\n        self.infdurmin = infdurmin\n        self.period = period\n        self.count = count\n\n        self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)\n\n        return\n    \n    def step(self, tick: int) -&gt; None:\n        if tick &gt; 0 and tick % self.period == 0:\n            i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]\n            if len(i_susceptible) &gt; 0:\n                count = min(self.count, len(i_susceptible))\n                i_infect = np.random.choice(i_susceptible, size=count, replace=False)\n                self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value\n                samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))\n                samples = np.round(samples)\n                samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)\n                self.model.people.itimer[i_infect] = samples\n                inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)\n                self.model.nodes.S[tick + 1] -= inf_by_node\n                self.model.nodes.I[tick + 1] += inf_by_node\n                self.model.nodes.imports[tick] = inf_by_node\n            # else:\n            #     print(f\"No susceptibles to infect at tick {tick}\")\n\n        return\n</pre> class Importation:     def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3):         self.model = model         self.infdurdist = infdurdist         self.infdurmin = infdurmin         self.period = period         self.count = count          self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)          return          def step(self, tick: int) -&gt; None:         if tick &gt; 0 and tick % self.period == 0:             i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]             if len(i_susceptible) &gt; 0:                 count = min(self.count, len(i_susceptible))                 i_infect = np.random.choice(i_susceptible, size=count, replace=False)                 self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value                 samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))                 samples = np.round(samples)                 samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)                 self.model.people.itimer[i_infect] = samples                 inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)                 self.model.nodes.S[tick + 1] -= inf_by_node                 self.model.nodes.I[tick + 1] += inf_by_node                 self.model.nodes.imports[tick] = inf_by_node             # else:             #     print(f\"No susceptibles to infect at tick {tick}\")          return  In\u00a0[3]: Copied! <pre>pop=2e5\nscenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 1\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\nscenario[\"R\"] = 0\nparameters = PropertySet(\n    {\"seed\": 4, \"nticks\": 365*100, \"verbose\": True, \"beta\": 0.4, \"inf_mean\": 12, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3}\n)\n\n\nbirthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))\ninfdurdist = dists.exponential(scale=parameters.inf_mean)\nrate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators.\nstable_age_dist = np.array(1000*np.exp(-rate_const*np.arange(89)))\npyramid = AliasedDistribution(stable_age_dist)\nsurvival = KaplanMeierEstimator(stable_age_dist.cumsum())\n</pre> pop=2e5 scenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 1 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected scenario[\"R\"] = 0 parameters = PropertySet(     {\"seed\": 4, \"nticks\": 365*100, \"verbose\": True, \"beta\": 0.4, \"inf_mean\": 12, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3} )   birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario)) infdurdist = dists.exponential(scale=parameters.inf_mean) rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators. stable_age_dist = np.array(1000*np.exp(-rate_const*np.arange(89))) pyramid = AliasedDistribution(stable_age_dist) survival = KaplanMeierEstimator(stable_age_dist.cumsum())  In\u00a0[4]: Copied! <pre>model = Model(scenario, parameters, birthrates=birthrate_map)\n\nmodel.components = [\n    SIR.Susceptible(model),\n    SIR.Recovered(model),\n    SIR.Infectious(model, infdurdist),\n    Importation(model, infdurdist),\n    SIR.Transmission(model, infdurdist),\n    BirthsByCBR(model, birthrate_map, pyramid),\n    MortalityByEstimator(model, estimator=survival),\n]\n\nmodel.run()\n\nplt.plot(model.nodes.S, color=\"blue\")\nplt.plot(model.nodes.I, color=\"red\")\nplt.plot(model.nodes.R, color=\"green\")\nplt.plot(model.nodes.S+model.nodes.I+model.nodes.R, color=\"black\")\nplt.legend([\"S\", \"I\", \"R\", \"N\"])\nplt.show()\n</pre> model = Model(scenario, parameters, birthrates=birthrate_map)  model.components = [     SIR.Susceptible(model),     SIR.Recovered(model),     SIR.Infectious(model, infdurdist),     Importation(model, infdurdist),     SIR.Transmission(model, infdurdist),     BirthsByCBR(model, birthrate_map, pyramid),     MortalityByEstimator(model, estimator=survival), ]  model.run()  plt.plot(model.nodes.S, color=\"blue\") plt.plot(model.nodes.I, color=\"red\") plt.plot(model.nodes.R, color=\"green\") plt.plot(model.nodes.S+model.nodes.I+model.nodes.R, color=\"black\") plt.legend([\"S\", \"I\", \"R\", \"N\"]) plt.show() <pre>200,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:35&lt;00:00, 1024.63it/s]\n</pre> In\u00a0[5]: Copied! <pre>mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\nR0 = model.params.beta / (1 / model.params.inf_mean + mu)\nA = 1 / ((R0 - 1) * mu) / 365\nG = 1 / (mu + 1 / model.params.inf_mean) / 365\nT_exp = 2 * np.pi * np.sqrt(A * G)\n\n\ndef ID_freq_peakfinder(y0, T_exp, cutoff=18250, plot=False):\n    y = y0[cutoff:]\n    y = y - np.mean(y)\n    y = gaussian_filter1d(y, sigma=50)\n    peaks, _ = find_peaks(y, distance=T_exp * 365 / 2)\n    peaks2, _ = find_peaks(-1*y, distance=T_exp * 365 / 2)\n    if plot:\n        plt.figure()\n        plt.plot(y, 'b-', lw=1)\n        plt.plot(peaks, y[peaks], \"rx\")\n        plt.plot(peaks2, y[peaks2], \"kx\")\n    return np.median(np.diff(peaks)) / 365, np.median(np.diff(peaks2)) / 365\n\n\nT_obs_pf, T_obs_pf2 = ID_freq_peakfinder(np.squeeze(model.nodes.I), T_exp, plot=True)\n\n\ndef ID_freq_autocorr(y0, cutoff=18250):\n    # Compute the FFT\n    Y1 = np.fft.fft(y0[cutoff:] - np.mean(y0[cutoff:]))\n\n    # Compute the circular autocorrelation using the inverse FFT\n    circular_autocorr = np.fft.ifft(Y1 * np.conj(Y1)).real\n    # Plot only the positive frequency spectrum\n    peaks, _ = find_peaks(circular_autocorr, distance=300)\n    return peaks[0] / 365\n\n\nT_obs_fft = ID_freq_autocorr(np.squeeze(model.nodes.I))\n\nplt.text(0.5, 0.99, f\"T expected: {T_exp:.2f} y\", transform=plt.gca().transAxes)\nplt.text(0.5, 0.95, f\"T observed, peakfinding: {T_obs_pf:.2f} y\", transform=plt.gca().transAxes)\nplt.text(0.5, 0.91, f\"T observed, valley-finding : {T_obs_pf:.2f} y\", transform=plt.gca().transAxes)\nplt.text(0.5, 0.87, f\"T observed, FFT: {T_obs_fft:.2f} y\", transform=plt.gca().transAxes)\nplt.gca().spines['top'].set_visible(False)\nplt.show()\n</pre> mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1 R0 = model.params.beta / (1 / model.params.inf_mean + mu) A = 1 / ((R0 - 1) * mu) / 365 G = 1 / (mu + 1 / model.params.inf_mean) / 365 T_exp = 2 * np.pi * np.sqrt(A * G)   def ID_freq_peakfinder(y0, T_exp, cutoff=18250, plot=False):     y = y0[cutoff:]     y = y - np.mean(y)     y = gaussian_filter1d(y, sigma=50)     peaks, _ = find_peaks(y, distance=T_exp * 365 / 2)     peaks2, _ = find_peaks(-1*y, distance=T_exp * 365 / 2)     if plot:         plt.figure()         plt.plot(y, 'b-', lw=1)         plt.plot(peaks, y[peaks], \"rx\")         plt.plot(peaks2, y[peaks2], \"kx\")     return np.median(np.diff(peaks)) / 365, np.median(np.diff(peaks2)) / 365   T_obs_pf, T_obs_pf2 = ID_freq_peakfinder(np.squeeze(model.nodes.I), T_exp, plot=True)   def ID_freq_autocorr(y0, cutoff=18250):     # Compute the FFT     Y1 = np.fft.fft(y0[cutoff:] - np.mean(y0[cutoff:]))      # Compute the circular autocorrelation using the inverse FFT     circular_autocorr = np.fft.ifft(Y1 * np.conj(Y1)).real     # Plot only the positive frequency spectrum     peaks, _ = find_peaks(circular_autocorr, distance=300)     return peaks[0] / 365   T_obs_fft = ID_freq_autocorr(np.squeeze(model.nodes.I))  plt.text(0.5, 0.99, f\"T expected: {T_exp:.2f} y\", transform=plt.gca().transAxes) plt.text(0.5, 0.95, f\"T observed, peakfinding: {T_obs_pf:.2f} y\", transform=plt.gca().transAxes) plt.text(0.5, 0.91, f\"T observed, valley-finding : {T_obs_pf:.2f} y\", transform=plt.gca().transAxes) plt.text(0.5, 0.87, f\"T observed, FFT: {T_obs_fft:.2f} y\", transform=plt.gca().transAxes) plt.gca().spines['top'].set_visible(False) plt.show() In\u00a0[6]: Copied! <pre>nsims = 10\nnticks = 36500\ncbrs = 70 + 30 * np.random.rand(nsims)\ninf_means = 50 + 50 * np.random.rand(nsims)\nR0s = 5 + 10 * np.random.rand(nsims)\nmu = [((1 + cbr / 1000) ** (1 / 365) - 1) for cbr in cbrs]\nA = [1 / ((R0 - 1) * mu) / 365 for R0, mu in zip(R0s, mu)]\nG = [1 / (mu + 1 / inf_mean) / 365 for mu, inf_mean in zip(mu, inf_means)]\nT_exp = [2 * math.pi * np.sqrt(A * G) for A, G in zip(A, G)]\nmycases = np.zeros((nsims, nticks))\nparams_df = pd.DataFrame(\n    {\n        \"cbr\": cbrs,\n        \"inf_mean\": inf_means,\n        \"R0\": R0s,\n        \"A\": A,\n        \"G\": G,\n        \"T_exp\": T_exp,\n        \"mu\": mu,\n    }\n)\n\npop=2e5\ninitial_infected = 1\nmycases = np.zeros((nsims, nticks+1))\n</pre> nsims = 10 nticks = 36500 cbrs = 70 + 30 * np.random.rand(nsims) inf_means = 50 + 50 * np.random.rand(nsims) R0s = 5 + 10 * np.random.rand(nsims) mu = [((1 + cbr / 1000) ** (1 / 365) - 1) for cbr in cbrs] A = [1 / ((R0 - 1) * mu) / 365 for R0, mu in zip(R0s, mu)] G = [1 / (mu + 1 / inf_mean) / 365 for mu, inf_mean in zip(mu, inf_means)] T_exp = [2 * math.pi * np.sqrt(A * G) for A, G in zip(A, G)] mycases = np.zeros((nsims, nticks)) params_df = pd.DataFrame(     {         \"cbr\": cbrs,         \"inf_mean\": inf_means,         \"R0\": R0s,         \"A\": A,         \"G\": G,         \"T_exp\": T_exp,         \"mu\": mu,     } )  pop=2e5 initial_infected = 1 mycases = np.zeros((nsims, nticks+1))  In\u00a0[7]: Copied! <pre>params_df\n</pre> params_df Out[7]: cbr inf_mean R0 A G T_exp mu 0 91.930983 62.254472 14.072421 0.869696 0.168039 2.401977 0.000241 1 90.884256 74.406422 10.701467 1.184809 0.200301 3.060874 0.000238 2 73.702560 68.962034 5.772357 2.946291 0.186432 4.656696 0.000195 3 75.019508 50.755062 10.059807 1.525691 0.137670 2.879605 0.000198 4 76.882418 50.648404 11.988046 1.228547 0.137351 2.581021 0.000203 5 73.679016 74.924584 10.868083 1.425312 0.202320 3.374071 0.000195 6 70.720934 92.910228 8.861059 1.861457 0.250196 4.287921 0.000187 7 86.677990 78.410540 10.893828 1.215774 0.211054 3.182755 0.000228 8 93.607440 58.109627 9.839757 1.264072 0.156968 2.798796 0.000245 9 95.751173 57.784105 10.887793 1.105884 0.156053 2.610183 0.000251 In\u00a0[\u00a0]: Copied! <pre>for i in range(nsims):\n    row = params_df.iloc[i]\n    scenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\n    parameters = PropertySet(\n        {\"seed\": 42+i, \n         \"nticks\": 365*100, \n         \"verbose\": True, \n         \"beta\": row[\"R0\"] * (row[\"mu\"] + 1 / row[\"inf_mean\"]), \n         \"inf_mean\": row[\"inf_mean\"], \n         \"cbr\": row[\"cbr\"], \n         \"importation_period\": 180, \n         \"importation_count\": 3}\n    )\n\n    scenario[\"I\"] = initial_infected\n    scenario[\"R\"] = np.round(pop * (1 / row[\"R0\"])).astype(np.int32)\n    scenario[\"S\"] = scenario.population - scenario[\"I\"] - scenario[\"R\"]\n\n    birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))\n    model = Model(scenario, parameters, birthrates=birthrate_map)\n    infdurdist = dists.exponential(scale=parameters.inf_mean)\n    rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators.\n    pyramid = AliasedDistribution(stable_age_dist := np.array(1000*np.exp(-rate_const*np.arange(89))))\n    survival = KaplanMeierEstimator(stable_age_dist.cumsum())\n    \n    model.components = [\n        SIR.Susceptible(model),\n        SIR.Recovered(model),\n        SIR.Infectious(model, infdurdist),\n        Importation(model, infdurdist),\n        SIR.Transmission(model, infdurdist),\n        BirthsByCBR(model, birthrate_map, pyramid),\n        MortalityByEstimator(model, estimator=survival),\n    ]\n\n    model.run(f\"{i+1:2}/{nsims} simulations\")\n    mycases[i, :] = np.squeeze(model.nodes.I)\n</pre> for i in range(nsims):     row = params_df.iloc[i]     scenario = grid(M=1, N=1, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)     parameters = PropertySet(         {\"seed\": 42+i,           \"nticks\": 365*100,           \"verbose\": True,           \"beta\": row[\"R0\"] * (row[\"mu\"] + 1 / row[\"inf_mean\"]),           \"inf_mean\": row[\"inf_mean\"],           \"cbr\": row[\"cbr\"],           \"importation_period\": 180,           \"importation_count\": 3}     )      scenario[\"I\"] = initial_infected     scenario[\"R\"] = np.round(pop * (1 / row[\"R0\"])).astype(np.int32)     scenario[\"S\"] = scenario.population - scenario[\"I\"] - scenario[\"R\"]      birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))     model = Model(scenario, parameters, birthrates=birthrate_map)     infdurdist = dists.exponential(scale=parameters.inf_mean)     rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators.     pyramid = AliasedDistribution(stable_age_dist := np.array(1000*np.exp(-rate_const*np.arange(89))))     survival = KaplanMeierEstimator(stable_age_dist.cumsum())          model.components = [         SIR.Susceptible(model),         SIR.Recovered(model),         SIR.Infectious(model, infdurdist),         Importation(model, infdurdist),         SIR.Transmission(model, infdurdist),         BirthsByCBR(model, birthrate_map, pyramid),         MortalityByEstimator(model, estimator=survival),     ]      model.run(f\"{i+1:2}/{nsims} simulations\")     mycases[i, :] = np.squeeze(model.nodes.I) <pre>1/10 simulations: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:31&lt;00:00, 1148.70it/s]\n2/10 simulations: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:32&lt;00:00, 1113.76it/s]\n3/10 simulations: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:34&lt;00:00, 1062.37it/s]\n4/10 simulations: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:32&lt;00:00, 1108.66it/s]\n5/10 simulations: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:31&lt;00:00, 1143.59it/s]\n6/10 simulations: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:31&lt;00:00, 1141.83it/s]\n7/10 simulations: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:32&lt;00:00, 1140.14it/s]\n8/10 simulations: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:31&lt;00:00, 1149.11it/s]\n9/10 simulations: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:32&lt;00:00, 1117.45it/s]\n10/10 simulations: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 36500/36500 [00:33&lt;00:00, 1088.11it/s]\n</pre> In\u00a0[9]: Copied! <pre>params_df[\"T_obs_peakfinder1\"] = np.nan\nparams_df[\"T_obs_peakfinder2\"] = np.nan\nparams_df[\"T_obs_autocorr\"] = np.nan\n\nfor i in range(mycases.shape[0]):\n    #plt.plot(mycases[i, :])\n    pf1, pf2 = ID_freq_peakfinder(np.squeeze(mycases[i, :]), params_df.loc[i, \"T_exp\"], plot=True)\n    params_df.loc[i, \"T_obs_peakfinder1\"] = pf1\n    params_df.loc[i, \"T_obs_peakfinder2\"] = pf2\n    params_df.loc[i, \"T_obs_autocorr\"] = ID_freq_autocorr(np.squeeze(mycases[i, :]))\n    plt.text(0.5, 0.99, f\"T expected: {params_df.loc[i, 'T_exp']:.2f} y\", transform=plt.gca().transAxes)\n    plt.text(0.5, 0.95, f\"T observed, peakfinding: {params_df.loc[i, 'T_obs_peakfinder1']:.2f} y\", transform=plt.gca().transAxes)\n    plt.text(0.5, 0.91, f\"T observed, valleyfinding: {params_df.loc[i, 'T_obs_peakfinder2']:.2f} y\", transform=plt.gca().transAxes)\n    plt.text(0.5, 0.87, f\"T observed, FFT: {params_df.loc[i, 'T_obs_autocorr']:.2f} y\", transform=plt.gca().transAxes)\n    plt.gca().spines['top'].set_visible(False)\n\n    plt.show()\n</pre> params_df[\"T_obs_peakfinder1\"] = np.nan params_df[\"T_obs_peakfinder2\"] = np.nan params_df[\"T_obs_autocorr\"] = np.nan  for i in range(mycases.shape[0]):     #plt.plot(mycases[i, :])     pf1, pf2 = ID_freq_peakfinder(np.squeeze(mycases[i, :]), params_df.loc[i, \"T_exp\"], plot=True)     params_df.loc[i, \"T_obs_peakfinder1\"] = pf1     params_df.loc[i, \"T_obs_peakfinder2\"] = pf2     params_df.loc[i, \"T_obs_autocorr\"] = ID_freq_autocorr(np.squeeze(mycases[i, :]))     plt.text(0.5, 0.99, f\"T expected: {params_df.loc[i, 'T_exp']:.2f} y\", transform=plt.gca().transAxes)     plt.text(0.5, 0.95, f\"T observed, peakfinding: {params_df.loc[i, 'T_obs_peakfinder1']:.2f} y\", transform=plt.gca().transAxes)     plt.text(0.5, 0.91, f\"T observed, valleyfinding: {params_df.loc[i, 'T_obs_peakfinder2']:.2f} y\", transform=plt.gca().transAxes)     plt.text(0.5, 0.87, f\"T observed, FFT: {params_df.loc[i, 'T_obs_autocorr']:.2f} y\", transform=plt.gca().transAxes)     plt.gca().spines['top'].set_visible(False)      plt.show()  In\u00a0[10]: Copied! <pre>params_df\n</pre> params_df  Out[10]: cbr inf_mean R0 A G T_exp mu T_obs_peakfinder1 T_obs_peakfinder2 T_obs_autocorr 0 91.930983 62.254472 14.072421 0.869696 0.168039 2.401977 0.000241 2.013699 2.191781 1.153425 1 90.884256 74.406422 10.701467 1.184809 0.200301 3.060874 0.000238 2.547945 2.189041 2.926027 2 73.702560 68.962034 5.772357 2.946291 0.186432 4.656696 0.000195 3.589041 3.449315 4.200000 3 75.019508 50.755062 10.059807 1.525691 0.137670 2.879605 0.000198 2.568493 2.438356 2.895890 4 76.882418 50.648404 11.988046 1.228547 0.137351 2.581021 0.000203 2.172603 2.298630 2.397260 5 73.679016 74.924584 10.868083 1.425312 0.202320 3.374071 0.000195 3.041096 2.939726 1.561644 6 70.720934 92.910228 8.861059 1.861457 0.250196 4.287921 0.000187 3.821918 3.102740 4.087671 7 86.677990 78.410540 10.893828 1.215774 0.211054 3.182755 0.000228 2.501370 2.497260 1.375342 8 93.607440 58.109627 9.839757 1.264072 0.156968 2.798796 0.000245 2.335616 2.408219 2.797260 9 95.751173 57.784105 10.887793 1.105884 0.156053 2.610183 0.000251 1.997260 2.358904 2.326027 In\u00a0[11]: Copied! <pre>plt.plot(params_df[\"T_exp\"], params_df[\"T_obs_peakfinder1\"], \"o\")\nplt.plot(params_df[\"T_exp\"], params_df[\"T_obs_peakfinder2\"], \"o\")\nplt.plot(params_df[\"T_exp\"], params_df[\"T_obs_autocorr\"], \"rx\")\nplt.plot([1, 4], [1, 4], \"k--\")\nplt.show()\n</pre> plt.plot(params_df[\"T_exp\"], params_df[\"T_obs_peakfinder1\"], \"o\") plt.plot(params_df[\"T_exp\"], params_df[\"T_obs_peakfinder2\"], \"o\") plt.plot(params_df[\"T_exp\"], params_df[\"T_obs_autocorr\"], \"rx\") plt.plot([1, 4], [1, 4], \"k--\") plt.show()"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#intrinsic-periodicity-of-the-sir-system","title":"Intrinsic periodicity of the SIR system\u00b6","text":"<p>Continuing our investigation of the Susceptible-Infected-Recovered system,</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\mu N - \\mu S $$</p> <p>$$ \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I - \\mu I $$</p> <p>$$ \\dot{R} = \\gamma I - \\mu R $$</p> <p>With non-trivial endemic equilbrium</p> <p>$$ (S^*, \\: I^*, \\: R^*) = (\\frac{1}{R_0}, \\:\\: \\frac{\\mu (R_0-1)}{\\beta}, \\: \\: 1-\\frac{1}{R_0} - \\frac{\\mu (R_0-1)}{\\beta}) $$</p> <p>$$ \\text{where} \\:\\: R_0 = \\frac{\\beta}{\\gamma + \\mu} $$</p> <p>General analysis of a system's stability of and approach to equilibria is beyond the scope of this notebook, and detailed discussions are available elsewhere (e.g., Keeling/Rohani Box 2.4).  In brief, one constructs the Jacobian of the system at the equilibrium points and computes its eigenvalues.  If all eigenvalues have negative real component, then the equilibrium is stable; if the dominant eigenvalues are complex conjugates, then system approaches equilibrium via damped oscillations, with damping constant equal to the real component and frequency equal to the imaginary component. This is the case for the SIR system around the non-trivial ($R_0 \\gt 1$) equilibrium, with dominant eigenvalues:</p> <p>$$ \\Lambda = -\\frac{\\mu R_0}{2} \\pm \\frac{\\sqrt{\\mu^2 R_0^2 - \\frac{4}{A G}}}{2} $$</p> <p>$$ \\text{where} \\:\\: A = \\frac{1}{\\mu (R_0 -1)} and G = \\frac{1}{\\mu + \\gamma} $$</p> <p>In general, $\\mu^2 R_0^2$ is quite small, and the intrinsic periodicity of the system is $T \\approx 2 \\pi \\sqrt{A G}$.</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#construct-the-model","title":"Construct the model\u00b6","text":"<p>The model is contructed as in notebook 05, though we will not record date of infection here. As again, we are looking at behavior around the endemic equilibrium, the same considerations of large-ish populations and long simulations apply here.</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test, as always, ensures that certain basic constraints are being obeyed by the model.</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#scientific-test","title":"Scientific test\u00b6","text":"<p>The scientific test will sample a set of $(\\mu, \\gamma, R_0)$ tuplets and confirm that the periodicity is as expected.</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#future-work","title":"Future work\u00b6","text":"<p>The addition of an exposed compartment with rate constant $\\sigma$ should change this result, by changing the generation time $G$ to $\\frac{1}{\\mu + \\gamma} + \\frac{1}{\\mu + \\sigma}$</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>As always, check that we haven't broken anything - S+I+R = N at all times, stocks track flows (need to have deaths by state to do this right).</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#larger-test-suite","title":"Larger test suite\u00b6","text":"<p>OK, so now we are going to replicate the above test for many values of R0 and cbr, as a scientific validity test.</p> <p>This takes 5+ minutes.</p>"},{"location":"tutorials/notebooks/07_SIR_CCS/","title":"Exploring the critical community size of an SIR model","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nimport laser.core.distributions as dists\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nfrom laser.generic import SIR\nfrom laser.generic import Model\nfrom laser.generic.utils import ValuesMap\nfrom laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator\nfrom laser.core.utils import grid\nimport laser.core\nimport laser.generic\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import fsolve\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> from pathlib import Path  import numpy as np import pandas as pd from laser.core.propertyset import PropertySet import laser.core.distributions as dists from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator from laser.generic import SIR from laser.generic import Model from laser.generic.utils import ValuesMap from laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator from laser.core.utils import grid import laser.core import laser.generic import matplotlib.pyplot as plt from scipy.optimize import fsolve  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.5'\nlaser.core.__version__='1.0.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>class Importation_EachNode:\n    def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3, duration: int = 20*365):\n        self.model = model\n        self.infdurdist = infdurdist\n        self.infdurmin = infdurmin\n        self.period = period\n        self.count = count\n        self.duration = duration\n\n        self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)\n\n        return\n    \n    def step(self, tick: int) -&gt; None:\n        if tick &gt; 0 and tick % self.period == 0 and tick &lt; self.duration:\n            i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]\n            n_susceptible = self.model.people.nodeid[i_susceptible]\n            for node in np.unique(self.model.people.nodeid):\n                these_susceptibles = i_susceptible[n_susceptible==node]\n                if len(these_susceptibles) &gt; 0:\n                    count = min(self.count, len(these_susceptibles))\n                    i_infect = np.random.choice(these_susceptibles, size=count, replace=False)\n                    self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value\n                    samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))\n                    samples = np.round(samples)\n                    samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)\n                    self.model.people.itimer[i_infect] = samples\n                    self.model.nodes.S[tick + 1, node] -= count\n                    self.model.nodes.I[tick + 1, node] += count\n                    self.model.nodes.imports[tick, node] = count\n            # else:\n            #     print(f\"No susceptibles to infect at tick {tick}\")\n\n        return\n</pre> class Importation_EachNode:     def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3, duration: int = 20*365):         self.model = model         self.infdurdist = infdurdist         self.infdurmin = infdurmin         self.period = period         self.count = count         self.duration = duration          self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)          return          def step(self, tick: int) -&gt; None:         if tick &gt; 0 and tick % self.period == 0 and tick &lt; self.duration:             i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]             n_susceptible = self.model.people.nodeid[i_susceptible]             for node in np.unique(self.model.people.nodeid):                 these_susceptibles = i_susceptible[n_susceptible==node]                 if len(these_susceptibles) &gt; 0:                     count = min(self.count, len(these_susceptibles))                     i_infect = np.random.choice(these_susceptibles, size=count, replace=False)                     self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value                     samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))                     samples = np.round(samples)                     samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)                     self.model.people.itimer[i_infect] = samples                     self.model.nodes.S[tick + 1, node] -= count                     self.model.nodes.I[tick + 1, node] += count                     self.model.nodes.imports[tick, node] = count             # else:             #     print(f\"No susceptibles to infect at tick {tick}\")          return In\u00a0[3]: Copied! <pre>run_sims = False\nanalyze_sims = True\n</pre> run_sims = False analyze_sims = True In\u00a0[4]: Copied! <pre>npatches = 61\nscenario = grid(M=1, N=npatches, population_fn=lambda x,y: np.ceil(10**(3 + y*(3/(npatches-1)))).astype(np.uint32), origin_x=0, origin_y=0)\ninitial_infected = 3\nnticks = 40 * 365\nnsims = 200\ni = 0\nstart_from_last = False\noutputs = None\n\nif run_sims:\n\n    i = 0\n\n    if start_from_last:  #If we are resuming from a stopped previous run\n\n        outputs =np.load(Path(\"outputs\") / \"CCS_outputs.npy\")\n        while i &lt; outputs.shape[0] and np.any(outputs[i]):\n            i += 1\n        R0_samples = np.load(Path(\"outputs\") / \"CCS_parameter_samples.npy\")[0, :]\n        infmean_samples = np.load(Path(\"outputs\") / \"CCS_parameter_samples.npy\")[1, :]\n        cbr_samples = np.load(Path(\"outputs\") / \"CCS_parameter_samples.npy\")[2, :]\n\n    else:\n        \n        R0_samples = np.random.uniform(1.05, 2.5, nsims)**3\n        infmean_samples = 5 + np.random.gamma(2, 10, nsims)\n        cbr_samples = 10 + np.random.gamma(2, 20, nsims)\n        cbr_samples = np.clip(cbr_samples, 10, 100)\n        np.save(Path(\"outputs\") / \"CCS_parameter_samples.npy\", np.vstack([R0_samples, infmean_samples, cbr_samples]))\n        outputs = np.zeros((nsims, nticks+1, npatches), dtype=np.uint32)\n    \n    while i &lt; nsims:\n\n        R0 = R0_samples[i]\n        infmean = infmean_samples[i]\n        cbr = cbr_samples[i]\n        print(f\"Running simulation {i+1}/{nsims} with R0={R0:.2f}, infmean={infmean:.2f}, cbr={cbr:.2f}\")\n\n        scenario[\"I\"] = initial_infected\n        scenario[\"R\"] = np.floor(scenario.population * (R0-1)/ R0).astype(np.uint32)\n        scenario[\"S\"] = scenario.population - scenario[\"I\"] - scenario[\"R\"]\n\n        parameters = PropertySet(\n            {\n                \"seed\": np.random.randint(0, 1000000),\n                \"nticks\": nticks,\n                \"verbose\": True,\n                \"beta\": R0 / infmean,\n                \"inf_mean\": infmean,\n                \"cbr\": cbr,\n                \"importation_period\": 180,\n                \"importation_count\": 3,\n                \"importation_end\": 20 * 365,\n            }\n        )\n\n        birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))\n        infdurdist = dists.exponential(scale=parameters.inf_mean)\n        rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators.\n        stable_age_dist = np.array(1000*np.exp(-rate_const*np.arange(89)))\n        pyramid = AliasedDistribution(stable_age_dist)\n        survival = KaplanMeierEstimator(stable_age_dist.cumsum())\n        model = Model(scenario, parameters, birthrates=birthrate_map.values)\n        model.network = 0*model.network\n        model.components = [\n            SIR.Susceptible(model),\n            SIR.Recovered(model),\n            SIR.Infectious(model, infdurdist),\n            Importation_EachNode(model, infdurdist, period=parameters.importation_period, count=parameters.importation_count, duration=parameters.importation_end),\n            SIR.Transmission(model, infdurdist),\n            BirthsByCBR(model, birthrate_map.values, pyramid),\n            MortalityByEstimator(model, estimator=survival),        \n        ]\n        model.run()\n        outputs[i, :, :] = model.nodes.I\n        Path(\"outputs\").mkdir(exist_ok=True)\n        np.save(Path(\"outputs\") / \"CCS_outputs.npy\", outputs)\n        i+=1\n</pre> npatches = 61 scenario = grid(M=1, N=npatches, population_fn=lambda x,y: np.ceil(10**(3 + y*(3/(npatches-1)))).astype(np.uint32), origin_x=0, origin_y=0) initial_infected = 3 nticks = 40 * 365 nsims = 200 i = 0 start_from_last = False outputs = None  if run_sims:      i = 0      if start_from_last:  #If we are resuming from a stopped previous run          outputs =np.load(Path(\"outputs\") / \"CCS_outputs.npy\")         while i &lt; outputs.shape[0] and np.any(outputs[i]):             i += 1         R0_samples = np.load(Path(\"outputs\") / \"CCS_parameter_samples.npy\")[0, :]         infmean_samples = np.load(Path(\"outputs\") / \"CCS_parameter_samples.npy\")[1, :]         cbr_samples = np.load(Path(\"outputs\") / \"CCS_parameter_samples.npy\")[2, :]      else:                  R0_samples = np.random.uniform(1.05, 2.5, nsims)**3         infmean_samples = 5 + np.random.gamma(2, 10, nsims)         cbr_samples = 10 + np.random.gamma(2, 20, nsims)         cbr_samples = np.clip(cbr_samples, 10, 100)         np.save(Path(\"outputs\") / \"CCS_parameter_samples.npy\", np.vstack([R0_samples, infmean_samples, cbr_samples]))         outputs = np.zeros((nsims, nticks+1, npatches), dtype=np.uint32)          while i &lt; nsims:          R0 = R0_samples[i]         infmean = infmean_samples[i]         cbr = cbr_samples[i]         print(f\"Running simulation {i+1}/{nsims} with R0={R0:.2f}, infmean={infmean:.2f}, cbr={cbr:.2f}\")          scenario[\"I\"] = initial_infected         scenario[\"R\"] = np.floor(scenario.population * (R0-1)/ R0).astype(np.uint32)         scenario[\"S\"] = scenario.population - scenario[\"I\"] - scenario[\"R\"]          parameters = PropertySet(             {                 \"seed\": np.random.randint(0, 1000000),                 \"nticks\": nticks,                 \"verbose\": True,                 \"beta\": R0 / infmean,                 \"inf_mean\": infmean,                 \"cbr\": cbr,                 \"importation_period\": 180,                 \"importation_count\": 3,                 \"importation_end\": 20 * 365,             }         )          birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))         infdurdist = dists.exponential(scale=parameters.inf_mean)         rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators.         stable_age_dist = np.array(1000*np.exp(-rate_const*np.arange(89)))         pyramid = AliasedDistribution(stable_age_dist)         survival = KaplanMeierEstimator(stable_age_dist.cumsum())         model = Model(scenario, parameters, birthrates=birthrate_map.values)         model.network = 0*model.network         model.components = [             SIR.Susceptible(model),             SIR.Recovered(model),             SIR.Infectious(model, infdurdist),             Importation_EachNode(model, infdurdist, period=parameters.importation_period, count=parameters.importation_count, duration=parameters.importation_end),             SIR.Transmission(model, infdurdist),             BirthsByCBR(model, birthrate_map.values, pyramid),             MortalityByEstimator(model, estimator=survival),                 ]         model.run()         outputs[i, :, :] = model.nodes.I         Path(\"outputs\").mkdir(exist_ok=True)         np.save(Path(\"outputs\") / \"CCS_outputs.npy\", outputs)         i+=1  In\u00a0[5]: Copied! <pre>if analyze_sims:\n\n    outputs_file = Path(\"outputs\") / \"CCS_outputs.npy\"\n    param_samples_file = Path(\"outputs\") / \"CCS_parameter_samples.npy\"\n    if outputs_file.exists() and param_samples_file.exists():\n        outputs = np.load(outputs_file)\n        parameter_samples = np.load(param_samples_file)\n        R0_samples = parameter_samples[0, :]\n        infmean_samples = parameter_samples[1, :]\n        cbr_samples = parameter_samples[2, :]\n        params_df = pd.DataFrame({\n            \"R0\": R0_samples,\n            \"infmean\": infmean_samples,\n            \"cbr\": cbr_samples,\n        })\n        params_df['mu'] = (1 + params_df['cbr'] / 1000) ** (1 / 365) - 1\n        params_df['alpha'] = (1 / params_df['infmean'] + params_df['mu'])/params_df['mu']\n        nsims, nticks, npatches = outputs.shape\n\n        pops = np.array(scenario.population)\n        plt.imshow(np.log10(outputs[0, :, :].T / pops[:, np.newaxis]), aspect=\"auto\", origin=\"lower\")\n        plt.colorbar(label=\"Cases\")\n        plt.xlabel(\"Time (days)\")\n        plt.ylabel(\"Patch population\")\n        plt.yticks(range(0, npatches, 10), pops[::10])\n        plt.title(\"Infections over time in patches of different population\")\n        plt.show()\n\nelse:\n\n    print(\"outputs and/or parameter samples files missing. Need to re-run simulations?\")\n</pre> if analyze_sims:      outputs_file = Path(\"outputs\") / \"CCS_outputs.npy\"     param_samples_file = Path(\"outputs\") / \"CCS_parameter_samples.npy\"     if outputs_file.exists() and param_samples_file.exists():         outputs = np.load(outputs_file)         parameter_samples = np.load(param_samples_file)         R0_samples = parameter_samples[0, :]         infmean_samples = parameter_samples[1, :]         cbr_samples = parameter_samples[2, :]         params_df = pd.DataFrame({             \"R0\": R0_samples,             \"infmean\": infmean_samples,             \"cbr\": cbr_samples,         })         params_df['mu'] = (1 + params_df['cbr'] / 1000) ** (1 / 365) - 1         params_df['alpha'] = (1 / params_df['infmean'] + params_df['mu'])/params_df['mu']         nsims, nticks, npatches = outputs.shape          pops = np.array(scenario.population)         plt.imshow(np.log10(outputs[0, :, :].T / pops[:, np.newaxis]), aspect=\"auto\", origin=\"lower\")         plt.colorbar(label=\"Cases\")         plt.xlabel(\"Time (days)\")         plt.ylabel(\"Patch population\")         plt.yticks(range(0, npatches, 10), pops[::10])         plt.title(\"Infections over time in patches of different population\")         plt.show()  else:      print(\"outputs and/or parameter samples files missing. Need to re-run simulations?\") <pre>/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_72224/2173563150.py:18: RuntimeWarning: divide by zero encountered in log10\n  plt.imshow(np.log10(outputs[0, :, :].T / pops[:, np.newaxis]), aspect=\"auto\", origin=\"lower\")\n</pre> In\u00a0[6]: Copied! <pre>if outputs is not None:\n\n    CCS_est = []\n\n    for sim in range(nsims):\n        end_output = outputs[sim, -1, :]\n        nonzero_pops = pops[end_output != 0]\n        if len(nonzero_pops) &gt; 0:\n            CCS_est.append(np.min(nonzero_pops))\n        else:\n            CCS_est.append(np.max(pops))\n\n    results_df = pd.DataFrame({\"CCS_est\": CCS_est})\n\n    print(results_df)\n\nelse:\n    results_df = None\n    print(\"No simulation outputs found for analysis.\")\n</pre> if outputs is not None:      CCS_est = []      for sim in range(nsims):         end_output = outputs[sim, -1, :]         nonzero_pops = pops[end_output != 0]         if len(nonzero_pops) &gt; 0:             CCS_est.append(np.min(nonzero_pops))         else:             CCS_est.append(np.max(pops))      results_df = pd.DataFrame({\"CCS_est\": CCS_est})      print(results_df)  else:     results_df = None     print(\"No simulation outputs found for analysis.\") <pre>     CCS_est\n0     398108\n1      14126\n2     112202\n3      35482\n4      63096\n..       ...\n195   707946\n196  1000000\n197   177828\n198    10000\n199    50119\n\n[200 rows x 1 columns]\n</pre> In\u00a0[7]: Copied! <pre>if results_df is not None:\n\n    fig, axs = plt.subplots(2, 1, figsize=(15, 15))\n\n    # Plot smallest_nonzero_pop against R0, colored by log10(alpha)\n    sc3 = axs[0].scatter(params_df[\"R0\"], results_df[\"CCS_est\"], c=np.log10(params_df[\"alpha\"]), cmap=\"viridis\")\n    axs[0].set_xlabel(\"R0\")\n    cbar1 = fig.colorbar(sc3, ax=axs[0])\n    cbar1.set_label(\"log10(alpha)\")\n    axs[0].set_ylabel(\"Smallest Nonzero Pop\")\n    axs[0].set_title(\"Smallest Nonzero Pop vs R0\")\n    axs[0].set_yscale(\"log\")\n\n    # Plot smallest_nonzero_pop against log10(alpha), colored by R0\n    sc4 = axs[1].scatter(np.log10(params_df[\"alpha\"]), results_df[\"CCS_est\"], c=params_df[\"R0\"], cmap=\"plasma\")\n    axs[1].set_xlabel(\"log10(alpha)\")\n    cbar2 = fig.colorbar(sc4, ax=axs[1])\n    cbar2.set_label(\"R0\")\n    axs[1].set_ylabel(\"Smallest Nonzero Pop\")\n    axs[1].set_title(\"Smallest Nonzero Pop vs log10(alpha)\")\n    axs[1].set_yscale(\"log\")\n\n\n    plt.tight_layout()\n    plt.show()\n\nelse:\n    print(\"No results to plot.\")\n</pre> if results_df is not None:      fig, axs = plt.subplots(2, 1, figsize=(15, 15))      # Plot smallest_nonzero_pop against R0, colored by log10(alpha)     sc3 = axs[0].scatter(params_df[\"R0\"], results_df[\"CCS_est\"], c=np.log10(params_df[\"alpha\"]), cmap=\"viridis\")     axs[0].set_xlabel(\"R0\")     cbar1 = fig.colorbar(sc3, ax=axs[0])     cbar1.set_label(\"log10(alpha)\")     axs[0].set_ylabel(\"Smallest Nonzero Pop\")     axs[0].set_title(\"Smallest Nonzero Pop vs R0\")     axs[0].set_yscale(\"log\")      # Plot smallest_nonzero_pop against log10(alpha), colored by R0     sc4 = axs[1].scatter(np.log10(params_df[\"alpha\"]), results_df[\"CCS_est\"], c=params_df[\"R0\"], cmap=\"plasma\")     axs[1].set_xlabel(\"log10(alpha)\")     cbar2 = fig.colorbar(sc4, ax=axs[1])     cbar2.set_label(\"R0\")     axs[1].set_ylabel(\"Smallest Nonzero Pop\")     axs[1].set_title(\"Smallest Nonzero Pop vs log10(alpha)\")     axs[1].set_yscale(\"log\")       plt.tight_layout()     plt.show()  else:     print(\"No results to plot.\")  <p>OK, now we are going to start some fitting, to see whether our simulations reproduce something like the functional dependences above.</p> <p>We are going to run into a bit of an inference power issue w/r/t dependence on the term of the form $\\frac{R_0}{R0-1}$ - we are fitting a quantity (CCS) varying over orders of magnitude, with one parameter ($\\alpha$) also varying over orders of magnitude, but this ratio being for the most part close to 1.  So we'll go ahead and assume one exponent for the ratio $\\frac{R_0}{R0-1}$ for now, and simply see whether we recover something like the expected functional dependence.</p> In\u00a0[8]: Copied! <pre>from scipy.optimize import curve_fit\n\n# Define the fitting function for curve_fit\ndef fitting_function(X, constant, a, b):\n    alpha, R0 = X\n    return np.log10(constant) + a * np.log10(alpha) + b * np.log10(R0 / (R0 - 1))\n\nif (results_df is not None) and (params_df is not None):\n\n    # Since we are bounded above and below, filter out the max and min values of CCS_est\n    inds2fit = (results_df[\"CCS_est\"] != np.max(pops)) &amp; (results_df[\"CCS_est\"] != np.min(pops))\n\n    # Prepare the data for multivariate fitting\n    # Remove rows with NA in smallest_nonzero_pop\n    alpha_values = params_df[\"alpha\"][inds2fit].values\n    R0_values = params_df[\"R0\"][inds2fit].values\n    CCS_est_values = results_df[\"CCS_est\"][inds2fit].values\n\n    # Stack alpha and R0 as input for curve_fit\n    Xdata = np.vstack((alpha_values, R0_values))\n    # Fit the function to the data\n    popt, pcov = curve_fit(\n        fitting_function,\n        Xdata,\n        np.log10(CCS_est_values),\n        bounds=([0.1, -2.5, -2.5], [100, 2.5, 2.5]),\n        maxfev=10000\n    )\n\n    # # Extract the optimal parameters\n    # constant_opt, a_opt, b_opt, c_opt = popt\n    print(f\"Optimal parameters:  constant = {10**popt[0]}, a = {popt[1]}, b = {popt[2]}\")#, c = {popt[3]}\")\n    print(f\"Covariance matrix:\\n{pcov}\")\n\nelse:\n\n    alpha_values = None\n    R0_values = None\n    CCS_est_values = None\n\n    print(\"No results available for curve fitting.\")\n</pre> from scipy.optimize import curve_fit  # Define the fitting function for curve_fit def fitting_function(X, constant, a, b):     alpha, R0 = X     return np.log10(constant) + a * np.log10(alpha) + b * np.log10(R0 / (R0 - 1))  if (results_df is not None) and (params_df is not None):      # Since we are bounded above and below, filter out the max and min values of CCS_est     inds2fit = (results_df[\"CCS_est\"] != np.max(pops)) &amp; (results_df[\"CCS_est\"] != np.min(pops))      # Prepare the data for multivariate fitting     # Remove rows with NA in smallest_nonzero_pop     alpha_values = params_df[\"alpha\"][inds2fit].values     R0_values = params_df[\"R0\"][inds2fit].values     CCS_est_values = results_df[\"CCS_est\"][inds2fit].values      # Stack alpha and R0 as input for curve_fit     Xdata = np.vstack((alpha_values, R0_values))     # Fit the function to the data     popt, pcov = curve_fit(         fitting_function,         Xdata,         np.log10(CCS_est_values),         bounds=([0.1, -2.5, -2.5], [100, 2.5, 2.5]),         maxfev=10000     )      # # Extract the optimal parameters     # constant_opt, a_opt, b_opt, c_opt = popt     print(f\"Optimal parameters:  constant = {10**popt[0]}, a = {popt[1]}, b = {popt[2]}\")#, c = {popt[3]}\")     print(f\"Covariance matrix:\\n{pcov}\")  else:      alpha_values = None     R0_values = None     CCS_est_values = None      print(\"No results available for curve fitting.\") <pre>Optimal parameters:  constant = 5.243349647321317, a = 1.8327944471708282, b = 1.6715245999431085\nCovariance matrix:\n[[ 0.02629976 -0.00598886 -0.00213744]\n [-0.00598886  0.00139804  0.00022599]\n [-0.00213744  0.00022599  0.00474996]]\n</pre> <p>Looks pretty good - critically, we recover a dependence close to $\\alpha^{3/2}$, matching one of the derived formulas above.  We also get a constant of order 1-10 (2 of the 3 formulas had a constant in this range).  Finally, we fit close to squared dependence on the ratio $\\frac{R_0}{R_0-1}$ (this doesn't exactly match the formula with $\\alpha^{3/2}$ dependence from the begining, but again we have very little no power on this term, as evidenced by the relatively large covariance on it).  Overall, reasonable fits here.</p> In\u00a0[9]: Copied! <pre>if (alpha_values is not None) and (R0_values is not None) and (CCS_est_values is not None):\n\n    # # Create a meshgrid for alpha and R0 values\n    alpha_fit = np.linspace(min(alpha_values), max(alpha_values), 100)\n    R0_fit = np.linspace(min(R0_values), max(R0_values), 100)\n    alpha_fit, R0_fit = np.meshgrid(alpha_fit, R0_fit)\n\n    # # Calculate the best fit surface\n    best_fit_surface = fitting_function((alpha_fit, R0_fit), popt[0], popt[1], popt[2])\n\n    # Plot the best fit surface\n    fig = plt.figure(figsize=(14, 7))\n    ax = fig.add_subplot(111, projection=\"3d\")\n\n\n    # # Plot the best fit surface\n    ax.plot_surface(alpha_fit, R0_fit, best_fit_surface, cmap=\"viridis\", alpha=0.7)\n\n    # # Scatter the real values for comparison\n    ax.scatter(alpha_values, R0_values, np.log10(CCS_est_values), color=\"red\", label=\"Real Values\")\n\n    ax.set_xlabel(\"Alpha\")\n    ax.set_ylabel(\"R0\")\n    ax.set_zlabel(\"Log10(CCS)\")\n    ax.set_title(\"Best Fit Surface and Real Values\")\n\n    # # Add the best fit equation as a textbox\n    equation_text = f\"Best fit: y = {popt[0]:.2f} * alpha^{popt[1]:.2f} * (R0/(R0-1))^{popt[2]:.2f}\"\n    fig.text(.4, 0.9, equation_text, transform=fig.transFigure, fontsize=8, verticalalignment='top')\n\n    plt.tight_layout()\n    # # Rotate the camera for a better viewing angle\n    ax.view_init(elev=20, azim=255)\n    plt.show()\n\nelse:\n\n    print(\"Insufficient data for 3D plotting.\")\n</pre> if (alpha_values is not None) and (R0_values is not None) and (CCS_est_values is not None):      # # Create a meshgrid for alpha and R0 values     alpha_fit = np.linspace(min(alpha_values), max(alpha_values), 100)     R0_fit = np.linspace(min(R0_values), max(R0_values), 100)     alpha_fit, R0_fit = np.meshgrid(alpha_fit, R0_fit)      # # Calculate the best fit surface     best_fit_surface = fitting_function((alpha_fit, R0_fit), popt[0], popt[1], popt[2])      # Plot the best fit surface     fig = plt.figure(figsize=(14, 7))     ax = fig.add_subplot(111, projection=\"3d\")       # # Plot the best fit surface     ax.plot_surface(alpha_fit, R0_fit, best_fit_surface, cmap=\"viridis\", alpha=0.7)      # # Scatter the real values for comparison     ax.scatter(alpha_values, R0_values, np.log10(CCS_est_values), color=\"red\", label=\"Real Values\")      ax.set_xlabel(\"Alpha\")     ax.set_ylabel(\"R0\")     ax.set_zlabel(\"Log10(CCS)\")     ax.set_title(\"Best Fit Surface and Real Values\")      # # Add the best fit equation as a textbox     equation_text = f\"Best fit: y = {popt[0]:.2f} * alpha^{popt[1]:.2f} * (R0/(R0-1))^{popt[2]:.2f}\"     fig.text(.4, 0.9, equation_text, transform=fig.transFigure, fontsize=8, verticalalignment='top')      plt.tight_layout()     # # Rotate the camera for a better viewing angle     ax.view_init(elev=20, azim=255)     plt.show()  else:      print(\"Insufficient data for 3D plotting.\") In\u00a0[10]: Copied! <pre>if (alpha_values is not None) and (R0_values is not None) and (popt is not None):\n\n    fig, ax = plt.subplots(figsize=(10, 7))\n\n    # Scatter plot: CCS_est vs alpha, colored by R0\n    sc = ax.scatter(alpha_values, results_df[\"CCS_est\"][inds2fit], c=R0_values, cmap=\"viridis\", label=\"Simulations\")\n    cbar = plt.colorbar(sc, ax=ax)\n    cbar.set_label(\"R0\")\n\n    # Fitted lines for selected R0 values\n    R0_lines = [1.5, 3, 8, 16]\n    alpha_range = np.logspace(np.log10(np.min(alpha_values)), np.log10(np.max(alpha_values)), 200)\n    for R0_val in R0_lines:\n        CCS_fit = 10**(np.log10(popt[0]) + popt[1]*np.log10(alpha_range) + popt[2]*np.log10(R0_val/(R0_val-1)))\n        ax.plot(alpha_range, CCS_fit, label=f\"Fit R0={R0_val}\")\n\n    ax.set_xscale(\"log\")\n    ax.set_yscale(\"log\")\n    ax.set_xlabel(\"Alpha\")\n    ax.set_ylabel(\"CCS_est\")\n    ax.set_title(\"CCS_est vs Alpha (colored by R0) with Fitted Lines\")\n    ax.legend()\n    plt.tight_layout()\n    plt.show()\n\nelse:\n\n    print(\"alpha values, R0 values, and/or popt missing. Need to re-run analysis?\")\n</pre> if (alpha_values is not None) and (R0_values is not None) and (popt is not None):      fig, ax = plt.subplots(figsize=(10, 7))      # Scatter plot: CCS_est vs alpha, colored by R0     sc = ax.scatter(alpha_values, results_df[\"CCS_est\"][inds2fit], c=R0_values, cmap=\"viridis\", label=\"Simulations\")     cbar = plt.colorbar(sc, ax=ax)     cbar.set_label(\"R0\")      # Fitted lines for selected R0 values     R0_lines = [1.5, 3, 8, 16]     alpha_range = np.logspace(np.log10(np.min(alpha_values)), np.log10(np.max(alpha_values)), 200)     for R0_val in R0_lines:         CCS_fit = 10**(np.log10(popt[0]) + popt[1]*np.log10(alpha_range) + popt[2]*np.log10(R0_val/(R0_val-1)))         ax.plot(alpha_range, CCS_fit, label=f\"Fit R0={R0_val}\")      ax.set_xscale(\"log\")     ax.set_yscale(\"log\")     ax.set_xlabel(\"Alpha\")     ax.set_ylabel(\"CCS_est\")     ax.set_title(\"CCS_est vs Alpha (colored by R0) with Fitted Lines\")     ax.legend()     plt.tight_layout()     plt.show()  else:      print(\"alpha values, R0 values, and/or popt missing. Need to re-run analysis?\")"},{"location":"tutorials/notebooks/07_SIR_CCS/#exploring-the-critical-community-size-of-an-sir-model","title":"Exploring the critical community size of an SIR model\u00b6","text":"<p>The critical community size (CCS) refers to the minimum population size required for an infectious disease to persist in a community without going extinct due to random fluctuations.  It would be more accurate to refer to the critical birth cohort, since the key factor is really not the total population but the rate of influx of new susceptibles - however, CCS is the more commonly used term in the field, and we will follow that. As shown in notebook 5 on the equilibrium age distribution, the SIR system has an endemic equilibrium solution</p> <p>$$ (S^*, \\: I^*, \\: R^*) = N*(\\frac{1}{R_0}, \\:\\: \\frac{\\mu (R_0-1)}{\\beta}, \\: \\: 1-\\frac{1}{R_0} - \\frac{\\mu (R_0-1)}{\\beta}) \\\\ $$</p> <p>and notebook 6, illustrates the stochastic fluctuations in the infectious population around this equilibrium.  It stands to reason, then, the smaller the the equilibrium infected population $\\frac{N \\mu (R_0-1)}{\\beta}$ (or more precisely, the larger the amplitude of fluctuations relative to $ I^* $), the more probable it becomes that the infected population will randomly fluctuate to 0.  In considering spatial patch models of disease transmission, this is a critical behavior that differentiates the disease dynamics of continuous vs. discrete models, and of spatially structured models with many small populations from unstructured models of large populations.  Modeling the spatial population and connectivity structure is thus essential for understanding how local extinctions and reintroductions shape disease persistence at larger scales.</p> <p>While the intuition makes sense, there's not a single, shared mathematically precise definition of the critical community size - how probable does a stochastic extinction need to be, within how long of a time window, to draw a dividing line between above and below the CCS?  Different authors have taken different approaches to defining CCS and analyzing the system and found slightly different approximations to the CCS.  In Nasell, Theoretical Population Biology 67 (2005) 203\u2013216, we find three formulae (the third credited to Diekmann &amp; Heesterbeek, Mathematical Epidemiology of Infectious Diseases (2000)):</p> <p>$$ N_{crit,1} = \\frac{2 \\pi}{log(2)} \\frac{\\alpha^\\frac{3}{2} R_0}{(R_0-1)^\\frac{3}{2}} $$</p> <p>$$ N_{crit,2} = \\frac{K \\alpha^2 R_0}{R_0-1} $$</p> <p>$$  N_{crit,3} = \\frac{\\alpha^2 R_0^2}{(R_0-1)^2} $$</p> <p>where $\\alpha = \\frac{\\gamma + \\mu}{\\mu}$, and $K$ represents a chosen time horizon in units of $\\mu$.  There are slight differences in functional form between these, but what they share in common provides some good intuiation.  First, a strong dependence on the ratio of $\\gamma$ to $\\mu$ - that is, how long is the infectious period relative to the timescale of susceptible replenishment.  Second, relatively weak dependence on $R_0$ as long as it's reasonably larger than 1.  One might expect $R_0$ to play a large role here, but in fact all diseases seek $R_{eff} \\approx 1$ near the endemic equilibrium, and so the impact of $R_0$ on pathogen survival is weak unless $R_0$ is quite small.</p> <p>In this notebook, we will demonstrate ability to reproduce the CCS phenomenon, and fit CCS against the $\\alpha$ &amp; $R_0$ parameters to see which, if any, of the above formula we reproduce.  To do this, we will construct the first patch model in this series of notebooks, setting up each simulation with a set of patches covering a couple orders of magnitude in population size from the smallest to the largest.  As the concept of CCS is defined for a population, we will not yet connect these population patches to each other (that will come in the next notebooks), but will let the disease dynamics play out independently in each to see where the disease persists and where it self-extinguishes.</p>"},{"location":"tutorials/notebooks/07_SIR_CCS/#important-note","title":"Important note\u00b6","text":"<p>Note that running the 200 simulations below takes a few hours even on modern hardware.</p> <p>We have set <code>run_sims</code> to False by default. Change <code>run_sims</code> to True to (re)generate the results.</p>"},{"location":"tutorials/notebooks/07_SIR_CCS/#estimating-the-ccs","title":"Estimating the CCS\u00b6","text":"<p>We will analyze two possible definitions for the CCS from our simulation outputs - the smallest population in which the disease persists through the end of simulation, and the largest population in which the disease fails to persist.   We will opt for the former definition as being more consistent with the definition - stochastic extinctions certianly can happen in above-CCS populations in a given sim, due to oscillations, relative timing of when we turn off new importations, etc.  Alternatively, we should never see disease persistence in sub-CCS populations, and so we will define our empirical estimate of the CCS to be (at most) the smallest population in which we do observe persistence.</p>"},{"location":"tutorials/notebooks/08_2patch_SIR_wbirths_correlation/","title":"The relationship between spatial coupling and incidence correlation in a 2-patch model","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\nfrom laser.core.propertyset import PropertySet\n\nimport laser.core.distributions as dists\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nfrom laser.generic import SIR\nfrom laser.generic import Model\nfrom laser.generic.utils import ValuesMap\nfrom laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator\nfrom laser.core.utils import grid\n\nimport laser.core\nimport laser.generic\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> from pathlib import Path  import matplotlib.pyplot as plt import numpy as np from scipy.optimize import curve_fit  from laser.core.propertyset import PropertySet  import laser.core.distributions as dists from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator from laser.generic import SIR from laser.generic import Model from laser.generic.utils import ValuesMap from laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator from laser.core.utils import grid  import laser.core import laser.generic  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\") <pre>np.__version__='2.2.6'\nlaser.core.__version__='0.9.1'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>class Importation:\n    def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3):\n        self.model = model\n        self.infdurdist = infdurdist\n        self.infdurmin = infdurmin\n        self.period = period\n        self.count = count\n\n        self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)\n\n        return\n    \n    def step(self, tick: int) -&gt; None:\n        if tick &gt; 0 and tick % self.period == 0:\n            i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]\n            if len(i_susceptible) &gt; 0:\n                count = min(self.count, len(i_susceptible))\n                i_infect = np.random.choice(i_susceptible, size=count, replace=False)\n                self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value\n                samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))\n                samples = np.round(samples)\n                samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)\n                self.model.people.itimer[i_infect] = samples\n                inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)\n                self.model.nodes.S[tick + 1] -= inf_by_node\n                self.model.nodes.I[tick + 1] += inf_by_node\n                self.model.nodes.imports[tick] = inf_by_node\n            # else:\n            #     print(f\"No susceptibles to infect at tick {tick}\")\n\n        return\n</pre> class Importation:     def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3):         self.model = model         self.infdurdist = infdurdist         self.infdurmin = infdurmin         self.period = period         self.count = count          self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)          return          def step(self, tick: int) -&gt; None:         if tick &gt; 0 and tick % self.period == 0:             i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]             if len(i_susceptible) &gt; 0:                 count = min(self.count, len(i_susceptible))                 i_infect = np.random.choice(i_susceptible, size=count, replace=False)                 self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value                 samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))                 samples = np.round(samples)                 samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)                 self.model.people.itimer[i_infect] = samples                 inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)                 self.model.nodes.S[tick + 1] -= inf_by_node                 self.model.nodes.I[tick + 1] += inf_by_node                 self.model.nodes.imports[tick] = inf_by_node             # else:             #     print(f\"No susceptibles to infect at tick {tick}\")          return In\u00a0[3]: Copied! <pre>outputs = None\nnsims = 100\nconnections = np.logspace(-4, np.log10(0.5), nsims)\n\nUPDATE_RESULTS = False # Set to True to update saved results takes ~90 minutes on current hardware\n\nif UPDATE_RESULTS:\n\n    import os\n\n    # Set parameters to match those of Keeling &amp; Rohani, 2002.  They have a constant importation rate of 5.5e-5*sqrt(N) per day,\n    # which for this sim would be something like 40 per year.  I'm importing 6 per year, but I don't think that should be the big deal.\n    # more important is setting the birth, R0, and infectious period to their numbers and then seeing the\n    # connectivity-correlation relationship.\n    nticks = 36500\n    pop = 1e6\n    scenario = grid(M=1, N=2, node_size_degs=0.089, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\n    initial_infected = 1\n    scenario[\"S\"] = np.array([pop - initial_infected, pop])\n    scenario[\"I\"] = np.array([initial_infected, 0])\n    scenario[\"R\"] = np.array([0, 0])\n    parameters = PropertySet(\n        {\n            \"seed\": 4,\n            \"nticks\": nticks,\n            \"verbose\": True,\n            \"beta\": 17 / 13,\n            \"inf_mean\": 13,\n            \"cbr\": 20.277294,\n            \"importation_period\": 180,\n            \"importation_count\": 3,\n        }\n    )\n    birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))\n\n    infdurdist = dists.exponential(scale=parameters.inf_mean)\n    rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators.\n    stable_age_dist = np.array(1000*np.exp(-rate_const*np.arange(89)))\n    pyramid = AliasedDistribution(stable_age_dist)\n    survival = KaplanMeierEstimator(stable_age_dist.cumsum())\n\n\n    outputs = np.zeros((nsims, parameters.nticks+1, scenario.shape[0]))\n    for i, connection in enumerate(connections):\n        parameters['seed'] += 1\n        model = Model(scenario, parameters, birthrates=birthrate_map)\n        model.components = [\n            SIR.Susceptible(model),\n            SIR.Recovered(model),\n            SIR.Infectious(model, infdurdist),\n            Importation(model, infdurdist),\n            SIR.Transmission(model, infdurdist),\n            BirthsByCBR(model, birthrates=birthrate_map, pyramid=pyramid),\n            MortalityByEstimator(model, estimator=survival),\n        ]\n\n        # Start them slightly asynchronously - different initial susceptibilities, infection only in 1 patch\n        # Want to see how connectivity drives correlation over time.\n        model.network = np.array([[0, connection], [connection, 0]])\n\n        model.run(f\"{i+1}/{nsims} sims with connection={connection:.6f}\")\n        outputs[i, :, :] = model.nodes.I\n        #Because this is a lot of long-running sims, we will save the outputs after each one completes\n        os.makedirs(\"outputs\", exist_ok=True)\n        np.save(\"outputs/outputs.npy\", outputs)\n</pre> outputs = None nsims = 100 connections = np.logspace(-4, np.log10(0.5), nsims)  UPDATE_RESULTS = False # Set to True to update saved results takes ~90 minutes on current hardware  if UPDATE_RESULTS:      import os      # Set parameters to match those of Keeling &amp; Rohani, 2002.  They have a constant importation rate of 5.5e-5*sqrt(N) per day,     # which for this sim would be something like 40 per year.  I'm importing 6 per year, but I don't think that should be the big deal.     # more important is setting the birth, R0, and infectious period to their numbers and then seeing the     # connectivity-correlation relationship.     nticks = 36500     pop = 1e6     scenario = grid(M=1, N=2, node_size_degs=0.089, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)     initial_infected = 1     scenario[\"S\"] = np.array([pop - initial_infected, pop])     scenario[\"I\"] = np.array([initial_infected, 0])     scenario[\"R\"] = np.array([0, 0])     parameters = PropertySet(         {             \"seed\": 4,             \"nticks\": nticks,             \"verbose\": True,             \"beta\": 17 / 13,             \"inf_mean\": 13,             \"cbr\": 20.277294,             \"importation_period\": 180,             \"importation_count\": 3,         }     )     birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))      infdurdist = dists.exponential(scale=parameters.inf_mean)     rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) #to get stable population, small correction factor for the annual age-dist/KM estimators.     stable_age_dist = np.array(1000*np.exp(-rate_const*np.arange(89)))     pyramid = AliasedDistribution(stable_age_dist)     survival = KaplanMeierEstimator(stable_age_dist.cumsum())       outputs = np.zeros((nsims, parameters.nticks+1, scenario.shape[0]))     for i, connection in enumerate(connections):         parameters['seed'] += 1         model = Model(scenario, parameters, birthrates=birthrate_map)         model.components = [             SIR.Susceptible(model),             SIR.Recovered(model),             SIR.Infectious(model, infdurdist),             Importation(model, infdurdist),             SIR.Transmission(model, infdurdist),             BirthsByCBR(model, birthrates=birthrate_map, pyramid=pyramid),             MortalityByEstimator(model, estimator=survival),         ]          # Start them slightly asynchronously - different initial susceptibilities, infection only in 1 patch         # Want to see how connectivity drives correlation over time.         model.network = np.array([[0, connection], [connection, 0]])          model.run(f\"{i+1}/{nsims} sims with connection={connection:.6f}\")         outputs[i, :, :] = model.nodes.I         #Because this is a lot of long-running sims, we will save the outputs after each one completes         os.makedirs(\"outputs\", exist_ok=True)         np.save(\"outputs/outputs.npy\", outputs)  In\u00a0[4]: Copied! <pre>if outputs is not None or Path(\"outputs/outputs.npy\").exists():\n    if outputs is None:\n        outputs = np.load(\"outputs/outputs.npy\")\n\n    correlations = []\n    last_25_years = 25 * 365  # 25 years in days\n\n    for sim in range(outputs.shape[0]):\n        patch1_data = outputs[sim, -last_25_years:, 0]\n        patch2_data = outputs[sim, -last_25_years:, 1]\n        correlation = np.corrcoef(patch1_data, patch2_data)[0, 1]\n        correlations.append(correlation)\n\n    correlations = np.array(correlations)\n\n    # Define the function to fit\n    def func(x, psi, beta):\n        return beta + x / (psi + x)\n\n\n    # Fit the curve\n    popt, pcov = curve_fit(func, connections, correlations, p0=[0.01, 0], bounds=([1e-6, -0.00002], [1, 0.00002]))\n    psi_opt = popt[0]\n    beta_opt = popt[1]\n    plt.plot(connections, correlations, \".\")\n    plt.xscale(\"log\")\n    # Plot the fitted curve\n    plt.plot(connections, func(connections, psi_opt, beta_opt), label=f\"Fitted curve: y = {beta_opt:.4f} + x / ({psi_opt:.4f} + x)\")\n\n    plt.legend()\n</pre> if outputs is not None or Path(\"outputs/outputs.npy\").exists():     if outputs is None:         outputs = np.load(\"outputs/outputs.npy\")      correlations = []     last_25_years = 25 * 365  # 25 years in days      for sim in range(outputs.shape[0]):         patch1_data = outputs[sim, -last_25_years:, 0]         patch2_data = outputs[sim, -last_25_years:, 1]         correlation = np.corrcoef(patch1_data, patch2_data)[0, 1]         correlations.append(correlation)      correlations = np.array(correlations)      # Define the function to fit     def func(x, psi, beta):         return beta + x / (psi + x)       # Fit the curve     popt, pcov = curve_fit(func, connections, correlations, p0=[0.01, 0], bounds=([1e-6, -0.00002], [1, 0.00002]))     psi_opt = popt[0]     beta_opt = popt[1]     plt.plot(connections, correlations, \".\")     plt.xscale(\"log\")     # Plot the fitted curve     plt.plot(connections, func(connections, psi_opt, beta_opt), label=f\"Fitted curve: y = {beta_opt:.4f} + x / ({psi_opt:.4f} + x)\")      plt.legend()"},{"location":"tutorials/notebooks/08_2patch_SIR_wbirths_correlation/#the-relationship-between-spatial-coupling-and-incidence-correlation-in-a-2-patch-model","title":"The relationship between spatial coupling and incidence correlation in a 2-patch model\u00b6","text":"<p>Now that we have extensively demonstrated and validated the single-patch behavior of different LASER models, it's finally time to demonstrate LASER in a spatial modeling context - in this case, not explicitly spatial but rather a multi-patch model with connection matrix.</p> <p>We will aim to replicate the findings in Keeling &amp; Rohani, Estimating spatial coupling in epidemiological systems: a mechanistic approach, Ecol. Letters (2002) 5:20-29, where the authors analyze a 2-patch SIR system and develop a relationship between the parameter governing the ratio of \"within vs. between\" coupling of infectives and susceptibles in the two patches, and the correlation in the time series of infections in the two patches.  Readers can turn to that publication for a full reproduction of the analysis; here we will introduce the system (using our notation established in the other notebooks, rather than that of the paper) and skip ahead to stating the result we want to reproduce.</p> <p>We consider a system of two coupled patches, of equal population $N$, birthrate $\\mu$, and mortality rate $\\nu$, coupled by parameter $\\sigma$ such that in each patch, a fraction $\\sigma$ of infectiveness is \"sent\" to the other node, with the remaining $(1-\\sigma)$ \"staying local\".</p> <p>$$ \\dot{S_1} = \\mu N - \\frac{\\beta S_1}{N}\\left( I_1 \\left( 1 - \\sigma \\right) +I_2 \\sigma \\right) - \\nu S_1 $$</p> <p>$$ \\dot{I_1} = \\frac{\\beta S_1}{N}(I_1 (1 - \\sigma) +I_2 \\sigma) - \\gamma I_1 - \\nu I_1 $$</p> <p>$$ \\dot{R_1} = \\gamma I_1 - \\nu R_1 $$</p> <p>$$ \\dot{S_2} = \\mu N - \\frac{\\beta S_2}{N}(I_2 (1 - \\sigma) +I_1 \\sigma) - \\nu S_2 $$</p> <p>$$ \\dot{I_2} = \\frac{\\beta S_2}{N}(I_2 (1 - \\sigma) +I_1 \\sigma)- \\gamma I_2 - \\nu I_2 $$</p> <p>$$ \\dot{R_2} = \\gamma I_2 - \\nu R_2 $$</p> <p>The authors proceed to analyze the combined system, eventually deriving the following approximate relationship,</p> <p>$$ C = \\frac{\\sigma}{\\xi + \\sigma} $$</p> <p>where $C$ is the time-series correlation between $I_1$ and $I_2$, $\\sigma$ is again the coupling constant as defined above, and $\\xi$ is a constant that depends on the other model parameters $\\mu, \\nu, \\beta, \\gamma$.   They find a value $\\xi = 0.0119$ for a particular instantiation of their model (run for 5000-year samples), and we will roughly replicate their parametrization and find that we can recapitulate the sigmoidal behavior and fit a similar value of $\\xi$.  It's important to note that this is an empirical constant and we can move the exact value of it by changing e.g., the length of time over which we compute the correlation - we consider it sufficient validation to demonstrate the sigmoidal relationship between $C$ and $\\sigma$, with a value of $\\xi$ in the same order of magnitude.</p>"},{"location":"tutorials/notebooks/08_2patch_SIR_wbirths_correlation/#results","title":"Results\u00b6","text":"<p>$\\xi$ = 0.0117 - quite close to the original result!</p> <p>As noted before - since these are finite time simulations and we are not running for 5000 years like the original paper, the choice of window over which to compute correlation can affect the outputs.  The particular choice of the last 25 years was chosen to land us with a value quite close to the original value - if you adjust the window of computation to be the last 10 years, or last 75 years, etc. you can shift the fitted value of $\\xi$ around by a factor of 2-3 either direction.  This is not unexpected - it takes some  time for this system to settle out of its early transient dynamics into a regime where we can reliably compute this correlation, and in fact, that time likely depends strongly on the value of the connection coefficient.  We view it as sufficient demonstration to recapture the sigmoidal relationship, and show that we can recover values of $\\xi$ of similar order of magnitude as the analytic result presented in the reference manuscript.</p>"},{"location":"tutorials/notebooks/09_rabies_diffusion_1D/","title":"Modeling the spread of rabies in one dimension","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nimport laser.core.distributions as dists\nfrom laser.generic import SIR\nfrom laser.generic import Model\nfrom laser.core.utils import grid\nimport laser.core\nimport laser.generic\nimport matplotlib.pyplot as plt\nimport os\nfrom scipy.optimize import fsolve\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd from laser.core.propertyset import PropertySet import laser.core.distributions as dists from laser.generic import SIR from laser.generic import Model from laser.core.utils import grid import laser.core import laser.generic import matplotlib.pyplot as plt import os from scipy.optimize import fsolve  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.2.6'\nlaser.core.__version__='0.9.1'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>#Set up the network and initial conditions\nnpatches = 201\npop = 1000\nscenario = grid(M=1, N=npatches, node_size_degs=0.05, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 3\nscenario[\"I\"] = 0\nscenario[\"R\"] = 0\nscenario[\"S\"] = scenario.population\nscenario.loc[scenario.nodeid==101,\"I\"] = initial_infected\nscenario.loc[scenario.nodeid==101,\"S\"] = scenario.loc[scenario.nodeid==101,\"population\"]-initial_infected\n</pre> #Set up the network and initial conditions npatches = 201 pop = 1000 scenario = grid(M=1, N=npatches, node_size_degs=0.05, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 3 scenario[\"I\"] = 0 scenario[\"R\"] = 0 scenario[\"S\"] = scenario.population scenario.loc[scenario.nodeid==101,\"I\"] = initial_infected scenario.loc[scenario.nodeid==101,\"S\"] = scenario.loc[scenario.nodeid==101,\"population\"]-initial_infected In\u00a0[3]: Copied! <pre>infmean = 10.0\nR0 = 10.0\nnticks = 2 * 365\nD = .01\nparameters = PropertySet(\n    {\n        \"seed\": np.random.randint(0, 1000000),\n        \"nticks\": nticks,\n        \"verbose\": True,\n        \"beta\": R0 / infmean,\n        \"inf_mean\": infmean,\n    }\n)\n\ninfdurdist = dists.exponential(scale=parameters.inf_mean)\nmodel = Model(scenario, parameters)\nmodel.network = 0*model.network\nnp.fill_diagonal(model.network[1:], D)\nnp.fill_diagonal(model.network[:,1:], D)\n\nmodel.components = [\n    SIR.Susceptible(model),\n    SIR.Recovered(model),\n    SIR.Infectious(model, infdurdist),\n    SIR.Transmission(model, infdurdist),\n]\nmodel.run()\n</pre> infmean = 10.0 R0 = 10.0 nticks = 2 * 365 D = .01 parameters = PropertySet(     {         \"seed\": np.random.randint(0, 1000000),         \"nticks\": nticks,         \"verbose\": True,         \"beta\": R0 / infmean,         \"inf_mean\": infmean,     } )  infdurdist = dists.exponential(scale=parameters.inf_mean) model = Model(scenario, parameters) model.network = 0*model.network np.fill_diagonal(model.network[1:], D) np.fill_diagonal(model.network[:,1:], D)  model.components = [     SIR.Susceptible(model),     SIR.Recovered(model),     SIR.Infectious(model, infdurdist),     SIR.Transmission(model, infdurdist), ] model.run()   <pre>201,000 agents in 201 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1314.70it/s]\n</pre> In\u00a0[4]: Copied! <pre>plt.figure(figsize=(9, 4))\nplt.imshow(model.nodes.I.T, aspect='auto', origin='lower')\nplt.xlabel('Time (tick)')\nplt.ylabel('Patch')\nplt.title('Infectious (I) over time and space')\nplt.colorbar(label='Infectious')\nplt.show()\n</pre> plt.figure(figsize=(9, 4)) plt.imshow(model.nodes.I.T, aspect='auto', origin='lower') plt.xlabel('Time (tick)') plt.ylabel('Patch') plt.title('Infectious (I) over time and space') plt.colorbar(label='Infectious') plt.show()  In\u00a0[5]: Copied! <pre>from scipy.stats import linregress\n\n# Find the time (tick) of peak I for each node\npeak_times = model.nodes.I.argmax(axis=0)  # shape: (npatches,)\n\n# Get the node indices for right-going (101 to 200) and left-going (100 to 0) waves\nright_nodes = np.arange(101, npatches)\nleft_nodes = np.arange(100, -1, -1)\n\n# Fit a line to peak_times vs node index for each direction to estimate velocity (slope = 1/velocity)\n\n# Right-going wave\nright_peak_times = peak_times[right_nodes]\nslope_r, intercept_r, r_value_r, p_value_r, std_err_r = linregress(right_nodes[right_peak_times&gt;0], right_peak_times[right_peak_times &gt; 0])\nvelocity_right = 1 / slope_r if slope_r != 0 else np.nan\n\n# Left-going wave\nleft_peak_times = peak_times[left_nodes]\nslope_l, intercept_l, r_value_l, p_value_l, std_err_l = linregress(left_nodes[left_peak_times&gt;0], left_peak_times[left_peak_times &gt; 0])\nvelocity_left = -1 / slope_l if slope_l != 0 else np.nan  # negative because left\n\nprint(f\"Estimated right-going wavespeed: {velocity_right:.3f} patches/tick\")\nprint(f\"Estimated left-going wavespeed: {velocity_left:.3f} patches/tick\")\nprint(f\"Expected wavespeed: {2*np.sqrt(D/infmean*(R0-1)):.3f} patches/tick\")\n</pre> from scipy.stats import linregress  # Find the time (tick) of peak I for each node peak_times = model.nodes.I.argmax(axis=0)  # shape: (npatches,)  # Get the node indices for right-going (101 to 200) and left-going (100 to 0) waves right_nodes = np.arange(101, npatches) left_nodes = np.arange(100, -1, -1)  # Fit a line to peak_times vs node index for each direction to estimate velocity (slope = 1/velocity)  # Right-going wave right_peak_times = peak_times[right_nodes] slope_r, intercept_r, r_value_r, p_value_r, std_err_r = linregress(right_nodes[right_peak_times&gt;0], right_peak_times[right_peak_times &gt; 0]) velocity_right = 1 / slope_r if slope_r != 0 else np.nan  # Left-going wave left_peak_times = peak_times[left_nodes] slope_l, intercept_l, r_value_l, p_value_l, std_err_l = linregress(left_nodes[left_peak_times&gt;0], left_peak_times[left_peak_times &gt; 0]) velocity_left = -1 / slope_l if slope_l != 0 else np.nan  # negative because left  print(f\"Estimated right-going wavespeed: {velocity_right:.3f} patches/tick\") print(f\"Estimated left-going wavespeed: {velocity_left:.3f} patches/tick\") print(f\"Expected wavespeed: {2*np.sqrt(D/infmean*(R0-1)):.3f} patches/tick\") <pre>Estimated right-going wavespeed: 0.179 patches/tick\nEstimated left-going wavespeed: 0.180 patches/tick\nExpected wavespeed: 0.190 patches/tick\n</pre> In\u00a0[6]: Copied! <pre># Set up parameter ranges\nn_samples = 100\nD_samples = np.logspace(np.log10(3e-4), np.log10(3e-1), n_samples)\nR0_samples = np.random.uniform(1.5, 10, n_samples)\ninfmean_samples = np.random.uniform(7, 50, n_samples)\n\nresults = []\n\nfor i, (D, R0, infmean) in enumerate(zip(D_samples, R0_samples, infmean_samples)):\n    # Set up parameters for this run\n    parameters = PropertySet(\n        {\n            \"seed\": np.random.randint(0, 1000000),\n            \"nticks\": nticks,\n            \"verbose\": False,\n            \"beta\": R0 / infmean,\n            \"inf_mean\": infmean,\n        }\n    )\n    infdurdist = dists.exponential(scale=parameters.inf_mean)\n    model = Model(scenario.copy(), parameters)\n    model.network = 0 * model.network\n    np.fill_diagonal(model.network[1:], D)\n    np.fill_diagonal(model.network[:, 1:], D)\n    model.components = [\n        SIR.Susceptible(model),\n        SIR.Recovered(model),\n        SIR.Infectious(model, infdurdist),\n        SIR.Transmission(model, infdurdist),\n    ]\n    model.run(f\"Sim {i+1}/{n_samples}\")\n    # Estimate wavespeed as before\n    peak_times = model.nodes.I.argmax(axis=0)\n    right_nodes = np.arange(101, npatches)\n    left_nodes = np.arange(100, -1, -1)\n    right_peak_times = peak_times[right_nodes]\n    left_peak_times = peak_times[left_nodes]\n    # Right\n    mask_r = right_peak_times &gt; 0\n    if np.any(mask_r):\n        slope_r, *_ = linregress(right_nodes[mask_r], right_peak_times[mask_r])\n        velocity_right = 1 / slope_r if slope_r != 0 else np.nan\n    else:\n        velocity_right = np.nan\n    # Left\n    mask_l = left_peak_times &gt; 0\n    if np.any(mask_l):\n        slope_l, *_ = linregress(left_nodes[mask_l], left_peak_times[mask_l])\n        velocity_left = -1 / slope_l if slope_l != 0 else np.nan\n    else:\n        velocity_left = np.nan\n    # Expected wavespeed (from theory)\n    expected_speed = 2 * np.sqrt(D / infmean * (R0 - 1))\n    results.append({\n        \"D\": D,\n        \"R0\": R0,\n        \"infmean\": infmean,\n        \"velocity_right\": velocity_right,\n        \"velocity_left\": velocity_left,\n        \"expected_speed\": expected_speed,\n    })\n\nresults_df = pd.DataFrame(results)\n</pre> # Set up parameter ranges n_samples = 100 D_samples = np.logspace(np.log10(3e-4), np.log10(3e-1), n_samples) R0_samples = np.random.uniform(1.5, 10, n_samples) infmean_samples = np.random.uniform(7, 50, n_samples)  results = []  for i, (D, R0, infmean) in enumerate(zip(D_samples, R0_samples, infmean_samples)):     # Set up parameters for this run     parameters = PropertySet(         {             \"seed\": np.random.randint(0, 1000000),             \"nticks\": nticks,             \"verbose\": False,             \"beta\": R0 / infmean,             \"inf_mean\": infmean,         }     )     infdurdist = dists.exponential(scale=parameters.inf_mean)     model = Model(scenario.copy(), parameters)     model.network = 0 * model.network     np.fill_diagonal(model.network[1:], D)     np.fill_diagonal(model.network[:, 1:], D)     model.components = [         SIR.Susceptible(model),         SIR.Recovered(model),         SIR.Infectious(model, infdurdist),         SIR.Transmission(model, infdurdist),     ]     model.run(f\"Sim {i+1}/{n_samples}\")     # Estimate wavespeed as before     peak_times = model.nodes.I.argmax(axis=0)     right_nodes = np.arange(101, npatches)     left_nodes = np.arange(100, -1, -1)     right_peak_times = peak_times[right_nodes]     left_peak_times = peak_times[left_nodes]     # Right     mask_r = right_peak_times &gt; 0     if np.any(mask_r):         slope_r, *_ = linregress(right_nodes[mask_r], right_peak_times[mask_r])         velocity_right = 1 / slope_r if slope_r != 0 else np.nan     else:         velocity_right = np.nan     # Left     mask_l = left_peak_times &gt; 0     if np.any(mask_l):         slope_l, *_ = linregress(left_nodes[mask_l], left_peak_times[mask_l])         velocity_left = -1 / slope_l if slope_l != 0 else np.nan     else:         velocity_left = np.nan     # Expected wavespeed (from theory)     expected_speed = 2 * np.sqrt(D / infmean * (R0 - 1))     results.append({         \"D\": D,         \"R0\": R0,         \"infmean\": infmean,         \"velocity_right\": velocity_right,         \"velocity_left\": velocity_left,         \"expected_speed\": expected_speed,     })  results_df = pd.DataFrame(results)  <pre>Sim 1/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1589.45it/s]\nSim 2/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1795.47it/s]\n/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_96092/1872132150.py:41: SmallSampleWarning: One or more sample arguments is too small; all returned values will be NaN. See documentation for sample size requirements.\n  slope_r, *_ = linregress(right_nodes[mask_r], right_peak_times[mask_r])\nSim 3/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1771.04it/s]\nSim 4/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1731.69it/s]\n/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_96092/1872132150.py:41: SmallSampleWarning: One or more sample arguments is too small; all returned values will be NaN. See documentation for sample size requirements.\n  slope_r, *_ = linregress(right_nodes[mask_r], right_peak_times[mask_r])\nSim 5/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1782.85it/s]\nSim 6/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1615.69it/s]\nSim 7/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1776.41it/s]\nSim 8/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1766.32it/s]\n/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_96092/1872132150.py:41: SmallSampleWarning: One or more sample arguments is too small; all returned values will be NaN. See documentation for sample size requirements.\n  slope_r, *_ = linregress(right_nodes[mask_r], right_peak_times[mask_r])\nSim 9/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1773.55it/s]\nSim 10/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1693.85it/s]\n/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_96092/1872132150.py:41: SmallSampleWarning: One or more sample arguments is too small; all returned values will be NaN. See documentation for sample size requirements.\n  slope_r, *_ = linregress(right_nodes[mask_r], right_peak_times[mask_r])\nSim 11/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1800.68it/s]\n/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_96092/1872132150.py:48: SmallSampleWarning: One or more sample arguments is too small; all returned values will be NaN. See documentation for sample size requirements.\n  slope_l, *_ = linregress(left_nodes[mask_l], left_peak_times[mask_l])\nSim 12/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1757.24it/s]\nSim 13/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1759.43it/s]\n/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_96092/1872132150.py:48: SmallSampleWarning: One or more sample arguments is too small; all returned values will be NaN. See documentation for sample size requirements.\n  slope_l, *_ = linregress(left_nodes[mask_l], left_peak_times[mask_l])\nSim 14/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1822.74it/s]\nSim 15/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1821.18it/s]\nSim 16/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1800.06it/s]\nSim 17/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1774.61it/s]\n/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_96092/1872132150.py:48: SmallSampleWarning: One or more sample arguments is too small; all returned values will be NaN. See documentation for sample size requirements.\n  slope_l, *_ = linregress(left_nodes[mask_l], left_peak_times[mask_l])\nSim 18/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1656.45it/s]\nSim 19/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1760.82it/s]\nSim 20/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1786.95it/s]\nSim 21/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1570.53it/s]\nSim 22/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1749.97it/s]\nSim 23/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1779.38it/s]\n/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_96092/1872132150.py:48: SmallSampleWarning: One or more sample arguments is too small; all returned values will be NaN. See documentation for sample size requirements.\n  slope_l, *_ = linregress(left_nodes[mask_l], left_peak_times[mask_l])\nSim 24/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1822.08it/s]\nSim 25/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1812.67it/s]\nSim 26/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1564.90it/s]\nSim 27/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1789.10it/s]\nSim 28/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1745.11it/s]\nSim 29/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1771.04it/s]\nSim 30/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1794.92it/s]\nSim 31/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1812.69it/s]\nSim 32/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1807.62it/s]\nSim 33/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1793.64it/s]\nSim 34/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1796.68it/s]\nSim 35/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1781.41it/s]\nSim 36/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1822.00it/s]\nSim 37/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1536.01it/s]\nSim 38/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1744.07it/s]\nSim 39/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1728.67it/s]\n/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_96092/1872132150.py:48: SmallSampleWarning: One or more sample arguments is too small; all returned values will be NaN. See documentation for sample size requirements.\n  slope_l, *_ = linregress(left_nodes[mask_l], left_peak_times[mask_l])\nSim 40/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1770.27it/s]\nSim 41/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1822.54it/s]\nSim 42/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1835.71it/s]\nSim 43/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1475.71it/s]\nSim 44/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1697.52it/s]\nSim 45/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1812.07it/s]\nSim 46/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1791.60it/s]\nSim 47/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1788.70it/s]\nSim 48/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1791.85it/s]\nSim 49/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1820.97it/s]\nSim 50/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1784.19it/s]\nSim 51/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1816.44it/s]\nSim 52/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1782.10it/s]\nSim 53/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1783.28it/s]\nSim 54/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1767.16it/s]\nSim 55/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1713.80it/s]\nSim 56/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1463.66it/s]\nSim 57/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1727.47it/s]\nSim 58/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1701.79it/s]\nSim 59/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1769.79it/s]\nSim 60/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1781.24it/s]\nSim 61/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1754.85it/s]\nSim 62/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1754.89it/s]\nSim 63/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1396.86it/s]\nSim 64/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1819.93it/s]\nSim 65/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1716.20it/s]\nSim 66/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1759.22it/s]\nSim 67/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1738.89it/s]\nSim 68/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1787.02it/s]\nSim 69/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1787.82it/s]\nSim 70/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1777.94it/s]\nSim 71/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1750.98it/s]\nSim 72/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1899.78it/s]\nSim 73/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1703.63it/s]\nSim 74/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1741.50it/s]\nSim 75/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1784.48it/s]\nSim 76/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1761.36it/s]\n/var/folders/fl/_ns4br_j2qxd92vjrgl3t4n00000gn/T/ipykernel_96092/1872132150.py:41: SmallSampleWarning: One or more sample arguments is too small; all returned values will be NaN. See documentation for sample size requirements.\n  slope_r, *_ = linregress(right_nodes[mask_r], right_peak_times[mask_r])\nSim 77/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1782.17it/s]\nSim 78/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1777.98it/s]\nSim 79/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1755.14it/s]\nSim 80/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1716.72it/s]\nSim 81/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1742.29it/s]\nSim 82/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1763.68it/s]\nSim 83/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1750.55it/s]\nSim 84/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1479.91it/s]\nSim 85/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1773.55it/s]\nSim 86/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1758.66it/s]\nSim 87/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1770.89it/s]\nSim 88/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1924.05it/s]\nSim 89/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1745.05it/s]\nSim 90/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1754.55it/s]\nSim 91/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1756.36it/s]\nSim 92/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1730.06it/s]\nSim 93/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1761.04it/s]\nSim 94/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1821.00it/s]\nSim 95/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1725.48it/s]\nSim 96/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1860.89it/s]\nSim 97/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1877.07it/s]\nSim 98/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1737.56it/s]\nSim 99/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1377.37it/s]\nSim 100/100: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1863.82it/s]\n</pre> In\u00a0[7]: Copied! <pre>plt.figure(figsize=(8, 6))\nplt.plot(results_df[\"expected_speed\"], results_df[\"velocity_left\"], 'r.', label=\"Velocity left\", markersize=12)\nplt.plot(results_df[\"expected_speed\"], results_df[\"velocity_right\"], 'b.', label=\"Velocity right\", markersize=12)\nplt.plot([1e-3, 1], [1e-3, 1], 'k--', label=\"y=x\")\nplt.xscale('log')\nplt.yscale('log')\nplt.xlabel(\"Expected wavespeed (patches/tick)\")\nplt.ylabel(\"Measured wavespeed (patches/tick)\")\nplt.title(\"Comparison of expected and observed wavespeeds\")\nmin_val = np.nanmin(np.abs([results_df[\"expected_speed\"].min(), results_df[\"velocity_right\"].min(), results_df[\"velocity_left\"].min()]))\nmax_val = np.nanmax([results_df[\"expected_speed\"].max(), results_df[\"velocity_right\"].max(), results_df[\"velocity_left\"].max()])\nplt.xlim(min_val, max_val)\nplt.ylim(min_val, max_val)\nplt.legend()\nplt.tight_layout()\nplt.show()\n</pre> plt.figure(figsize=(8, 6)) plt.plot(results_df[\"expected_speed\"], results_df[\"velocity_left\"], 'r.', label=\"Velocity left\", markersize=12) plt.plot(results_df[\"expected_speed\"], results_df[\"velocity_right\"], 'b.', label=\"Velocity right\", markersize=12) plt.plot([1e-3, 1], [1e-3, 1], 'k--', label=\"y=x\") plt.xscale('log') plt.yscale('log') plt.xlabel(\"Expected wavespeed (patches/tick)\") plt.ylabel(\"Measured wavespeed (patches/tick)\") plt.title(\"Comparison of expected and observed wavespeeds\") min_val = np.nanmin(np.abs([results_df[\"expected_speed\"].min(), results_df[\"velocity_right\"].min(), results_df[\"velocity_left\"].min()])) max_val = np.nanmax([results_df[\"expected_speed\"].max(), results_df[\"velocity_right\"].max(), results_df[\"velocity_left\"].max()]) plt.xlim(min_val, max_val) plt.ylim(min_val, max_val) plt.legend() plt.tight_layout() plt.show()  In\u00a0[8]: Copied! <pre># Compute relative errors\nrel_err_left = (results_df[\"velocity_left\"] - results_df[\"expected_speed\"]) / results_df[\"expected_speed\"]\nrel_err_right = (results_df[\"velocity_right\"] - results_df[\"expected_speed\"]) / results_df[\"expected_speed\"]\n\n# Plot: colored by R0\nplt.figure(figsize=(8, 6))\nsc = plt.scatter(results_df[\"expected_speed\"], rel_err_right, c=results_df[\"R0\"]/results_df['infmean'], cmap='viridis', label=\"Right\", marker='o')\nplt.colorbar(sc, label=\"beta\")\nplt.scatter(results_df[\"expected_speed\"], rel_err_left, c=results_df[\"R0\"]/results_df['infmean'], cmap='viridis', marker='x', label=\"Left\")\nplt.xscale('log')\nplt.xlabel(\"Expected wavespeed (patches/tick)\")\nplt.ylabel(\"Relative error (measured - expected) / expected\")\nplt.title(\"Relative error vs. expected speed (colored by beta)\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n# Plot: colored by D\nplt.figure(figsize=(8, 6))\nsc = plt.scatter(results_df[\"expected_speed\"], rel_err_right, c=np.log10(results_df[\"D\"]), cmap='plasma', label=\"Right\", marker='o')\nplt.colorbar(sc, label=\"log10(D)\")\nplt.scatter(results_df[\"expected_speed\"], rel_err_left, c=np.log10(results_df[\"D\"]), cmap='plasma', marker='x', label=\"Left\")\nplt.xscale('log')\nplt.xlabel(\"Expected wavespeed (patches/tick)\")\nplt.ylabel(\"Relative error (measured - expected) / expected\")\nplt.title(\"Relative error vs. expected speed (colored by log10(D))\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n# Plot: colored by infmean\nplt.figure(figsize=(8, 6))\nsc = plt.scatter(results_df[\"expected_speed\"], rel_err_right, c=results_df[\"infmean\"], cmap='cividis', label=\"Right\", marker='o')\nplt.colorbar(sc, label=\"inf_mean\")\nplt.scatter(results_df[\"expected_speed\"], rel_err_left, c=results_df[\"infmean\"], cmap='cividis', marker='x', label=\"Left\")\nplt.xscale('log')\nplt.xlabel(\"Expected wavespeed (patches/tick)\")\nplt.ylabel(\"Relative error (measured - expected) / expected\")\nplt.title(\"Relative error vs. expected speed (colored by inf_mean)\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n</pre> # Compute relative errors rel_err_left = (results_df[\"velocity_left\"] - results_df[\"expected_speed\"]) / results_df[\"expected_speed\"] rel_err_right = (results_df[\"velocity_right\"] - results_df[\"expected_speed\"]) / results_df[\"expected_speed\"]  # Plot: colored by R0 plt.figure(figsize=(8, 6)) sc = plt.scatter(results_df[\"expected_speed\"], rel_err_right, c=results_df[\"R0\"]/results_df['infmean'], cmap='viridis', label=\"Right\", marker='o') plt.colorbar(sc, label=\"beta\") plt.scatter(results_df[\"expected_speed\"], rel_err_left, c=results_df[\"R0\"]/results_df['infmean'], cmap='viridis', marker='x', label=\"Left\") plt.xscale('log') plt.xlabel(\"Expected wavespeed (patches/tick)\") plt.ylabel(\"Relative error (measured - expected) / expected\") plt.title(\"Relative error vs. expected speed (colored by beta)\") plt.legend() plt.tight_layout() plt.show()  # Plot: colored by D plt.figure(figsize=(8, 6)) sc = plt.scatter(results_df[\"expected_speed\"], rel_err_right, c=np.log10(results_df[\"D\"]), cmap='plasma', label=\"Right\", marker='o') plt.colorbar(sc, label=\"log10(D)\") plt.scatter(results_df[\"expected_speed\"], rel_err_left, c=np.log10(results_df[\"D\"]), cmap='plasma', marker='x', label=\"Left\") plt.xscale('log') plt.xlabel(\"Expected wavespeed (patches/tick)\") plt.ylabel(\"Relative error (measured - expected) / expected\") plt.title(\"Relative error vs. expected speed (colored by log10(D))\") plt.legend() plt.tight_layout() plt.show()  # Plot: colored by infmean plt.figure(figsize=(8, 6)) sc = plt.scatter(results_df[\"expected_speed\"], rel_err_right, c=results_df[\"infmean\"], cmap='cividis', label=\"Right\", marker='o') plt.colorbar(sc, label=\"inf_mean\") plt.scatter(results_df[\"expected_speed\"], rel_err_left, c=results_df[\"infmean\"], cmap='cividis', marker='x', label=\"Left\") plt.xscale('log') plt.xlabel(\"Expected wavespeed (patches/tick)\") plt.ylabel(\"Relative error (measured - expected) / expected\") plt.title(\"Relative error vs. expected speed (colored by inf_mean)\") plt.legend() plt.tight_layout() plt.show()"},{"location":"tutorials/notebooks/09_rabies_diffusion_1D/#modeling-the-spread-of-rabies-in-one-dimension","title":"Modeling the spread of rabies in one dimension\u00b6","text":"<p>In this notebook, we will move from the 2 connected patches described in Notebook 8 to a 1-D grid of connected population patches.  This is the scenario explored to describe the spatial spread of rabies in foxes in the work of Kallen, Arcuri, and Murray, Journal of Theoretical Biology (1985) 116, 377-393. The relevant model equations (note that these are now PDEs rather than the ODEs of previous notebooks) are:</p> <p>$$ \\frac{\\partial S}{\\partial t} = -KIS $$</p> <p>$$ \\frac{\\partial I}{\\partial t} = D \\frac{\\partial^2 I}{\\partial x^2} + KIS - \\mu I $$</p> <p>and come to the conclusion that this system supports traveling waves with velocity bounded below by</p> <p>$$ c = 2 \\sqrt{D \\mu (1/r -1)} $$</p> <p>where $r = \\frac{\\mu}{K S_0}$ and $S_0$ is the initial density of susceptibles.</p> <p>The analogy to the SIR model equations we have been using is clear, though this model conceptually different in specific ways from that model as we now have spatially dimensional quantities.  For example, I &amp; S are infective/susceptible population densities rather than population counts, which affects translating between the $K$ of this model and the $\\beta$ of the SIR; the derived quantity $r$ is clearly analogous to $\\frac{1}{R_0}$ of the SIR model, but requires the presence of the initial susceptible density to be properly dimensionless, and rabies being invariably fatal, $\\mu$ represents the mortality of rabies rather than the $\\gamma$ we would use for recovery.</p> <p>With all that said, if we are careful about translation between parameters, and appropriately construct the transmission network to appropriately reflect 1-D diffusion, we ought to be able to reproduce this model in our SIR implementation, and recapitulate the traveling wave behavior of the outbreak.  As we do this, we will also run into two well-understood issues in simulating traveling waves of the expected wavespeed on a finite lattice, both biasing us to produce slower waves on average.</p> <p>The first comes from discretization - we are transitioning from a PDE continuous in space, time, and the relevant variable $I$, to a simulation that is discrete in all 3.  This discretization will make it impossible for infection to travel more than 1 lattice spacing per simulation timestep, so in parameter regimes where the expected wavespeed approaches a lattice spacing per simulation timestep, our model will be incapable of demonstrating that.</p> <p>The second slowdown ill come from discretization of the population itself, and from stochasticity.  This phenomenon is sometimes referred to as the \"attofox\" problem, and is discussed, e.g., in the chapter on Spatial Modeling in Keeling and Rohani, Modeling Infectious Diseases in Humans and Animals.  In a model with deterministic dynamics and continuous populations, any fraction of infectivity deposited in a population can generate fractional infectives, and deterministically kick off the start of a local outbreak.  In a discrete population, stochastic model, we cannot create new infections in smaller units than a single infected individual. This causes stochastic delays relative to the continuous model - these delays can arise both in exportation - it can take longer to infect an individual in an uninfected location, and it can take longer for the outbreak to then progress from 1 individual to more, and the wavespeed will on average be slower.</p> <p>In fact, as long as $D&gt;0$ and $1/r &gt;1$, the continuous equation is guaranteed to support traveling waves, but for small D and small 1/r the stochastic version may simply die out in the initial node before successfully propagating to adjacent nodes, or it may die out at some subsequent node along the way.</p> <p>So as we fit this result, we should expect to see the observed wavespeed consistently be slower than expected at very high propagation speeds.  At lower propagation speeds, the match between model and theory will vary with the values of D, $\\beta$, $\\gamma$ - we should expect better match between theory and observation but with a general bias for observation to be slower.</p>"},{"location":"tutorials/notebooks/09_rabies_diffusion_1D/#the-transmission-network","title":"The transmission network\u00b6","text":"<p>Spatial transmission in this rabies model is contained in the diffusive term $D \\frac{\\partial^2 I}{\\partial x^2}$.  We are operating on a discretized 1-D grid, and will take advantage of the usual way to discretize a second derivative</p> <p>$$ D \\frac{\\partial^2 I}{\\partial x^2} \\rightarrow D \\frac {I_{x-h} - 2 I_{x} + I_{x+h}} {h^2} $$</p> <p>To translate this into a network structure for the model, we can arbitrarily set the  length scale $h$ to be 1 in units of the grid spacing.  Looking at the above, from the perspective of an arbitrary node $i$, the transmission matrix must \"send\" $D I_i$ units of infectivity to the adjacent nodes on either side, and remove that infectivity from the local pool.   Looking at the spatial transmission code (line 1006-8 in src/laser_generic/models/components.py), we see that spatial transmission is handled by multiplying the transmission matrix and the vector of infectivities by node, and that it internally handles subtracting the \"outbound infectivity\" from the local source.  Thus, the above discretization can be accomplished by filling the value $D$ on the first superdiagonal and subdiagonal of the transmission matrix, and 0 everywhere else.</p>"},{"location":"tutorials/notebooks/09_rabies_diffusion_1D/#results","title":"Results\u00b6","text":"<p>As expected, at high speeds the observed wavespeed is consistently slower than theoretical expetactation.  At slower wavespeeds, the model is more able to reproduce waves traveling around the correct speed, but there is still a bias towards the model being slower than expected.  Below, we will take a look at how the errors behave with model parameters.</p>"},{"location":"tutorials/notebooks/09_rabies_diffusion_1D/#discussion","title":"Discussion\u00b6","text":"<p>We can see clear vertical gradients in the error plots colored by $\\beta$ and infectious duration - lower values of $beta$, and longer infectious durations are both clearly correlated with producing observed waves that are slower than theoretical expectations.  This makes some sense - lower values of both parameters translate into lower per-infective, per-timestep force of infection, which can cause delays in both the important processes of spatial spread of infections and the growth of local outbreaks in each node.  The dependence on D is present but less obvious, as this parameter can only affect the delays related to spatial spread.</p>"},{"location":"tutorials/notebooks/10_England_and_Wales/","title":"Spatial features of measles transmission in England and Wales during the pre-vaccine era","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport numba as nb\nfrom pathlib import Path\nimport sys\nfrom laser.core.propertyset import PropertySet\nimport laser.core.distributions as dists\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nfrom laser.generic import SEIR\nfrom laser.generic import Model\nfrom laser.generic.utils import ValuesMap\nfrom laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator\nfrom laser.core.migration import gravity\nfrom laser.core.migration import row_normalizer\n\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\nfrom shapely.geometry import Point\nimport pywt\n\n\nimport laser.core\nimport laser.generic\n\ndata_dir = Path.cwd().parent.parent.parent / \"data\"\nsys.path.append(str(data_dir))\n\nfrom EnglandWalesMeasles import data as engwal\ndistances = np.load(data_dir / \"EnglandWalesDistances.npy\")\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd import numba as nb from pathlib import Path import sys from laser.core.propertyset import PropertySet import laser.core.distributions as dists from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator from laser.generic import SEIR from laser.generic import Model from laser.generic.utils import ValuesMap from laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator from laser.core.migration import gravity from laser.core.migration import row_normalizer  import matplotlib.pyplot as plt import geopandas as gpd from shapely.geometry import Point import pywt   import laser.core import laser.generic  data_dir = Path.cwd().parent.parent.parent / \"data\" sys.path.append(str(data_dir))  from EnglandWalesMeasles import data as engwal distances = np.load(data_dir / \"EnglandWalesDistances.npy\") print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.5'\nlaser.core.__version__='1.0.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>class Importation:\n    def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 30, count: int = 3, end_tick: int = 10*365):\n        self.model = model\n        self.infdurdist = infdurdist\n        self.infdurmin = infdurmin\n        self.period = period\n        self.count = count\n        self.end_tick = end_tick if end_tick is not None else model.params.nticks\n\n        self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)\n\n        return\n    \n    def step(self, tick: int) -&gt; None:\n        if tick &gt; 0 and tick % self.period == 0 and tick &lt; self.end_tick:\n            i_susceptible = np.nonzero(self.model.people.state == SEIR.State.SUSCEPTIBLE.value)[0]\n            if len(i_susceptible) &gt; 0:\n                count = min(self.count, len(i_susceptible))\n                i_infect = np.random.choice(i_susceptible, size=count, replace=False)\n                self.model.people.state[i_infect] = SEIR.State.INFECTIOUS.value\n                samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))\n                samples = np.round(samples)\n                samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)\n                self.model.people.itimer[i_infect] = samples\n                inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)\n                self.model.nodes.S[tick + 1] -= inf_by_node\n                self.model.nodes.I[tick + 1] += inf_by_node\n                self.model.nodes.imports[tick] = inf_by_node\n            # else:\n            #     print(f\"No susceptibles to infect at tick {tick}\")\n\n        return\n\nclass SeasonalTransmission(SEIR.Transmission):\n        \n    def step(self, tick: int) -&gt; None:\n        ft = self.model.nodes.forces[tick]\n\n        N = self.model.nodes.S[tick] + self.model.nodes.E[tick] + (I := self.model.nodes.I[tick])  # noqa: E741\n        # Might have R\n        if hasattr(self.model.nodes, \"R\"):\n            N += self.model.nodes.R[tick]\n\n        ft[:] = self.model.params.beta * I / N * self.model.params.beta_season[tick % 365]\n        transfer = ft[:, None] * self.model.network\n        ft += transfer.sum(axis=0)\n        ft -= transfer.sum(axis=1)\n        ft = -np.expm1(-ft)  # Convert to probability of infection\n\n        newly_infected_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.int32)\n        self.nb_transmission_step(\n            self.model.people.state,\n            self.model.people.nodeid,\n            ft,\n            newly_infected_by_node,\n            self.model.people.etimer,\n            self.expdurdist,\n            self.expdurmin,\n            tick,\n        )\n        newly_infected_by_node = newly_infected_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads\n\n        # state(t+1) = state(t) + \u2206state(t)\n        self.model.nodes.S[tick + 1] -= newly_infected_by_node\n        self.model.nodes.E[tick + 1] += newly_infected_by_node\n        # Record today's \u2206\n        self.model.nodes.newly_infected[tick] = newly_infected_by_node\n\n        return\n</pre> class Importation:     def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 30, count: int = 3, end_tick: int = 10*365):         self.model = model         self.infdurdist = infdurdist         self.infdurmin = infdurmin         self.period = period         self.count = count         self.end_tick = end_tick if end_tick is not None else model.params.nticks          self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)          return          def step(self, tick: int) -&gt; None:         if tick &gt; 0 and tick % self.period == 0 and tick &lt; self.end_tick:             i_susceptible = np.nonzero(self.model.people.state == SEIR.State.SUSCEPTIBLE.value)[0]             if len(i_susceptible) &gt; 0:                 count = min(self.count, len(i_susceptible))                 i_infect = np.random.choice(i_susceptible, size=count, replace=False)                 self.model.people.state[i_infect] = SEIR.State.INFECTIOUS.value                 samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))                 samples = np.round(samples)                 samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)                 self.model.people.itimer[i_infect] = samples                 inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)                 self.model.nodes.S[tick + 1] -= inf_by_node                 self.model.nodes.I[tick + 1] += inf_by_node                 self.model.nodes.imports[tick] = inf_by_node             # else:             #     print(f\"No susceptibles to infect at tick {tick}\")          return  class SeasonalTransmission(SEIR.Transmission):              def step(self, tick: int) -&gt; None:         ft = self.model.nodes.forces[tick]          N = self.model.nodes.S[tick] + self.model.nodes.E[tick] + (I := self.model.nodes.I[tick])  # noqa: E741         # Might have R         if hasattr(self.model.nodes, \"R\"):             N += self.model.nodes.R[tick]          ft[:] = self.model.params.beta * I / N * self.model.params.beta_season[tick % 365]         transfer = ft[:, None] * self.model.network         ft += transfer.sum(axis=0)         ft -= transfer.sum(axis=1)         ft = -np.expm1(-ft)  # Convert to probability of infection          newly_infected_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.int32)         self.nb_transmission_step(             self.model.people.state,             self.model.people.nodeid,             ft,             newly_infected_by_node,             self.model.people.etimer,             self.expdurdist,             self.expdurmin,             tick,         )         newly_infected_by_node = newly_infected_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads          # state(t+1) = state(t) + \u2206state(t)         self.model.nodes.S[tick + 1] -= newly_infected_by_node         self.model.nodes.E[tick + 1] += newly_infected_by_node         # Record today's \u2206         self.model.nodes.newly_infected[tick] = newly_infected_by_node          return In\u00a0[3]: Copied! <pre># See ../../../data/readme.md for a description of the England and Wales measles data contained there.  \n# We provide pre-computed pairwise distances between the population centers in EnglandWalesDistances.npy.\n# Here, we compute a population-wide average crude birth rate (CBR) for England and Wales from the data.\n\naverage_pop = np.array([np.mean(place.population) for place in engwal.places.values()])\naverage_birthrate = np.array([np.mean(place.births/place.population) for place in engwal.places.values()])\naverage_cbr = 1000*np.sum(average_pop*average_birthrate)/np.sum(average_pop)\nbirthrates = np.array([place.births/place.population *1000 for place in engwal.places.values()])\n</pre> # See ../../../data/readme.md for a description of the England and Wales measles data contained there.   # We provide pre-computed pairwise distances between the population centers in EnglandWalesDistances.npy. # Here, we compute a population-wide average crude birth rate (CBR) for England and Wales from the data.  average_pop = np.array([np.mean(place.population) for place in engwal.places.values()]) average_birthrate = np.array([np.mean(place.births/place.population) for place in engwal.places.values()]) average_cbr = 1000*np.sum(average_pop*average_birthrate)/np.sum(average_pop) birthrates = np.array([place.births/place.population *1000 for place in engwal.places.values()]) In\u00a0[4]: Copied! <pre># Define the geodataframe\ncells = []\nfor placename, place in engwal.places.items():\n    lat, long = place.latitude, place.longitude\n    nodeid = engwal.placenames.index(placename)\n    name = placename\n    # As long as we are here, record the proportion of weeks with zero cases.  \n    # Wavelet analysis is more complex and we will come back to that later.\n    prop_zero = np.mean(np.array(place.cases) == 0)\n\n    cells.append({\"nodeid\": nodeid, \"name\": name, \"population\": place.population[0], \"geometry\": Point(long, lat), \"prop_zero\": prop_zero})\n\nscenario = gpd.GeoDataFrame(cells, columns=[\"nodeid\", \"name\", \"population\", \"geometry\", \"prop_zero\"], crs=\"EPSG:4326\")\n</pre> # Define the geodataframe cells = [] for placename, place in engwal.places.items():     lat, long = place.latitude, place.longitude     nodeid = engwal.placenames.index(placename)     name = placename     # As long as we are here, record the proportion of weeks with zero cases.       # Wavelet analysis is more complex and we will come back to that later.     prop_zero = np.mean(np.array(place.cases) == 0)      cells.append({\"nodeid\": nodeid, \"name\": name, \"population\": place.population[0], \"geometry\": Point(long, lat), \"prop_zero\": prop_zero})  scenario = gpd.GeoDataFrame(cells, columns=[\"nodeid\", \"name\", \"population\", \"geometry\", \"prop_zero\"], crs=\"EPSG:4326\") In\u00a0[5]: Copied! <pre>run_sims = False\nstart_from_last = False\n</pre> run_sims = False start_from_last = False  In\u00a0[6]: Copied! <pre>output_file = Path(\"outputs\") / \"EW_outputs.npy\"\nparams_file = Path(\"outputs\") / \"EW_parameter_samples.csv\"\nnsims = 150\nnticks = 40*365\nnpatches = len(scenario)\nif run_sims:\n    istart = 0\n    if start_from_last and (output_file.exists() \n                            and params_file.exists()):\n\n        print(\"Resuming from last saved simulation...\")\n\n        outputs =np.load(output_file)\n        while istart &lt; outputs.shape[0] and np.any(outputs[istart]):\n            istart += 1\n        params_df = pd.read_csv(params_file)\n        beta_samples = params_df[\"beta\"].values\n        amplitude_samples = params_df[\"amplitude\"].values\n        k_samples = params_df[\"k\"].values\n        b_samples = params_df[\"b\"].values\n        c_samples = params_df[\"c\"].values\n\n    else:\n\n        print(\"Starting new set of simulations...\")\n\n        beta_samples = np.random.uniform(3, 4.5, nsims) #Ro from 24 to 36\n        amplitude_samples = np.random.uniform(0.5, 1.5, nsims) #1 will be exactly the seasonal forcing profile from reference above\n        k_samples = 10 ** np.random.uniform(-3.5, -1, nsims)\n        #a_samples = np.random.uniform(-0.5, 0.5, nsims)\n        b_samples = np.random.uniform(0.25, 1.0, nsims)\n        c_samples = np.random.uniform(1, 2, nsims)\n        params_df = pd.DataFrame({\n            \"beta\": beta_samples,\n            \"amplitude\": amplitude_samples,\n            \"k\": k_samples,\n            \"b\": b_samples,\n            \"c\": c_samples\n        })\n        Path(\"outputs\").mkdir(exist_ok=True)\n        params_df.to_csv(params_file, index=False)\n        outputs = np.zeros((nsims, (nticks+1) // 7, npatches), dtype=np.uint32)\n    \n    log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n        -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n    beta_season = np.repeat(log_betas, np.floor(365 / len(log_betas)).astype(int))\n    beta_season = np.append(beta_season, beta_season[-1])\n    beta_season = np.exp( (beta_season - np.mean(beta_season)) )\n\n    for i in range(istart, nsims):\n        print(f\"Running simulation {i+1} of {nsims}...\")\n        parameters = PropertySet(\n            {\"seed\": 4, \"nticks\": nticks,\n            \"exp_shape\": 40, \"exp_scale\": 0.25,\n            \"verbose\": True, \"beta\": beta_samples[i], \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": average_cbr,\n            \"beta_season\": beta_season**amplitude_samples[i],\n            \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365,\n            \"gravity_k\": k_samples[i], \"gravity_b\": b_samples[i], \"gravity_c\": c_samples[i],\n            \"skip_capacity\": False, \"capacity_safety_factor\": 3.0}\n        )\n\n        scenario[\"E\"] = 0\n        scenario[\"I\"] = 3\n        scenario[\"R\"] = np.round(0.95 * scenario.population).astype(np.uint32)\n        scenario[\"S\"] = scenario.population - scenario[\"E\"] - scenario[\"I\"] - scenario[\"R\"]\n\n        expdist = dists.gamma(shape=parameters.exp_shape, scale=parameters.exp_scale)\n        infdist = dists.normal(loc=parameters.inf_mean, scale=parameters.inf_sigma)\n\n        birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))\n        rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) # approximate annual to daily\n        stable_age_dist = np.array(1000*np.exp(-rate_const*np.arange(89)))\n        pyramid = AliasedDistribution(stable_age_dist)\n        survival = KaplanMeierEstimator(stable_age_dist.cumsum())\n        model = Model(scenario, parameters, birthrates=birthrate_map.values)\n\n        model.components = [\n            SEIR.Susceptible(model),\n            SEIR.Exposed(model, expdist, infdist),\n            SEIR.Infectious(model, infdist),\n            SEIR.Recovered(model),\n            Importation(model, infdist),\n            SeasonalTransmission(model, infdist),\n            BirthsByCBR(model, birthrates=birthrate_map.values, pyramid=pyramid),\n            MortalityByEstimator(model, estimator=survival),\n        ]\n\n        model.network = gravity(np.array(scenario.population), distances, 1, 0, model.params.gravity_b, model.params.gravity_c)\n        # The scale of the parameter k is actually unit-ful, and depends on the values of b and c.  \n        # To make k more interpretable, and avoid having to sample large swaths of useless parameter space,\n        # we rescale the network here so that the average export fraction is 1, then multiply by k.\n        average_export_frac = np.mean(model.network.sum(axis=1))\n        model.network = model.network / average_export_frac * model.params.gravity_k \n        model.network = row_normalizer(model.network, 0.2) #Don't let any individual node send more than 20% of its infectivity elsewhere.\n\n        model.run(f\"Sim {i+1}/{nsims}\")\n        incidence = model.nodes.newly_infected\n        num_weeks = incidence.shape[0] // 7\n        weekly_incidence = incidence[:num_weeks*7, :].reshape(num_weeks, 7, incidence.shape[1]).sum(axis=1)        \n        outputs[i, :, :] = weekly_incidence\n        np.save(output_file, outputs)\n</pre>  output_file = Path(\"outputs\") / \"EW_outputs.npy\" params_file = Path(\"outputs\") / \"EW_parameter_samples.csv\" nsims = 150 nticks = 40*365 npatches = len(scenario) if run_sims:     istart = 0     if start_from_last and (output_file.exists()                              and params_file.exists()):          print(\"Resuming from last saved simulation...\")          outputs =np.load(output_file)         while istart &lt; outputs.shape[0] and np.any(outputs[istart]):             istart += 1         params_df = pd.read_csv(params_file)         beta_samples = params_df[\"beta\"].values         amplitude_samples = params_df[\"amplitude\"].values         k_samples = params_df[\"k\"].values         b_samples = params_df[\"b\"].values         c_samples = params_df[\"c\"].values      else:          print(\"Starting new set of simulations...\")          beta_samples = np.random.uniform(3, 4.5, nsims) #Ro from 24 to 36         amplitude_samples = np.random.uniform(0.5, 1.5, nsims) #1 will be exactly the seasonal forcing profile from reference above         k_samples = 10 ** np.random.uniform(-3.5, -1, nsims)         #a_samples = np.random.uniform(-0.5, 0.5, nsims)         b_samples = np.random.uniform(0.25, 1.0, nsims)         c_samples = np.random.uniform(1, 2, nsims)         params_df = pd.DataFrame({             \"beta\": beta_samples,             \"amplitude\": amplitude_samples,             \"k\": k_samples,             \"b\": b_samples,             \"c\": c_samples         })         Path(\"outputs\").mkdir(exist_ok=True)         params_df.to_csv(params_file, index=False)         outputs = np.zeros((nsims, (nticks+1) // 7, npatches), dtype=np.uint32)          log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,         -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])     beta_season = np.repeat(log_betas, np.floor(365 / len(log_betas)).astype(int))     beta_season = np.append(beta_season, beta_season[-1])     beta_season = np.exp( (beta_season - np.mean(beta_season)) )      for i in range(istart, nsims):         print(f\"Running simulation {i+1} of {nsims}...\")         parameters = PropertySet(             {\"seed\": 4, \"nticks\": nticks,             \"exp_shape\": 40, \"exp_scale\": 0.25,             \"verbose\": True, \"beta\": beta_samples[i], \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": average_cbr,             \"beta_season\": beta_season**amplitude_samples[i],             \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365,             \"gravity_k\": k_samples[i], \"gravity_b\": b_samples[i], \"gravity_c\": c_samples[i],             \"skip_capacity\": False, \"capacity_safety_factor\": 3.0}         )          scenario[\"E\"] = 0         scenario[\"I\"] = 3         scenario[\"R\"] = np.round(0.95 * scenario.population).astype(np.uint32)         scenario[\"S\"] = scenario.population - scenario[\"E\"] - scenario[\"I\"] - scenario[\"R\"]          expdist = dists.gamma(shape=parameters.exp_shape, scale=parameters.exp_scale)         infdist = dists.normal(loc=parameters.inf_mean, scale=parameters.inf_sigma)          birthrate_map = ValuesMap.from_scalar(parameters.cbr, nticks=parameters.nticks, nnodes=len(scenario))         rate_const = 365 * ((1 + parameters.cbr / 1000) ** (1/365) - 1) # approximate annual to daily         stable_age_dist = np.array(1000*np.exp(-rate_const*np.arange(89)))         pyramid = AliasedDistribution(stable_age_dist)         survival = KaplanMeierEstimator(stable_age_dist.cumsum())         model = Model(scenario, parameters, birthrates=birthrate_map.values)          model.components = [             SEIR.Susceptible(model),             SEIR.Exposed(model, expdist, infdist),             SEIR.Infectious(model, infdist),             SEIR.Recovered(model),             Importation(model, infdist),             SeasonalTransmission(model, infdist),             BirthsByCBR(model, birthrates=birthrate_map.values, pyramid=pyramid),             MortalityByEstimator(model, estimator=survival),         ]          model.network = gravity(np.array(scenario.population), distances, 1, 0, model.params.gravity_b, model.params.gravity_c)         # The scale of the parameter k is actually unit-ful, and depends on the values of b and c.           # To make k more interpretable, and avoid having to sample large swaths of useless parameter space,         # we rescale the network here so that the average export fraction is 1, then multiply by k.         average_export_frac = np.mean(model.network.sum(axis=1))         model.network = model.network / average_export_frac * model.params.gravity_k          model.network = row_normalizer(model.network, 0.2) #Don't let any individual node send more than 20% of its infectivity elsewhere.          model.run(f\"Sim {i+1}/{nsims}\")         incidence = model.nodes.newly_infected         num_weeks = incidence.shape[0] // 7         weekly_incidence = incidence[:num_weeks*7, :].reshape(num_weeks, 7, incidence.shape[1]).sum(axis=1)                 outputs[i, :, :] = weekly_incidence         np.save(output_file, outputs) In\u00a0[\u00a0]: Copied! <pre>outputs_file = Path(\"outputs\") / \"EW_outputs.npy\"\nparams_file = Path(\"outputs\") / \"EW_parameter_samples.csv\"\n\nif outputs_file.exists() and params_file.exists():\n\n    weekly_incidence = np.load(outputs_file)\n    params_df = pd.read_csv(params_file)\n    results_df = params_df.copy()\n\n    prop_zero = np.mean(weekly_incidence[:, 1040:, :]==0, axis=1)\n    prop_low = np.mean(weekly_incidence[:, 1040:, :]&lt;=2, axis=1)\n\n    results_df[\"prop_zero\"] = list(prop_zero)\n    results_df[\"prop_low\"] = list(prop_low)\n\nelse:\n\n    print(\"No simulation outputs found.  Please run the simulations first.\")\n    results_df = None\n</pre> outputs_file = Path(\"outputs\") / \"EW_outputs.npy\" params_file = Path(\"outputs\") / \"EW_parameter_samples.csv\"  if outputs_file.exists() and params_file.exists():      weekly_incidence = np.load(outputs_file)     params_df = pd.read_csv(params_file)     results_df = params_df.copy()      prop_zero = np.mean(weekly_incidence[:, 1040:, :]==0, axis=1)     prop_low = np.mean(weekly_incidence[:, 1040:, :]&lt;=2, axis=1)      results_df[\"prop_zero\"] = list(prop_zero)     results_df[\"prop_low\"] = list(prop_low)  else:      print(\"No simulation outputs found.  Please run the simulations first.\")     results_df = None  In\u00a0[\u00a0]: Copied! <pre>from scipy.optimize import curve_fit\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 1. Define fitting functions for mean and variance\ndef logistic(x, x0, k):\n    # Logistic function bounded between 0 and 1, transitions from 1 to 0 as x increases\n    return 1 / (1 + np.exp(k * (x - x0)))\n\ndef fit_mean_var(x, y):\n    # Fit a logistic to the mean\n    # Initial guess: midpoint at median(x), width=1\n    p0 = [np.median(x), 1.0]\n    bounds = ([-np.inf, 0.01], [np.inf, 10.0])\n    popt_mean, _ = curve_fit(logistic, x, y, p0=p0, bounds=bounds, maxfev=10000)\n    return popt_mean\n\n# 3. Define similarity metric (sum of squared differences of mean and variance fits)\ndef similarity_metric(mean_data, mean_sim):\n    # Evaluate both curves on a common grid\n    x_grid = np.linspace(2.5, 6.5, 200)\n    data_curve = logistic(x_grid, *mean_data)\n    sim_curve = logistic(x_grid, *mean_sim)\n    # Similarity: sum of squared differences between the curves\n    mean_diff = np.sum((sim_curve - data_curve) ** 2)\n    return mean_diff\n\nsimilarity = []\n\nif results_df is not None:\n\n    for i in results_df.index:\n        # Plot observed and simulated data\n        logpop_obs = np.log10(scenario.population)\n        prop_zero_obs = scenario.prop_zero\n        logpop_sim = np.log10(scenario.population)\n        prop_zero_sim = results_df.loc[i]['prop_zero']\n\n        # Fit to observed\n        popt_obs = fit_mean_var(logpop_obs, prop_zero_obs)\n        popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)\n        # Similarity metric\n        similarity.append(similarity_metric(popt_obs, popt_sim))\n\n    results_df[\"similarity_CCS\"] = similarity\n\nelse:\n\n    print(\"No results dataframe found.  Please run the simulations first.\")\n</pre> from scipy.optimize import curve_fit from mpl_toolkits.mplot3d import Axes3D  # 1. Define fitting functions for mean and variance def logistic(x, x0, k):     # Logistic function bounded between 0 and 1, transitions from 1 to 0 as x increases     return 1 / (1 + np.exp(k * (x - x0)))  def fit_mean_var(x, y):     # Fit a logistic to the mean     # Initial guess: midpoint at median(x), width=1     p0 = [np.median(x), 1.0]     bounds = ([-np.inf, 0.01], [np.inf, 10.0])     popt_mean, _ = curve_fit(logistic, x, y, p0=p0, bounds=bounds, maxfev=10000)     return popt_mean  # 3. Define similarity metric (sum of squared differences of mean and variance fits) def similarity_metric(mean_data, mean_sim):     # Evaluate both curves on a common grid     x_grid = np.linspace(2.5, 6.5, 200)     data_curve = logistic(x_grid, *mean_data)     sim_curve = logistic(x_grid, *mean_sim)     # Similarity: sum of squared differences between the curves     mean_diff = np.sum((sim_curve - data_curve) ** 2)     return mean_diff  similarity = []  if results_df is not None:      for i in results_df.index:         # Plot observed and simulated data         logpop_obs = np.log10(scenario.population)         prop_zero_obs = scenario.prop_zero         logpop_sim = np.log10(scenario.population)         prop_zero_sim = results_df.loc[i]['prop_zero']          # Fit to observed         popt_obs = fit_mean_var(logpop_obs, prop_zero_obs)         popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)         # Similarity metric         similarity.append(similarity_metric(popt_obs, popt_sim))      results_df[\"similarity_CCS\"] = similarity  else:      print(\"No results dataframe found.  Please run the simulations first.\")  In\u00a0[9]: Copied! <pre>if results_df is not None:\n\n    fig, axes = plt.subplots(6, 2, figsize=(14, 18))\n    axes = axes.flatten()\n\n    ranked_params = results_df.sort_values('similarity_CCS', ascending=True).reset_index(drop=True)\n    ranked_params[0:20]\n\n    for idx in range(12):\n        # Get the parameter set with the idx-th lowest similarity\n        beta_best, amp_best, k_best, b_best, c_best = ranked_params.loc[idx, ['beta', 'amplitude', 'k', 'b', 'c']]\n        sim_score = ranked_params.loc[idx, 'similarity_CCS']\n        prop_zero_sim = ranked_params.loc[idx, 'prop_zero']\n\n        # Fit logistic to simulation\n        popt_sim = fit_mean_var(np.log10(scenario.population), prop_zero_sim)\n        # Fit logistic to observed (reuse from above)\n        popt_obs = fit_mean_var(np.log10(scenario.population), scenario.prop_zero)\n\n        xfit = np.linspace(2.8, 6.4, 200)\n        axes[idx].plot(np.log10(scenario.population), scenario.prop_zero, 'o', label='Observed', alpha=0.6)\n        axes[idx].plot(np.log10(scenario.population), prop_zero_sim, 'o', label='Simulated', alpha=0.6)\n        axes[idx].plot(xfit, logistic(xfit, *popt_obs), '-', label='Obs fit', color='C0')\n        axes[idx].plot(xfit, logistic(xfit, *popt_sim), '-', label='Sim fit', color='C1')\n        axes[idx].set_title(f\"beta={beta_best:.2f}, amplitude={amp_best:.2f}, k={k_best:.1e}, b={b_best:.2f}, c={c_best:.2f}, similarity={sim_score:.3f}\")\n        axes[idx].set_xlabel(\"log10(Population)\")\n        axes[idx].set_ylabel(\"Proportion zero\")\n        axes[idx].legend()\n\n    plt.tight_layout()\n    plt.show()\n\nelse:\n\n    print(\"No results dataframe found.  Please run the simulations first.\")\n</pre> if results_df is not None:      fig, axes = plt.subplots(6, 2, figsize=(14, 18))     axes = axes.flatten()      ranked_params = results_df.sort_values('similarity_CCS', ascending=True).reset_index(drop=True)     ranked_params[0:20]      for idx in range(12):         # Get the parameter set with the idx-th lowest similarity         beta_best, amp_best, k_best, b_best, c_best = ranked_params.loc[idx, ['beta', 'amplitude', 'k', 'b', 'c']]         sim_score = ranked_params.loc[idx, 'similarity_CCS']         prop_zero_sim = ranked_params.loc[idx, 'prop_zero']          # Fit logistic to simulation         popt_sim = fit_mean_var(np.log10(scenario.population), prop_zero_sim)         # Fit logistic to observed (reuse from above)         popt_obs = fit_mean_var(np.log10(scenario.population), scenario.prop_zero)          xfit = np.linspace(2.8, 6.4, 200)         axes[idx].plot(np.log10(scenario.population), scenario.prop_zero, 'o', label='Observed', alpha=0.6)         axes[idx].plot(np.log10(scenario.population), prop_zero_sim, 'o', label='Simulated', alpha=0.6)         axes[idx].plot(xfit, logistic(xfit, *popt_obs), '-', label='Obs fit', color='C0')         axes[idx].plot(xfit, logistic(xfit, *popt_sim), '-', label='Sim fit', color='C1')         axes[idx].set_title(f\"beta={beta_best:.2f}, amplitude={amp_best:.2f}, k={k_best:.1e}, b={b_best:.2f}, c={c_best:.2f}, similarity={sim_score:.3f}\")         axes[idx].set_xlabel(\"log10(Population)\")         axes[idx].set_ylabel(\"Proportion zero\")         axes[idx].legend()      plt.tight_layout()     plt.show()  else:      print(\"No results dataframe found.  Please run the simulations first.\") In\u00a0[10]: Copied! <pre>def pad_data(x):\n    \"\"\"\n    Pad data to the next power of 2\n    \"\"\"\n    nx = len(x) # number of samples\n    nx2 = (2**np.ceil(np.log(nx)/np.log(2))).astype(int) # next power of 2\n    x2 = np.zeros(nx2, dtype=x.dtype) # pad to next power of 2\n    offset = (nx2-nx)//2 # offset\n    x2[offset:(offset+nx)] = x # copy\n    return x2\n\ndef log_transform(x, debug=1):\n    \"\"\"\n    Log transform for case data\n    \"\"\" \n    # add one and take log\n    x = np.log(x+1)\n    # set mean=0 and std=1\n    m = np.mean(x)\n    s = np.std(x)\n    x = (x - m)/s\n    return x\n\n\ndef calc_Ws(cases):\n    # transform case data\n    log_cases = pad_data(log_transform(cases))\n\n    # setup and execute wavelet transform\n    # https://pywavelets.readthedocs.io/en/latest/ref/cwt.html#morlet-wavelet\n    wavelet = pywt.ContinuousWavelet('cmor2-1')\n\n    dt = 1 # 2 weeks\n    widths = np.logspace(np.log10(1), np.log10(7*52), int(7*52))\n    [cwt, frequencies] = pywt.cwt(log_cases, widths, wavelet, dt)\n\n    # Number of time steps in padded time series\n    nt = len(cases)\n    # trim matrix\n    offset = (cwt.shape[1] - nt) // 2\n    cwt = cwt[:, offset:offset + nt]\n\n    return cwt, frequencies\n</pre> def pad_data(x):     \"\"\"     Pad data to the next power of 2     \"\"\"     nx = len(x) # number of samples     nx2 = (2**np.ceil(np.log(nx)/np.log(2))).astype(int) # next power of 2     x2 = np.zeros(nx2, dtype=x.dtype) # pad to next power of 2     offset = (nx2-nx)//2 # offset     x2[offset:(offset+nx)] = x # copy     return x2  def log_transform(x, debug=1):     \"\"\"     Log transform for case data     \"\"\"      # add one and take log     x = np.log(x+1)     # set mean=0 and std=1     m = np.mean(x)     s = np.std(x)     x = (x - m)/s     return x   def calc_Ws(cases):     # transform case data     log_cases = pad_data(log_transform(cases))      # setup and execute wavelet transform     # https://pywavelets.readthedocs.io/en/latest/ref/cwt.html#morlet-wavelet     wavelet = pywt.ContinuousWavelet('cmor2-1')      dt = 1 # 2 weeks     widths = np.logspace(np.log10(1), np.log10(7*52), int(7*52))     [cwt, frequencies] = pywt.cwt(log_cases, widths, wavelet, dt)      # Number of time steps in padded time series     nt = len(cases)     # trim matrix     offset = (cwt.shape[1] - nt) // 2     cwt = cwt[:, offset:offset + nt]      return cwt, frequencies  In\u00a0[11]: Copied! <pre>def wavelet_phase_diff(data, distances, ref_cwt):\n\n    if isinstance(data, pd.DataFrame):\n        x = np.zeros(len(data))\n        y = np.zeros(len(data))\n        y2 = np.zeros(len(data))\n        for i, row in data.iterrows():\n            if distances[i] &gt; 30:\n                continue\n            cwt, frequencies = calc_Ws(row[\"cases\"].flatten())\n            diff = ref_cwt*np.conj(cwt)\n            ind = np.where(np.logical_and(frequencies &lt; 1/(1.5 * 52), frequencies &gt; 1 / (3 * 52))) #Frequencies around 2 year periods.\n            diff1 = diff[ind[0], :]\n            x[i] = distances[i]\n            y[i] = np.angle(np.mean(diff1))\n            ind2 = np.where(np.logical_and(frequencies &lt; 1/(0.75 * 52), frequencies &gt; 1 / (1.25 * 52))) #Frequencies around 1 year periods\n            diff2 = diff[ind2[0], :]\n            y2[i] = np.angle(np.mean(diff2))\n            \n    elif isinstance(data, np.ndarray):\n        # initialize output arrays\n        x = np.zeros(data.shape[1])\n        y = np.zeros(data.shape[1])\n        y2 = np.zeros(data.shape[1])\n        for i in range(data.shape[1]):\n            if distances[i] &gt; 30:\n                continue\n            cwt, frequencies = calc_Ws(data[:, i].flatten())\n            diff = ref_cwt*np.conj(cwt)\n            ind = np.where(np.logical_and(frequencies &lt; 1/(1.5 * 52), frequencies &gt; 1 / (3 * 52)))\n            diff1 = diff[ind[0], :]\n            x[i] = distances[i]\n            y[i] = np.angle(np.mean(diff1))\n            ind2 = np.where(np.logical_and(frequencies &lt; 1/(0.75 * 52), frequencies &gt; 1 / (1.25 * 52)))\n            diff2 = diff[ind2[0], :]\n            y2[i] = np.angle(np.mean(diff2))\n\n    return x, y, y2\n</pre> def wavelet_phase_diff(data, distances, ref_cwt):      if isinstance(data, pd.DataFrame):         x = np.zeros(len(data))         y = np.zeros(len(data))         y2 = np.zeros(len(data))         for i, row in data.iterrows():             if distances[i] &gt; 30:                 continue             cwt, frequencies = calc_Ws(row[\"cases\"].flatten())             diff = ref_cwt*np.conj(cwt)             ind = np.where(np.logical_and(frequencies &lt; 1/(1.5 * 52), frequencies &gt; 1 / (3 * 52))) #Frequencies around 2 year periods.             diff1 = diff[ind[0], :]             x[i] = distances[i]             y[i] = np.angle(np.mean(diff1))             ind2 = np.where(np.logical_and(frequencies &lt; 1/(0.75 * 52), frequencies &gt; 1 / (1.25 * 52))) #Frequencies around 1 year periods             diff2 = diff[ind2[0], :]             y2[i] = np.angle(np.mean(diff2))                  elif isinstance(data, np.ndarray):         # initialize output arrays         x = np.zeros(data.shape[1])         y = np.zeros(data.shape[1])         y2 = np.zeros(data.shape[1])         for i in range(data.shape[1]):             if distances[i] &gt; 30:                 continue             cwt, frequencies = calc_Ws(data[:, i].flatten())             diff = ref_cwt*np.conj(cwt)             ind = np.where(np.logical_and(frequencies &lt; 1/(1.5 * 52), frequencies &gt; 1 / (3 * 52)))             diff1 = diff[ind[0], :]             x[i] = distances[i]             y[i] = np.angle(np.mean(diff1))             ind2 = np.where(np.logical_and(frequencies &lt; 1/(0.75 * 52), frequencies &gt; 1 / (1.25 * 52)))             diff2 = diff[ind2[0], :]             y2[i] = np.angle(np.mean(diff2))      return x, y, y2  In\u00a0[12]: Copied! <pre># Get the cases for London from EWdata\ndistances = np.load(data_dir / \"EnglandWalesDistances.npy\")\n\nEWdata = pd.DataFrame([{\"name\": placename,\n         \"population\": place.population[0],\n         \"latitude\": place.latitude,\n         \"longitude\": place.longitude} for placename, place in engwal.places.items()])\n\nEWdata[\"cases\"] = EWdata[\"name\"].apply(lambda name: engwal.places[name].cases)\n\n# Calculate distances between all locations\nlocations = np.array([[place.latitude, place.longitude] for place in engwal.places.values()])\n\n# Calculate wavelet transforms and phase differences from London\nlondon_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\nlondon_cases = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]\n\nref_cwt, frequencies = calc_Ws(np.array(london_cases.flatten()))\ndistances_from_london = distances[london_idx, :]\n\nx_data, y_data, y2_data = wavelet_phase_diff(  EWdata, distances_from_london, ref_cwt)\n# Plot phase differences\nplt.plot(x_data, -y_data*180/np.pi, 'o')\nplt.xlim(5, 30)\nplt.ylim(-90, 0)\nplt.xlabel(\"Distance from London\")\nplt.ylabel(\"Phase difference\")\nplt.title(\"Phase difference of London wavelet transform\")\nplt.show()\n</pre> # Get the cases for London from EWdata distances = np.load(data_dir / \"EnglandWalesDistances.npy\")  EWdata = pd.DataFrame([{\"name\": placename,          \"population\": place.population[0],          \"latitude\": place.latitude,          \"longitude\": place.longitude} for placename, place in engwal.places.items()])  EWdata[\"cases\"] = EWdata[\"name\"].apply(lambda name: engwal.places[name].cases)  # Calculate distances between all locations locations = np.array([[place.latitude, place.longitude] for place in engwal.places.values()])  # Calculate wavelet transforms and phase differences from London london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0] london_cases = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]  ref_cwt, frequencies = calc_Ws(np.array(london_cases.flatten())) distances_from_london = distances[london_idx, :]  x_data, y_data, y2_data = wavelet_phase_diff(  EWdata, distances_from_london, ref_cwt) # Plot phase differences plt.plot(x_data, -y_data*180/np.pi, 'o') plt.xlim(5, 30) plt.ylim(-90, 0) plt.xlabel(\"Distance from London\") plt.ylabel(\"Phase difference\") plt.title(\"Phase difference of London wavelet transform\") plt.show() In\u00a0[13]: Copied! <pre>from tqdm import tqdm\n\ndf_file = Path('outputs') / 'EW_analysis_results.pkl'\n\nrecompute_wavelet = True\nif recompute_wavelet:\n\n    if results_df is not None:\n\n        results_df[\"wavelet_y\"] = None\n        results_df[\"wavelet_y2\"] = None\n\n        for sim_idx in tqdm(range(weekly_incidence.shape[0])):\n            cases = weekly_incidence[sim_idx, :, :]\n            # Get London cases for this simulation\n            london_cases_sim = cases[:, london_idx].flatten()\n            ref_cwt_sim, frequencies_sim = calc_Ws(np.array(london_cases_sim[520:]).flatten())\n\n            x_sim, y_sim, y2_sim = wavelet_phase_diff(cases[520:, :], distances_from_london, ref_cwt_sim)\n            results_df.at[sim_idx, \"wavelet_y\"] = y_sim\n            results_df.at[sim_idx, \"wavelet_y2\"] = y2_sim\n        # Save the DataFrame using pandas to preserve all columns and types\n        results_df.to_pickle(df_file)\n\n    else:\n\n        print(\"Results dataframe is not available. Please run the simulations first.\")\n\nelse:\n\n    if df_file.exists():\n        # Load using pandas to get the full DataFrame back\n        results_df = pd.read_pickle(df_file)\n\n    else:\n\n        print(\"No results dataframe found.  Please run the simulations first.\")\n</pre> from tqdm import tqdm  df_file = Path('outputs') / 'EW_analysis_results.pkl'  recompute_wavelet = True if recompute_wavelet:      if results_df is not None:          results_df[\"wavelet_y\"] = None         results_df[\"wavelet_y2\"] = None          for sim_idx in tqdm(range(weekly_incidence.shape[0])):             cases = weekly_incidence[sim_idx, :, :]             # Get London cases for this simulation             london_cases_sim = cases[:, london_idx].flatten()             ref_cwt_sim, frequencies_sim = calc_Ws(np.array(london_cases_sim[520:]).flatten())              x_sim, y_sim, y2_sim = wavelet_phase_diff(cases[520:, :], distances_from_london, ref_cwt_sim)             results_df.at[sim_idx, \"wavelet_y\"] = y_sim             results_df.at[sim_idx, \"wavelet_y2\"] = y2_sim         # Save the DataFrame using pandas to preserve all columns and types         results_df.to_pickle(df_file)      else:          print(\"Results dataframe is not available. Please run the simulations first.\")  else:      if df_file.exists():         # Load using pandas to get the full DataFrame back         results_df = pd.read_pickle(df_file)      else:          print(\"No results dataframe found.  Please run the simulations first.\")  <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 150/150 [35:17&lt;00:00, 14.11s/it]\n</pre> In\u00a0[14]: Copied! <pre>from scipy.stats import linregress\n\nif x_data is not None and y_data is not None and results_df is not None:\n\n    mask_data = (x_data &gt; 0) &amp; (y_data != 0)\n    slope_data, intercept_data, _, _, _ = linregress(x_data[mask_data], -180/np.pi*y_data[mask_data])\n    # Compute variance of observed phase differences\n    var_data = np.var(-180/np.pi*y_data[mask_data])\n\n    # Define similarity metric as sum of squared differences between observed and simulated phase differences for each city in the mask\n    def phase_similarity(y_obs, y_sim, mask):\n        # Only compare where both masks are valid\n        return np.sum(((-180/np.pi)*y_obs[mask] - (-180/np.pi)*y_sim[mask])**2)\n\n    sim_phase_diffs = []\n    for idx, row in results_df.iterrows():\n        y_sim = row['wavelet_y']\n        if isinstance(y_sim, np.ndarray):\n            mask_sim = (x_data &gt; 0) &amp; (y_sim != 0) &amp; (y_data != 0)\n            if np.any(mask_sim):\n                sim_phase_diffs.append(phase_similarity(y_data, y_sim, mask_sim))\n            else:\n                sim_phase_diffs.append(np.nan)\n        else:\n            sim_phase_diffs.append(np.nan)\n\n    results_df['wavelet_phase_similarity'] = sim_phase_diffs\n\n    # Find the 10 simulations with the lowest phase similarity (best match)\n    top10_idx = np.argsort(results_df['wavelet_phase_similarity'].values)[:10]\n\n    for i, idx in enumerate(top10_idx):\n        plt.figure(figsize=(10, 6))\n        y_sim = results_df.loc[idx, 'wavelet_y']\n        if isinstance(y_sim, np.ndarray):\n            plt.plot(x_data, -180/np.pi*y_data, 'ko', label='Observed')\n            plt.plot(x_data, -180/np.pi*y_sim, '.', alpha=0.6, label=f'Sim {idx} (sim={results_df.loc[idx, \"wavelet_phase_similarity\"]:.1f})')\n            plt.xlabel('Distance from London')\n            plt.ylabel('Phase difference')\n            plt.title(f'Simulation {idx} Wavelet Phase Similarity')\n            plt.legend()\n            plt.show()\n\nelse:\n\n    print(\"x_data/y_data and/or results dataframe not found.  Please run the simulations first.\")\n</pre> from scipy.stats import linregress  if x_data is not None and y_data is not None and results_df is not None:      mask_data = (x_data &gt; 0) &amp; (y_data != 0)     slope_data, intercept_data, _, _, _ = linregress(x_data[mask_data], -180/np.pi*y_data[mask_data])     # Compute variance of observed phase differences     var_data = np.var(-180/np.pi*y_data[mask_data])      # Define similarity metric as sum of squared differences between observed and simulated phase differences for each city in the mask     def phase_similarity(y_obs, y_sim, mask):         # Only compare where both masks are valid         return np.sum(((-180/np.pi)*y_obs[mask] - (-180/np.pi)*y_sim[mask])**2)      sim_phase_diffs = []     for idx, row in results_df.iterrows():         y_sim = row['wavelet_y']         if isinstance(y_sim, np.ndarray):             mask_sim = (x_data &gt; 0) &amp; (y_sim != 0) &amp; (y_data != 0)             if np.any(mask_sim):                 sim_phase_diffs.append(phase_similarity(y_data, y_sim, mask_sim))             else:                 sim_phase_diffs.append(np.nan)         else:             sim_phase_diffs.append(np.nan)      results_df['wavelet_phase_similarity'] = sim_phase_diffs      # Find the 10 simulations with the lowest phase similarity (best match)     top10_idx = np.argsort(results_df['wavelet_phase_similarity'].values)[:10]      for i, idx in enumerate(top10_idx):         plt.figure(figsize=(10, 6))         y_sim = results_df.loc[idx, 'wavelet_y']         if isinstance(y_sim, np.ndarray):             plt.plot(x_data, -180/np.pi*y_data, 'ko', label='Observed')             plt.plot(x_data, -180/np.pi*y_sim, '.', alpha=0.6, label=f'Sim {idx} (sim={results_df.loc[idx, \"wavelet_phase_similarity\"]:.1f})')             plt.xlabel('Distance from London')             plt.ylabel('Phase difference')             plt.title(f'Simulation {idx} Wavelet Phase Similarity')             plt.legend()             plt.show()  else:      print(\"x_data/y_data and/or results dataframe not found.  Please run the simulations first.\") In\u00a0[15]: Copied! <pre>if results_df is not None and x_data is not None and y_data is not None:\n\n    # Rank the simulations by CCS similarity (lower is better)\n    ccs_ranks = results_df['similarity_CCS'].rank(method='min', ascending=True)\n    # Rank the simulations by wavelet phase similarity (lower is better)\n    phase_ranks = results_df['wavelet_phase_similarity'].rank(method='min', ascending=True)\n\n    # Combine the ranks (sum of ranks, lower is better)\n    combined_rank = ccs_ranks + phase_ranks\n\n    # Find the index of the simulation with the lowest combined rank\n    best_idx = combined_rank.idxmin()\n\n    print(f\"Best combined similarity simulation index: {best_idx}\")\n    print(\"Parameters:\")\n    print(results_df.loc[best_idx, ['beta', 'amplitude', 'k', 'b', 'c']])\n    print(\"CCS similarity rank:\", ccs_ranks[best_idx])\n    print(\"Wavelet phase similarity rank:\", phase_ranks[best_idx])\n\n    # Plot CCS (proportion zero vs log10(population))\n    plt.figure(figsize=(8, 5))\n    plt.plot(np.log10(model.scenario.population), model.scenario.prop_zero, 'o', label='Observed')\n    plt.plot(np.log10(model.scenario.population), results_df.loc[best_idx, 'prop_zero'], 'o', label='Simulated')\n    xfit = np.linspace(2.8, 6.4, 200)\n    popt_obs = fit_mean_var(np.log10(model.scenario.population), model.scenario.prop_zero)\n    popt_sim = fit_mean_var(np.log10(model.scenario.population), results_df.loc[best_idx, 'prop_zero'])\n    plt.plot(xfit, logistic(xfit, *popt_obs), '-', color='C0', label='Obs fit')\n    plt.plot(xfit, logistic(xfit, *popt_sim), '-', color='C1', label='Sim fit')\n    plt.xlabel('log10(Population)')\n    plt.ylabel('Proportion zero')\n    plt.title('CCS Plot\\n' + ', '.join([f'{k}={results_df.loc[best_idx, k]:.3g}' for k in ['beta','amplitude','k','b','c']]))\n    plt.legend()\n    plt.tight_layout()\n    plt.show()\n\n    # Plot wavelet phase difference\n    y_sim = results_df.loc[best_idx, 'wavelet_y']\n    plt.figure(figsize=(8, 5))\n    plt.plot(x_data, -180/np.pi*y_data, 'ko', label='Observed')\n    if isinstance(y_sim, np.ndarray):\n        plt.plot(x_data, -180/np.pi*y_sim, 'o', alpha=0.7, label='Simulated')\n    plt.xlabel('Distance from London')\n    plt.ylabel('Phase difference')\n    plt.title('Wavelet Phase Plot\\n' + ', '.join([f'{k}={results_df.loc[best_idx, k]:.3g}' for k in ['beta','amplitude','k','b','c']]))\n    plt.legend()\n    plt.tight_layout()\n    plt.show()\n\nelse:\n\n    print(\"results dataframe and/or x_data/y_data not found.  Please run the simulations first.\")\n</pre> if results_df is not None and x_data is not None and y_data is not None:      # Rank the simulations by CCS similarity (lower is better)     ccs_ranks = results_df['similarity_CCS'].rank(method='min', ascending=True)     # Rank the simulations by wavelet phase similarity (lower is better)     phase_ranks = results_df['wavelet_phase_similarity'].rank(method='min', ascending=True)      # Combine the ranks (sum of ranks, lower is better)     combined_rank = ccs_ranks + phase_ranks      # Find the index of the simulation with the lowest combined rank     best_idx = combined_rank.idxmin()      print(f\"Best combined similarity simulation index: {best_idx}\")     print(\"Parameters:\")     print(results_df.loc[best_idx, ['beta', 'amplitude', 'k', 'b', 'c']])     print(\"CCS similarity rank:\", ccs_ranks[best_idx])     print(\"Wavelet phase similarity rank:\", phase_ranks[best_idx])      # Plot CCS (proportion zero vs log10(population))     plt.figure(figsize=(8, 5))     plt.plot(np.log10(model.scenario.population), model.scenario.prop_zero, 'o', label='Observed')     plt.plot(np.log10(model.scenario.population), results_df.loc[best_idx, 'prop_zero'], 'o', label='Simulated')     xfit = np.linspace(2.8, 6.4, 200)     popt_obs = fit_mean_var(np.log10(model.scenario.population), model.scenario.prop_zero)     popt_sim = fit_mean_var(np.log10(model.scenario.population), results_df.loc[best_idx, 'prop_zero'])     plt.plot(xfit, logistic(xfit, *popt_obs), '-', color='C0', label='Obs fit')     plt.plot(xfit, logistic(xfit, *popt_sim), '-', color='C1', label='Sim fit')     plt.xlabel('log10(Population)')     plt.ylabel('Proportion zero')     plt.title('CCS Plot\\n' + ', '.join([f'{k}={results_df.loc[best_idx, k]:.3g}' for k in ['beta','amplitude','k','b','c']]))     plt.legend()     plt.tight_layout()     plt.show()      # Plot wavelet phase difference     y_sim = results_df.loc[best_idx, 'wavelet_y']     plt.figure(figsize=(8, 5))     plt.plot(x_data, -180/np.pi*y_data, 'ko', label='Observed')     if isinstance(y_sim, np.ndarray):         plt.plot(x_data, -180/np.pi*y_sim, 'o', alpha=0.7, label='Simulated')     plt.xlabel('Distance from London')     plt.ylabel('Phase difference')     plt.title('Wavelet Phase Plot\\n' + ', '.join([f'{k}={results_df.loc[best_idx, k]:.3g}' for k in ['beta','amplitude','k','b','c']]))     plt.legend()     plt.tight_layout()     plt.show()  else:      print(\"results dataframe and/or x_data/y_data not found.  Please run the simulations first.\") <pre>Best combined similarity simulation index: 56\nParameters:\nbeta         3.865332\namplitude    1.310744\nk            0.044565\nb            0.251464\nc            1.563193\nName: 56, dtype: object\nCCS similarity rank: 2.0\nWavelet phase similarity rank: 3.0\n</pre>"},{"location":"tutorials/notebooks/10_England_and_Wales/#spatial-features-of-measles-transmission-in-england-and-wales-during-the-pre-vaccine-era","title":"Spatial features of measles transmission in England and Wales during the pre-vaccine era\u00b6","text":"<p>In this notebook, we will move away from theoretical results and aim to model a famous observational dataset in disease transmission - records of measles cases in England and Wales during the pre-vaccine era.  This is a dataset that has been modeled in a number of famous publications and used to demonstrate phenomena like switching from annual to biennial epidemics in the face of demographic changes, traveling wave-like behavior from cities to smaller population centers around them, and disease extinction in sub-CCS populations followed by reimportation from elsewhere.  Here, we will aim to reproduce two of these results in a single spatial model - the demonstration of traveling waves of infection from Grenfell BT, Bj\u00f8rnstad ON, Kappey J. Travelling waves and spatial hierarchies in measles epidemics. Nature. 2001 Dec 13;414(6865):716-23, and the interplay between exinction and reimportation vs. population size from Conlan AJ et al. Resolving the impact of waiting time distributions on the persistence of measles. J R Soc Interface. 2010 Apr 6;7(45):623-40.</p> <p>This notebook will also demonstrate construction of a spatial population scenario representing real populations, rather than the grids used up until now.  This dataset also covers a period of time with important dynamics in birth and deaths rates, that produce their own interesting impacts on measles dynamics, but for now we will model constant birth and death rates as the phenomena we seek to reproduce are driven more by spatial connections between populations.  In the future, we will return to this scenario and also use this to demonstrate for users how to set up spatiotemporally varying demographics from existing datasets.</p>"},{"location":"tutorials/notebooks/10_England_and_Wales/#note","title":"NOTE\u00b6","text":"<p>The 150 sims below - ~30M agents for 20 years - take some hours to run even on modern hardware. If you want to re-run the sims, consider running this part of the notebook overnight.</p>"},{"location":"tutorials/notebooks/10_England_and_Wales/#calibration","title":"Calibration\u00b6","text":"<p>In order to reproduce the fadeout/reimportation phenomenon and the travelling wave dynamics observed in the measles dataset, we will have to undergo a calibration exercise - the model will not faithfully reproduce all of the details of the data for any set of input parameters.  We are faced with a fairly large parameter space to deal with - exposed/infectious periods, infectivity, amplitude and shape of seasonal forcing in infectivity, and the migration network between populations.  For the purposes of this demonstration, we will leverage existing knowledge of the biology of measles and past analyses of this data to restrict our priors and get to a place where we should be able to produce reasonable results with order 100 simulations - manageable for a powerful laptop in order hours, or in a matter of minutes on a HPC cluster.</p> <p>We will choose distributions that put the exposed and infectious periods at 10 and 8 days long, respectively, with a std. deviation of a couple of days each.</p> <p>The work in Bj\u00f8rnstad, O.N., Finkenst\u00e4dt, B.F. and Grenfell, B.T. (2002), Dynamics of Measles Epidemics: Estimating Scaling of Transmission Rates Using a Time Series SIR Model. Ecological Monographs, 72: 169-184 explores inferring the transmission rates.  In the discussion section, they find that under the assumption of homogenous mixing within spatial units (as in our model), $R_0$ is on average equal to approximately 30 and varies throughout the year, with a minimum of around 19 and a maximum around 40.  So in our calibration exercise, we will take values in this vinicity, and use the seasonal forcing profile estimated in that work.</p> <p>Other sources and some intuition can help constrain the search space for the migration model parameters.  To keep things simple, we will use a gravity model with 4 parameters</p> <p>$$ M_{i,j} = k \\frac{p_i^a p_j^b}{d^c} $$</p> <p>Our work with the 2-patch SIR system revealed that there is roughly 2 orders of magnitude in overall coupling in which \"interesting\" stuff happens (i.e., the system is not totally decoupled and also not fully synchronized), between about 0.001 and 0.1.  We can extrapolate from this and explore values of $k$ such that the average node is exporting a fraction of its infectivity in this range.   Prior study of the time between fadeout and reimportation has found that the importation rate into a node seems to scale like the square root of the node population (see Keeling &amp; Rohani, ref appropriately here), so we will explore values of $b$ in the vicinity of 0.5.  As to $a$, we'll assume that there's no \"self-gravity\" here and set this to zero - that is, a person's propensity to travel to other places is independent of the population of their home and determined entirely by the distance to and population of potential destinations.  Finally, w/r/t $c$, we'll assume that the difficulty of traveling somewhere is at least linear in distance and explore values from 1 to 2.</p>"},{"location":"tutorials/notebooks/10_England_and_Wales/#note","title":"NOTE:\u00b6","text":"<p>The following cell takes 30-40 minutes to render.</p>"},{"location":"tutorials/notebooks/10_England_and_Wales/#discussion","title":"Discussion\u00b6","text":"<p>A more complete calibration exercise might take these results, and iterate a few more times to fully explore the parameter space that produces good fits to both metrics.  For our purposes, we have demonstrated the model's ability, with a fairly limited number of simulations, to reproduce two of the key spatiotemporal features of the England and Wales dataset, and will stop here.</p>"},{"location":"tutorials/notebooks/EW_analysis/","title":"England and Wales measles analysis","text":"In\u00a0[2]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport os\nimport sys\nfrom laser.core.propertyset import PropertySet\nimport matplotlib.pyplot as plt\n\nimport pickle\n\n\ndata_dir = os.path.join('..', \"data\")\nsys.path.append(data_dir)\n\nfrom EnglandWalesmeasles import data as engwal\ndistances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))\n\nimport laser.core\nimport laser.generic\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd import os import sys from laser.core.propertyset import PropertySet import matplotlib.pyplot as plt  import pickle   data_dir = os.path.join('..', \"data\") sys.path.append(data_dir)  from EnglandWalesmeasles import data as engwal distances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))  import laser.core import laser.generic  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[2], line 14\n     11 data_dir = os.path.join('..', \"data\")\n     12 sys.path.append(data_dir)\n---&gt; 14 from EnglandWalesmeasles import data as engwal\n     15 distances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))\n     17 import laser.core\n\nModuleNotFoundError: No module named 'EnglandWalesmeasles'</pre> In\u00a0[\u00a0]: Copied! <pre>EWdata = pd.DataFrame([{\"name\": placename,\n         \"population\": place.population[0],\n         \"latitude\": place.latitude,\n         \"longitude\": place.longitude} for placename, place in engwal.places.items()])\n</pre> EWdata = pd.DataFrame([{\"name\": placename,          \"population\": place.population[0],          \"latitude\": place.latitude,          \"longitude\": place.longitude} for placename, place in engwal.places.items()]) In\u00a0[\u00a0]: Copied! <pre>EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)]\n</pre> EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)] In\u00a0[\u00a0]: Copied! <pre>EWdata[\"cases\"] = EWdata[\"name\"].apply(lambda name: engwal.places[name].cases)\nEWdata['births' ] = EWdata[\"name\"].apply(lambda name: engwal.places[name].births)\nEWdata[\"prop_zero\"] = EWdata[\"cases\"].apply(lambda x: np.mean(np.array(x) == 0))\n</pre> EWdata[\"cases\"] = EWdata[\"name\"].apply(lambda name: engwal.places[name].cases) EWdata['births' ] = EWdata[\"name\"].apply(lambda name: engwal.places[name].births) EWdata[\"prop_zero\"] = EWdata[\"cases\"].apply(lambda x: np.mean(np.array(x) == 0))  In\u00a0[\u00a0]: Copied! <pre>EWdata.loc[507]['births']/EWdata.loc[507]['population']\n</pre> EWdata.loc[507]['births']/EWdata.loc[507]['population'] In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>plt.plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o')\n</pre> plt.plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o') In\u00a0[\u00a0]: Copied! <pre>import re\n\noutput_dir = os.path.join('..', 'outputs3')\nparams = pd.read_csv(os.path.join(output_dir, \"params.csv\"))\n\nresults = []\n\nfor fname in range(100):\n   \n    with open(os.path.join(output_dir, 'EWoutputs_gravity_'+str(fname)+'.pkl'), \"rb\") as f:\n        x = pickle.load(f)\n    # x.cases_test: shape (days, 954)\n    cases_test = np.array(x.cases_test)\n    incidence = np.array(x.incidence)\n    populations = np.array(x.populations[0 ,:])\n    # Aggregate daily to weekly: sum every 7 days along axis 0\n    num_weeks = cases_test.shape[0] // 7\n    weekly_cases = cases_test[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)\n    weekly_incidence = incidence[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)\n    # Create a DataFrame for this parameter set, matching EWdata's structure\n    df = pd.DataFrame({\n        \"name\": EWdata[\"name\"],\n        \"population\": populations,\n        \"cases\": list(weekly_cases.T),  # each entry is a list of weekly cases for that place\n        \"incidence\": list(weekly_incidence.T)  # each entry is a list of weekly cases for that place\n    })\n    df[\"k\"] = params.iloc[fname][\"k\"]\n    df[\"b\"] = params.iloc[fname][\"b\"]\n    df[\"c\"] = params.iloc[fname][\"c\"]\n    #df.set_index([\"k\", \"a\", \"c\", \"name\"], inplace=True)\n    results.append(df)\n</pre> import re  output_dir = os.path.join('..', 'outputs3') params = pd.read_csv(os.path.join(output_dir, \"params.csv\"))  results = []  for fname in range(100):         with open(os.path.join(output_dir, 'EWoutputs_gravity_'+str(fname)+'.pkl'), \"rb\") as f:         x = pickle.load(f)     # x.cases_test: shape (days, 954)     cases_test = np.array(x.cases_test)     incidence = np.array(x.incidence)     populations = np.array(x.populations[0 ,:])     # Aggregate daily to weekly: sum every 7 days along axis 0     num_weeks = cases_test.shape[0] // 7     weekly_cases = cases_test[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)     weekly_incidence = incidence[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)     # Create a DataFrame for this parameter set, matching EWdata's structure     df = pd.DataFrame({         \"name\": EWdata[\"name\"],         \"population\": populations,         \"cases\": list(weekly_cases.T),  # each entry is a list of weekly cases for that place         \"incidence\": list(weekly_incidence.T)  # each entry is a list of weekly cases for that place     })     df[\"k\"] = params.iloc[fname][\"k\"]     df[\"b\"] = params.iloc[fname][\"b\"]     df[\"c\"] = params.iloc[fname][\"c\"]     #df.set_index([\"k\", \"a\", \"c\", \"name\"], inplace=True)     results.append(df) In\u00a0[\u00a0]: Copied! <pre>for df_result in results:\n    df_result[\"prop_zero\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) ==0 ))\n    df_result[\"prop_low\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) &lt;=2 ))\n</pre> for df_result in results:     df_result[\"prop_zero\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) ==0 ))     df_result[\"prop_low\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) &lt;=2 )) In\u00a0[\u00a0]: Copied! <pre>from scipy.optimize import curve_fit\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 1. Define fitting functions for mean and variance\ndef logistic(x, x0, k):\n    # Logistic function bounded between 0 and 1, transitions from 1 to 0 as x increases\n    return 1 / (1 + np.exp(k * (x - x0)))\n\ndef fit_mean_var(x, y):\n    # Fit a logistic to the mean\n    # Initial guess: midpoint at median(x), width=1\n    p0 = [np.median(x), 1.0]\n    bounds = ([-np.inf, 0.01], [np.inf, 10.0])\n    popt_mean, _ = curve_fit(logistic, x, y, p0=p0, bounds=bounds, maxfev=10000)\n    return popt_mean\n\n# 3. Define similarity metric (sum of squared differences of mean and variance fits)\ndef similarity_metric(mean_data, mean_sim):\n    # Evaluate both curves on a common grid\n    x_grid = np.linspace(2.5, 6.5, 200)\n    data_curve = logistic(x_grid, *mean_data)\n    sim_curve = logistic(x_grid, *mean_sim)\n    # Similarity: sum of squared differences between the curves\n    mean_diff = np.sum((sim_curve - data_curve) ** 2)\n    return mean_diff\n\nparams = []\nsim_metrics = []\n\nfor i, df_result in enumerate(results):\n    # Plot observed and simulated data\n    logpop_obs = np.log10(EWdata['population'])\n    prop_zero_obs = EWdata['prop_zero']\n    logpop_sim = np.log10(df_result['population'])\n    prop_zero_sim = df_result['prop_zero']\n\n    # Fit to observed\n    popt_obs = fit_mean_var(logpop_obs, prop_zero_obs)\n    popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)\n    # Similarity metric\n    sim = similarity_metric(popt_obs, popt_sim)\n    k = df_result['k'].iloc[0]\n    a = df_result['b'].iloc[0]\n    c = df_result['c'].iloc[0]\n    params.append((k, a, c))\n    sim_metrics.append(sim)\n</pre> from scipy.optimize import curve_fit from mpl_toolkits.mplot3d import Axes3D  # 1. Define fitting functions for mean and variance def logistic(x, x0, k):     # Logistic function bounded between 0 and 1, transitions from 1 to 0 as x increases     return 1 / (1 + np.exp(k * (x - x0)))  def fit_mean_var(x, y):     # Fit a logistic to the mean     # Initial guess: midpoint at median(x), width=1     p0 = [np.median(x), 1.0]     bounds = ([-np.inf, 0.01], [np.inf, 10.0])     popt_mean, _ = curve_fit(logistic, x, y, p0=p0, bounds=bounds, maxfev=10000)     return popt_mean  # 3. Define similarity metric (sum of squared differences of mean and variance fits) def similarity_metric(mean_data, mean_sim):     # Evaluate both curves on a common grid     x_grid = np.linspace(2.5, 6.5, 200)     data_curve = logistic(x_grid, *mean_data)     sim_curve = logistic(x_grid, *mean_sim)     # Similarity: sum of squared differences between the curves     mean_diff = np.sum((sim_curve - data_curve) ** 2)     return mean_diff  params = [] sim_metrics = []  for i, df_result in enumerate(results):     # Plot observed and simulated data     logpop_obs = np.log10(EWdata['population'])     prop_zero_obs = EWdata['prop_zero']     logpop_sim = np.log10(df_result['population'])     prop_zero_sim = df_result['prop_zero']      # Fit to observed     popt_obs = fit_mean_var(logpop_obs, prop_zero_obs)     popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)     # Similarity metric     sim = similarity_metric(popt_obs, popt_sim)     k = df_result['k'].iloc[0]     a = df_result['b'].iloc[0]     c = df_result['c'].iloc[0]     params.append((k, a, c))     sim_metrics.append(sim)  In\u00a0[\u00a0]: Copied! <pre># Create a DataFrame with k, b, c, and similarity score, then sort by similarity\nparams_df = pd.DataFrame(params, columns=['k', 'b', 'c'])\nparams_df['similarity'] = sim_metrics\nranked_params = params_df.sort_values('similarity').reset_index(drop=True)\nranked_params[0:20]\n</pre> # Create a DataFrame with k, b, c, and similarity score, then sort by similarity params_df = pd.DataFrame(params, columns=['k', 'b', 'c']) params_df['similarity'] = sim_metrics ranked_params = params_df.sort_values('similarity').reset_index(drop=True) ranked_params[0:20] In\u00a0[\u00a0]: Copied! <pre>params_df\n</pre> params_df In\u00a0[\u00a0]: Copied! <pre>fig, axes = plt.subplots(6, 2, figsize=(14, 18))\naxes = axes.flatten()\n\nfor idx in range(12):\n    # Get the parameter set with the idx-th lowest similarity\n    k_best, b_best, c_best = ranked_params.loc[idx, ['k', 'b', 'c']]\n    sim_score = ranked_params.loc[idx, 'similarity']\n    # Find the corresponding result DataFrame\n    for df in results:\n        if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):\n            df_best = df\n            break\n\n    logpop_sim = np.log10(df_best['population'])\n    prop_zero_sim = df_best['prop_zero']\n\n    # Fit logistic to simulation\n    popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)\n    # Fit logistic to observed (reuse from above)\n    popt_obs = fit_mean_var(np.log10(EWdata['population']), EWdata['prop_zero'])\n\n    xfit = np.linspace(2.8, 6.4, 200)\n    axes[idx].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)\n    axes[idx].plot(logpop_sim, prop_zero_sim, 'o', label='Simulated', alpha=0.6)\n    axes[idx].plot(xfit, logistic(xfit, *popt_obs), '-', label='Obs fit', color='C0')\n    axes[idx].plot(xfit, logistic(xfit, *popt_sim), '-', label='Sim fit', color='C1')\n    axes[idx].set_title(f\"k={k_best:.1e}, b={b_best:.2f}, c={c_best:.2f}, similarity={sim_score:.3f}\")\n    axes[idx].set_xlabel(\"log10(Population)\")\n    axes[idx].set_ylabel(\"Proportion zero\")\n    axes[idx].legend()\n\nplt.tight_layout()\nplt.show()\n</pre>   fig, axes = plt.subplots(6, 2, figsize=(14, 18)) axes = axes.flatten()  for idx in range(12):     # Get the parameter set with the idx-th lowest similarity     k_best, b_best, c_best = ranked_params.loc[idx, ['k', 'b', 'c']]     sim_score = ranked_params.loc[idx, 'similarity']     # Find the corresponding result DataFrame     for df in results:         if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):             df_best = df             break      logpop_sim = np.log10(df_best['population'])     prop_zero_sim = df_best['prop_zero']      # Fit logistic to simulation     popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)     # Fit logistic to observed (reuse from above)     popt_obs = fit_mean_var(np.log10(EWdata['population']), EWdata['prop_zero'])      xfit = np.linspace(2.8, 6.4, 200)     axes[idx].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)     axes[idx].plot(logpop_sim, prop_zero_sim, 'o', label='Simulated', alpha=0.6)     axes[idx].plot(xfit, logistic(xfit, *popt_obs), '-', label='Obs fit', color='C0')     axes[idx].plot(xfit, logistic(xfit, *popt_sim), '-', label='Sim fit', color='C1')     axes[idx].set_title(f\"k={k_best:.1e}, b={b_best:.2f}, c={c_best:.2f}, similarity={sim_score:.3f}\")     axes[idx].set_xlabel(\"log10(Population)\")     axes[idx].set_ylabel(\"Proportion zero\")     axes[idx].legend()  plt.tight_layout() plt.show() In\u00a0[\u00a0]: Copied! <pre># Find the top 10 best simulations (lowest similarity)\ntop10 = ranked_params.iloc[:10]\n\n# Collect the corresponding result DataFrames\ndf_top10 = []\nfor idx, row in top10.iterrows():\n    k_best, b_best, c_best = row[['k', 'b', 'c']]\n    for df in results:\n        if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):\n            df_top10.append(df)\n            break\n\n# Stack prop_zero and population for averaging\npopulations = np.stack([np.log10(df['population'].values) for df in df_top10])\nprop_zeros = np.stack([df['prop_zero'].values for df in df_top10])\n\n# Compute mean and std across the top 10\nlogpop_sim_mean = populations.mean(axis=0)\nprop_zero_sim_mean = prop_zeros.mean(axis=0)\nprop_zero_sim_std = prop_zeros.std(axis=0)\n\nlogpop_obs = np.log10(EWdata['population'])\nprop_zero_obs = EWdata['prop_zero']\n#logpop_sim = np.log10(df_best['population'])\n#prop_zero_sim = df_best['prop_zero']\n\nplt.figure(figsize=(9, 6), dpi=200)\n# Use colorblind-friendly colors (e.g., from Color Universal Design palette)\n# Blue: #0072B2, Orange: #E69F00\nplt.scatter(logpop_obs, prop_zero_obs, s=40, color='#0072B2', label='Observed', alpha=0.8, edgecolor='k', linewidth=0.7)\nplt.scatter(logpop_sim_mean, prop_zero_sim_mean, s=40, color='#E69F00', label='Simulated', alpha=0.8, marker='s', edgecolor='k', linewidth=0.7)\n\nplt.xlabel(\"City population\", fontsize=18)\nplt.ylabel(\"Proportion of weeks \\n with no reported cases\", fontsize=18)\nplt.title(\"England + Wales 954 city dataset \\n Measles fadeout and reinvasion dynamics, 1944-1964\", fontsize=20)\nplt.legend(fontsize=16)\n# Set custom x-ticks and labels for log10 scale\nxticks = [3, 4, 5, 6]\nxticklabels = [r\"$10^{%g}$\" % x for x in xticks]\nplt.xticks(xticks, xticklabels, fontsize=15)\nplt.xticks(fontsize=15)\nplt.yticks(fontsize=15)\nplt.tight_layout()\nplt.show()\n</pre> # Find the top 10 best simulations (lowest similarity) top10 = ranked_params.iloc[:10]  # Collect the corresponding result DataFrames df_top10 = [] for idx, row in top10.iterrows():     k_best, b_best, c_best = row[['k', 'b', 'c']]     for df in results:         if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):             df_top10.append(df)             break  # Stack prop_zero and population for averaging populations = np.stack([np.log10(df['population'].values) for df in df_top10]) prop_zeros = np.stack([df['prop_zero'].values for df in df_top10])  # Compute mean and std across the top 10 logpop_sim_mean = populations.mean(axis=0) prop_zero_sim_mean = prop_zeros.mean(axis=0) prop_zero_sim_std = prop_zeros.std(axis=0)  logpop_obs = np.log10(EWdata['population']) prop_zero_obs = EWdata['prop_zero'] #logpop_sim = np.log10(df_best['population']) #prop_zero_sim = df_best['prop_zero']  plt.figure(figsize=(9, 6), dpi=200) # Use colorblind-friendly colors (e.g., from Color Universal Design palette) # Blue: #0072B2, Orange: #E69F00 plt.scatter(logpop_obs, prop_zero_obs, s=40, color='#0072B2', label='Observed', alpha=0.8, edgecolor='k', linewidth=0.7) plt.scatter(logpop_sim_mean, prop_zero_sim_mean, s=40, color='#E69F00', label='Simulated', alpha=0.8, marker='s', edgecolor='k', linewidth=0.7)  plt.xlabel(\"City population\", fontsize=18) plt.ylabel(\"Proportion of weeks \\n with no reported cases\", fontsize=18) plt.title(\"England + Wales 954 city dataset \\n Measles fadeout and reinvasion dynamics, 1944-1964\", fontsize=20) plt.legend(fontsize=16) # Set custom x-ticks and labels for log10 scale xticks = [3, 4, 5, 6] xticklabels = [r\"$10^{%g}$\" % x for x in xticks] plt.xticks(xticks, xticklabels, fontsize=15) plt.xticks(fontsize=15) plt.yticks(fontsize=15) plt.tight_layout() plt.show()  In\u00a0[\u00a0]: Copied! <pre>import geopandas as gpd\n\n# Plot spatial distribution of cities with marker size proportional to log(population)\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8, 10))\n\n# Scatter plot: marker size proportional to log(population)\nsizes =   0.5*np.sqrt(EWdata['population'])  # adjust scaling as needed\nsc = ax.scatter(EWdata['longitude'], EWdata['latitude'], s=sizes, alpha=0.8, c='C0', edgecolor='k', linewidth=1.0)\n\nax.set_xlabel('Longitude')\nax.set_ylabel('Latitude')\nax.set_title('Cities in England &amp; Wales\\nMarker size ~ log10(population)')\n\n# # Optional: Add England &amp; Wales borders using geopandas if available\n# try:\n#     # Plot England &amp; Wales borders from local shapefile\n#     shapefile_path = os.path.join('..', 'ne_110m_admin_0_map_units', 'ne_110m_admin_0_map_units.shp')\n#     borders = gpd.read_file(shapefile_path)\n#     # Filter for United Kingdom, then further for England and Wales if possible\n#     uk = borders[borders['SOVEREIGNT'] == 'United Kingdom']\n#     # If there are subregions, filter for England and Wales\n#     if 'NAME' in uk.columns:\n#         england_wales = uk[uk['NAME'].isin(['England', 'Wales'])]\n#         if not england_wales.empty:\n#             england_wales.boundary.plot(ax=ax, color='k', linewidth=1)\n#         else:\n#             uk.boundary.plot(ax=ax, color='k', linewidth=1)\n#     else:\n#         uk.boundary.plot(ax=ax, color='k', linewidth=1)\n# except ImportError:\n#     print(\"geopandas not installed, skipping borders.\")\n# except Exception as e:\n#     print(f\"Could not plot borders: {e}\")\n</pre> import geopandas as gpd  # Plot spatial distribution of cities with marker size proportional to log(population) import matplotlib.pyplot as plt  fig, ax = plt.subplots(figsize=(8, 10))  # Scatter plot: marker size proportional to log(population) sizes =   0.5*np.sqrt(EWdata['population'])  # adjust scaling as needed sc = ax.scatter(EWdata['longitude'], EWdata['latitude'], s=sizes, alpha=0.8, c='C0', edgecolor='k', linewidth=1.0)  ax.set_xlabel('Longitude') ax.set_ylabel('Latitude') ax.set_title('Cities in England &amp; Wales\\nMarker size ~ log10(population)')  # # Optional: Add England &amp; Wales borders using geopandas if available # try: #     # Plot England &amp; Wales borders from local shapefile #     shapefile_path = os.path.join('..', 'ne_110m_admin_0_map_units', 'ne_110m_admin_0_map_units.shp') #     borders = gpd.read_file(shapefile_path) #     # Filter for United Kingdom, then further for England and Wales if possible #     uk = borders[borders['SOVEREIGNT'] == 'United Kingdom'] #     # If there are subregions, filter for England and Wales #     if 'NAME' in uk.columns: #         england_wales = uk[uk['NAME'].isin(['England', 'Wales'])] #         if not england_wales.empty: #             england_wales.boundary.plot(ax=ax, color='k', linewidth=1) #         else: #             uk.boundary.plot(ax=ax, color='k', linewidth=1) #     else: #         uk.boundary.plot(ax=ax, color='k', linewidth=1) # except ImportError: #     print(\"geopandas not installed, skipping borders.\") # except Exception as e: #     print(f\"Could not plot borders: {e}\")   In\u00a0[\u00a0]: Copied! <pre>np.max(sizes)\n</pre> np.max(sizes) In\u00a0[\u00a0]: Copied! <pre>borders\n</pre> borders In\u00a0[\u00a0]: Copied! <pre>#wavelet phase analysis\nimport pywt\n\ndef pad_data(x):\n    \"\"\"\n    Pad data to the next power of 2\n    \"\"\"\n    nx = len(x) # number of samples\n    nx2 = (2**np.ceil(np.log(nx)/np.log(2))).astype(int) # next power of 2\n    x2 = np.zeros(nx2, dtype=x.dtype) # pad to next power of 2\n    offset = (nx2-nx)//2 # offset\n    x2[offset:(offset+nx)] = x # copy\n    return x2\n\ndef log_transform(x, debug=1):\n    \"\"\"\n    Log transform for case data\n    \"\"\" \n    # add one and take log\n    x = np.log(x+1)\n    # set mean=0 and std=1\n    m = np.mean(x)\n    s = np.std(x)\n    x = (x - m)/s\n    return x\n\n\ndef calc_Ws(cases):\n    # transform case data\n    log_cases = pad_data(log_transform(cases))\n\n    # setup and execute wavelet transform\n    # https://pywavelets.readthedocs.io/en/latest/ref/cwt.html#morlet-wavelet\n    wavelet = pywt.ContinuousWavelet('cmor2-1')\n\n    dt = 1 # 2 weeks\n    widths = np.logspace(np.log10(1), np.log10(7*52), int(7*52))\n    [cwt, frequencies] = pywt.cwt(log_cases, widths, wavelet, dt)\n\n    # Number of time steps in padded time series\n    nt = len(cases)\n    # trim matrix\n    offset = (cwt.shape[1] - nt) // 2\n    cwt = cwt[:, offset:offset + nt]\n\n    return cwt, frequencies\n</pre> #wavelet phase analysis import pywt  def pad_data(x):     \"\"\"     Pad data to the next power of 2     \"\"\"     nx = len(x) # number of samples     nx2 = (2**np.ceil(np.log(nx)/np.log(2))).astype(int) # next power of 2     x2 = np.zeros(nx2, dtype=x.dtype) # pad to next power of 2     offset = (nx2-nx)//2 # offset     x2[offset:(offset+nx)] = x # copy     return x2  def log_transform(x, debug=1):     \"\"\"     Log transform for case data     \"\"\"      # add one and take log     x = np.log(x+1)     # set mean=0 and std=1     m = np.mean(x)     s = np.std(x)     x = (x - m)/s     return x   def calc_Ws(cases):     # transform case data     log_cases = pad_data(log_transform(cases))      # setup and execute wavelet transform     # https://pywavelets.readthedocs.io/en/latest/ref/cwt.html#morlet-wavelet     wavelet = pywt.ContinuousWavelet('cmor2-1')      dt = 1 # 2 weeks     widths = np.logspace(np.log10(1), np.log10(7*52), int(7*52))     [cwt, frequencies] = pywt.cwt(log_cases, widths, wavelet, dt)      # Number of time steps in padded time series     nt = len(cases)     # trim matrix     offset = (cwt.shape[1] - nt) // 2     cwt = cwt[:, offset:offset + nt]      return cwt, frequencies  In\u00a0[\u00a0]: Copied! <pre># Get the cases for London from EWdata\nlondon_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\nlondon_cases = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]\nref_cwt, frequencies = calc_Ws(np.array(london_cases.flatten()))\ndistances_from_london = distances[london_idx, :]\n\nx = np.zeros(len(EWdata))\ny = np.zeros(len(EWdata))\ny2 = np.zeros(len(EWdata))\nfor i, row in EWdata.iterrows():\n    if distances_from_london[i] &gt; 30:\n        continue\n    cwt, frequencies = calc_Ws(row[\"cases\"].flatten())\n    diff = ref_cwt*np.conj(cwt)\n    ind = np.where(np.logical_and(frequencies &lt; 1/(1.5 * 52), frequencies &gt; 1 / (3 * 52)))\n    diff1 = diff[ind[0], :]\n    x[i] = distances_from_london[i]\n    y[i] = np.angle(np.mean(diff1))\n    ind2 = np.where(np.logical_and(frequencies &lt; 1/(0.75 * 52), frequencies &gt; 1 / (1.25 * 52)))\n    diff2 = diff[ind2[0], :]\n    y2[i] = np.angle(np.mean(diff2))\n\nplt.plot(x, y, 'o')\nplt.xlabel(\"Distance from London\")\nplt.ylabel(\"Phase difference\")\nplt.title(\"Phase difference of London wavelet transform\")\nplt.show()\n</pre> # Get the cases for London from EWdata london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0] london_cases = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0] ref_cwt, frequencies = calc_Ws(np.array(london_cases.flatten())) distances_from_london = distances[london_idx, :]  x = np.zeros(len(EWdata)) y = np.zeros(len(EWdata)) y2 = np.zeros(len(EWdata)) for i, row in EWdata.iterrows():     if distances_from_london[i] &gt; 30:         continue     cwt, frequencies = calc_Ws(row[\"cases\"].flatten())     diff = ref_cwt*np.conj(cwt)     ind = np.where(np.logical_and(frequencies &lt; 1/(1.5 * 52), frequencies &gt; 1 / (3 * 52)))     diff1 = diff[ind[0], :]     x[i] = distances_from_london[i]     y[i] = np.angle(np.mean(diff1))     ind2 = np.where(np.logical_and(frequencies &lt; 1/(0.75 * 52), frequencies &gt; 1 / (1.25 * 52)))     diff2 = diff[ind2[0], :]     y2[i] = np.angle(np.mean(diff2))  plt.plot(x, y, 'o') plt.xlabel(\"Distance from London\") plt.ylabel(\"Phase difference\") plt.title(\"Phase difference of London wavelet transform\") plt.show()  In\u00a0[\u00a0]: Copied! <pre>plt.plot(x, -y*180/np.pi, 'o')\nplt.xlim(5, 30)\nplt.ylim(-90, 0)\nplt.xlabel(\"Distance from London\")\nplt.ylabel(\"Phase difference\")\nplt.title(\"Phase difference of London wavelet transform\")\nplt.show()\n</pre> plt.plot(x, -y*180/np.pi, 'o') plt.xlim(5, 30) plt.ylim(-90, 0) plt.xlabel(\"Distance from London\") plt.ylabel(\"Phase difference\") plt.title(\"Phase difference of London wavelet transform\") plt.show() In\u00a0[\u00a0]: Copied! <pre>len(results)\n</pre> len(results)  In\u00a0[\u00a0]: Copied! <pre># Get the cases for London from EWdata\n# For each simulation in results, compute phase difference arrays y_sim and y2_sim\nphase_diff_results = []\n\nlondon_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\ndistances_from_london = distances[london_idx, :]\n\nfor sim_idx, df_sim in enumerate(results):\n    # Get London cases for this simulation\n    london_cases_sim = df_sim[df_sim[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]\n    ref_cwt_sim, frequencies_sim = calc_Ws(np.array(london_cases_sim[520:]).flatten())\n    x_sim = np.zeros(len(df_sim))\n    y_sim = np.zeros(len(df_sim))\n    y2_sim = np.zeros(len(df_sim))\n    for i, row in df_sim.iterrows():\n        if distances_from_london[i] &gt; 30:\n            continue\n        cwt_sim, frequencies_sim = calc_Ws(np.array(row[\"cases\"][520:]).flatten())\n        diff_sim = ref_cwt_sim * np.conj(cwt_sim)\n        ind = np.where(np.logical_and(frequencies_sim &lt; 1/(1.5 * 52), frequencies_sim &gt; 1 / (3 * 52)))\n        diff1_sim = diff_sim[ind[0], :]\n        x_sim[i] = distances_from_london[i]\n        y_sim[i] = np.angle(np.mean(diff1_sim))\n        ind2 = np.where(np.logical_and(frequencies_sim &lt; 1/(0.75 * 52), frequencies_sim &gt; 1 / (1.25 * 52)))\n        diff2_sim = diff_sim[ind2[0], :]\n        y2_sim[i] = np.angle(np.mean(diff2_sim))\n    phase_diff_results.append({\n        \"sim_idx\": sim_idx,\n        \"x\": x_sim,\n        \"y\": y_sim,\n        \"y2\": y2_sim\n    })\n</pre> # Get the cases for London from EWdata # For each simulation in results, compute phase difference arrays y_sim and y2_sim phase_diff_results = []  london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0] distances_from_london = distances[london_idx, :]  for sim_idx, df_sim in enumerate(results):     # Get London cases for this simulation     london_cases_sim = df_sim[df_sim[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]     ref_cwt_sim, frequencies_sim = calc_Ws(np.array(london_cases_sim[520:]).flatten())     x_sim = np.zeros(len(df_sim))     y_sim = np.zeros(len(df_sim))     y2_sim = np.zeros(len(df_sim))     for i, row in df_sim.iterrows():         if distances_from_london[i] &gt; 30:             continue         cwt_sim, frequencies_sim = calc_Ws(np.array(row[\"cases\"][520:]).flatten())         diff_sim = ref_cwt_sim * np.conj(cwt_sim)         ind = np.where(np.logical_and(frequencies_sim &lt; 1/(1.5 * 52), frequencies_sim &gt; 1 / (3 * 52)))         diff1_sim = diff_sim[ind[0], :]         x_sim[i] = distances_from_london[i]         y_sim[i] = np.angle(np.mean(diff1_sim))         ind2 = np.where(np.logical_and(frequencies_sim &lt; 1/(0.75 * 52), frequencies_sim &gt; 1 / (1.25 * 52)))         diff2_sim = diff_sim[ind2[0], :]         y2_sim[i] = np.angle(np.mean(diff2_sim))     phase_diff_results.append({         \"sim_idx\": sim_idx,         \"x\": x_sim,         \"y\": y_sim,         \"y2\": y2_sim     }) In\u00a0[\u00a0]: Copied! <pre>with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"wb\") as f:\n    pickle.dump(phase_diff_results, f)\n</pre> with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"wb\") as f:     pickle.dump(phase_diff_results, f) In\u00a0[\u00a0]: Copied! <pre>with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"rb\") as f:\n    phase_diff_results = pickle.load(f)\n</pre> with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"rb\") as f:     phase_diff_results = pickle.load(f) In\u00a0[\u00a0]: Copied! <pre>params_df\n</pre> params_df In\u00a0[\u00a0]: Copied! <pre>for ind in range(100):\n    fig, axs = plt.subplots(1, 2, figsize=(12, 5))\n\n    # Left plot: Phase difference\n    axs[0].plot(x, -y*180/np.pi, 'o', label='Observed')\n    axs[0].plot(phase_diff_results[14][\"x\"], -phase_diff_results[ind][\"y\"]*180/np.pi, 'o', label='Simulated')\n    axs[0].set_xlim(5, 30)\n    axs[0].set_ylim(-90, 90)\n    axs[0].set_xlabel(\"Distance from London\")\n    axs[0].set_ylabel(\"Phase difference\")\n    axs[0].set_title(\"Phase difference of London wavelet transform\")\n    axs[0].legend()\n\n    # Right plot: Proportion zero vs log10(population)\n    axs[1].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)\n    axs[1].plot(np.log10(results[10]['population']), results[ind][\"prop_low\"], '.', label='Simulated')\n    axs[1].set_xlabel(\"log10(Population)\")\n    axs[1].set_ylabel(\"Proportion zero\")\n    axs[1].set_title(\"Proportion zero vs log10(Population)\")\n    axs[1].legend()\n\n    plt.tight_layout()\n    plt.show()\n</pre> for ind in range(100):     fig, axs = plt.subplots(1, 2, figsize=(12, 5))      # Left plot: Phase difference     axs[0].plot(x, -y*180/np.pi, 'o', label='Observed')     axs[0].plot(phase_diff_results[14][\"x\"], -phase_diff_results[ind][\"y\"]*180/np.pi, 'o', label='Simulated')     axs[0].set_xlim(5, 30)     axs[0].set_ylim(-90, 90)     axs[0].set_xlabel(\"Distance from London\")     axs[0].set_ylabel(\"Phase difference\")     axs[0].set_title(\"Phase difference of London wavelet transform\")     axs[0].legend()      # Right plot: Proportion zero vs log10(population)     axs[1].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)     axs[1].plot(np.log10(results[10]['population']), results[ind][\"prop_low\"], '.', label='Simulated')     axs[1].set_xlabel(\"log10(Population)\")     axs[1].set_ylabel(\"Proportion zero\")     axs[1].set_title(\"Proportion zero vs log10(Population)\")     axs[1].legend()      plt.tight_layout()     plt.show() In\u00a0[\u00a0]: Copied! <pre>from scipy.spatial.distance import euclidean\n\n# 1. Compute similarity between observed and each simulation's phase difference curve\n# We'll use the y (phase difference) vs x (distance) arrays\n\n# Only consider cities within 5-30 km (as in previous plots)\nmask = (x &gt;= 5) &amp; (x &lt;= 30)\nx_obs = x[mask]\ny_obs = y[mask]\n\nsim_scores = []\nfor sim in phase_diff_results:\n    x_sim = sim[\"x\"]\n    y_sim = sim[\"y\"]\n    # Interpolate simulation phase difference to observed x values for fair comparison\n    mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)\n    if np.sum(mask_sim) &lt; 5:  # skip if not enough points\n        sim_scores.append(np.inf)\n        continue\n    # Interpolate simulation y to observed x points\n    try:\n        y_sim_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])\n        score = np.sum((y_obs - y_sim_interp) ** 2)\n    except Exception:\n        score = np.inf\n    sim_scores.append(score)\n\n# 2. Get indices of the 10 best simulations (lowest scores)\ntop10_idx = np.argsort(sim_scores)[:10]\n\n# 3. Plot\nplt.figure(figsize=(8, 6), dpi=300)\nplt.plot(x_obs, -y_obs*180/np.pi, 'o', color='#0072B2', label='Observed', linewidth=2, markersize=6)\n\n# Color palette for simulations\nimport matplotlib.cm as cm\ncolors = cm.viridis(np.linspace(0, 1, 10))\n# Average the top 10 simulations' phase difference curves (interpolated to observed x points)\ny_sims_interp = []\nfor idx in top10_idx:\n    sim = phase_diff_results[idx]\n    x_sim = sim[\"x\"]\n    y_sim = sim[\"y\"]\n    mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)\n    if np.sum(mask_sim) &lt; 5:\n        continue\n    y_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])\n    y_sims_interp.append(y_interp)\ny_sims_interp = np.array(y_sims_interp)\ny_sim_mean = np.mean(y_sims_interp, axis=0)\ny_sim_std = np.std(y_sims_interp, axis=0)\n\n#plt.plot(x_obs, -y_sim_mean*180/np.pi, 'o', color='#E69F00', linewidth=2.5, label='Simulated (mean)')\nplt.errorbar(x_obs, -y_sim_mean*180/np.pi, yerr=y_sim_std*180/np.pi, marker='s', fmt='none', ecolor='#E69F00', capsize=3, label='Simulated (\u00b11 std)')\n\nplt.xlim(5, 30)\nplt.ylim(-90, 20)\nplt.xlabel(\"Distance from London (km)\", fontsize=14)\nplt.ylabel(\"Phase difference (degrees)\", fontsize=14)\nplt.title(\"Top 10 Simulations: Phase difference vs. Distance\", fontsize=16)\nplt.legend(fontsize=10, loc='lower left', ncol=2, frameon=True)\nplt.tight_layout()\nplt.grid(True, linestyle='--', alpha=0.3)\nplt.show()\n</pre> from scipy.spatial.distance import euclidean  # 1. Compute similarity between observed and each simulation's phase difference curve # We'll use the y (phase difference) vs x (distance) arrays  # Only consider cities within 5-30 km (as in previous plots) mask = (x &gt;= 5) &amp; (x &lt;= 30) x_obs = x[mask] y_obs = y[mask]  sim_scores = [] for sim in phase_diff_results:     x_sim = sim[\"x\"]     y_sim = sim[\"y\"]     # Interpolate simulation phase difference to observed x values for fair comparison     mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)     if np.sum(mask_sim) &lt; 5:  # skip if not enough points         sim_scores.append(np.inf)         continue     # Interpolate simulation y to observed x points     try:         y_sim_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])         score = np.sum((y_obs - y_sim_interp) ** 2)     except Exception:         score = np.inf     sim_scores.append(score)  # 2. Get indices of the 10 best simulations (lowest scores) top10_idx = np.argsort(sim_scores)[:10]  # 3. Plot plt.figure(figsize=(8, 6), dpi=300) plt.plot(x_obs, -y_obs*180/np.pi, 'o', color='#0072B2', label='Observed', linewidth=2, markersize=6)  # Color palette for simulations import matplotlib.cm as cm colors = cm.viridis(np.linspace(0, 1, 10)) # Average the top 10 simulations' phase difference curves (interpolated to observed x points) y_sims_interp = [] for idx in top10_idx:     sim = phase_diff_results[idx]     x_sim = sim[\"x\"]     y_sim = sim[\"y\"]     mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)     if np.sum(mask_sim) &lt; 5:         continue     y_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])     y_sims_interp.append(y_interp) y_sims_interp = np.array(y_sims_interp) y_sim_mean = np.mean(y_sims_interp, axis=0) y_sim_std = np.std(y_sims_interp, axis=0)  #plt.plot(x_obs, -y_sim_mean*180/np.pi, 'o', color='#E69F00', linewidth=2.5, label='Simulated (mean)') plt.errorbar(x_obs, -y_sim_mean*180/np.pi, yerr=y_sim_std*180/np.pi, marker='s', fmt='none', ecolor='#E69F00', capsize=3, label='Simulated (\u00b11 std)')  plt.xlim(5, 30) plt.ylim(-90, 20) plt.xlabel(\"Distance from London (km)\", fontsize=14) plt.ylabel(\"Phase difference (degrees)\", fontsize=14) plt.title(\"Top 10 Simulations: Phase difference vs. Distance\", fontsize=16) plt.legend(fontsize=10, loc='lower left', ncol=2, frameon=True) plt.tight_layout() plt.grid(True, linestyle='--', alpha=0.3) plt.show() In\u00a0[\u00a0]: Copied! <pre># Compute the total cases across all towns for each simulation in results\ntotal_cases_per_sim = []\n\nfor df in results:\n    # Each row's \"cases\" is a list/array of weekly cases for that town\n    # Stack all towns' cases into a 2D array: shape (num_towns, num_weeks)\n    cases_matrix = np.stack(df[\"incidence\"].values)\n    # Sum across towns (axis=0) to get total cases per week\n    total_cases = cases_matrix.sum(axis=0)\n    total_cases_per_sim.append(total_cases)\n</pre> # Compute the total cases across all towns for each simulation in results total_cases_per_sim = []  for df in results:     # Each row's \"cases\" is a list/array of weekly cases for that town     # Stack all towns' cases into a 2D array: shape (num_towns, num_weeks)     cases_matrix = np.stack(df[\"incidence\"].values)     # Sum across towns (axis=0) to get total cases per week     total_cases = cases_matrix.sum(axis=0)     total_cases_per_sim.append(total_cases) In\u00a0[\u00a0]: Copied! <pre>plt.plot(total_cases_per_sim[39], label='Sim 1')\n</pre> plt.plot(total_cases_per_sim[39], label='Sim 1') In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/","title":"SEI and SEIS model implementations","text":"In\u00a0[1]: Copied! <pre>from laser.generic.SI import Susceptible, Infectious\nfrom laser.generic.SEIR import Transmission\n</pre> from laser.generic.SI import Susceptible, Infectious from laser.generic.SEIR import Transmission In\u00a0[2]: Copied! <pre>from laser.generic.SEIR import Exposed\nimport inspect\n\nprint(inspect.getsource(Exposed.__init__))\n</pre> from laser.generic.SEIR import Exposed import inspect  print(inspect.getsource(Exposed.__init__)) <pre>    def __init__(self, model, expdurdist, infdurdist, expdurmin=1, infdurmin=1):\n        self.model = model\n        self.model.people.add_scalar_property(\"etimer\", dtype=np.uint16)\n        self.model.nodes.add_vector_property(\"E\", model.params.nticks + 1, dtype=np.int32)\n        self.model.nodes.add_vector_property(\"newly_infectious\", model.params.nticks + 1, dtype=np.int32)\n\n        self.model.nodes.E[0] = self.model.scenario.E\n\n        self.expdurdist = expdurdist\n        self.infdurdist = infdurdist\n        self.expdurmin = expdurmin\n        self.infdurmin = infdurmin\n\n        # convenience\n        nodeids = self.model.people.nodeid\n        states = self.model.people.state\n\n        for node in range(self.model.nodes.count):\n            nseeds = self.model.scenario.E[node]\n            if nseeds &gt; 0:\n                i_susceptible = np.nonzero((nodeids == node) &amp; (states == State.SUSCEPTIBLE.value))[0]\n                assert nseeds &lt;= len(i_susceptible), (\n                    f\"Node {node} has more initial exposed ({nseeds}) than available susceptible ({len(i_susceptible)})\"\n                )\n                i_exposed = np.random.choice(i_susceptible, size=nseeds, replace=False)\n                self.model.people.state[i_exposed] = State.EXPOSED.value\n                samples = dists.sample_floats(self.expdurdist, np.zeros(nseeds, dtype=np.float32))\n                samples = np.round(samples)\n                samples = np.maximum(samples, self.expdurmin).astype(self.model.people.etimer.dtype)\n                self.model.people.etimer[i_exposed] = samples\n                assert np.all(self.model.people.etimer[i_exposed] &gt; 0), (\n                    f\"Exposed individuals should have etimer &gt; 0 ({self.model.people.etimer[i_exposed].min()=})\"\n                )\n\n        return\n\n</pre> <p>Note that the <code>__init__()</code> implementation takes an infectious duration distribution and infectious duration minimum. We will not need this since the infectious state is an absorbing state that agents do not leave.</p> In\u00a0[3]: Copied! <pre>print(inspect.getsource(Exposed.step))\n</pre>  print(inspect.getsource(Exposed.step))  <pre>    def step(self, tick: int) -&gt; None:\n        newly_infectious_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.int32)\n        nb_timer_update_timer_set(\n            self.model.people.state,\n            State.EXPOSED.value,\n            self.model.people.etimer,\n            State.INFECTIOUS.value,\n            self.model.people.itimer,\n            newly_infectious_by_node,\n            self.model.people.nodeid,\n            self.infdurdist,\n            self.infdurmin,\n            tick,\n        )\n        newly_infectious_by_node = newly_infectious_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads\n\n        # state(t+1) = state(t) + \u2206state(t)\n        self.model.nodes.E[tick + 1] -= newly_infectious_by_node\n        self.model.nodes.I[tick + 1] += newly_infectious_by_node\n        # Record today's \u2206\n        self.model.nodes.newly_infectious[tick] = newly_infectious_by_node\n\n        return\n\n</pre> <p>Note that the <code>step()</code> function calls the <code>nb_timer_update_timer_set()</code> function which checks an existing timer (the incubation or exposure timer -<code>etimer</code>) and, if that timer expires, transitions the agent to the new state - INFECTIOUS - and sets the infectious duration. We can instead use the <code>nb_timer_update()</code> function which does not set a timer for the new state.</p> In\u00a0[4]: Copied! <pre>import numba as nb\nimport numpy as np\nfrom laser.generic.SI import State\nfrom laser.generic.components import nb_timer_update\n\n# Implement a new nb_exposed_step() function which tests the state and etimer and transitions the agent to the INFECTIOUS state when the timer expires. This function will not take itimers, infdurdist, infdurmin, or tick parameters and will not set an infectious duration timer. The function should use Numba's njit decorator for performance and prange to parallelize over agents.\n# Implement a new step() function, modeled after the SEIR model Exposed step(), which updates the node count E, calls the new nb_exposed_step() function with an accumulation array - newly_infectious - and updates the node E and I counters.\n\nclass ExposedSEI(Exposed):\n\n    def __init__(self, model, expdurdist, expdurmin=1):\n        # We only need the incubation (exposure) duration distribution parameters during initialization.\n        super().__init__(model, expdurdist, infdurdist=None, expdurmin=expdurmin, infdurmin=None)\n\n        return\n\n    def step(self, tick: int) -&gt; None:\n        # Propagate the number of exposed individuals in each patch\n        # state(t+1) = state(t) + \u2206state(t), initialize state(t+1) with state(t)\n        self.model.nodes.E[tick + 1] = self.model.nodes.E[tick]\n\n        newly_infectious_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.int32)\n        nb_timer_update(\n            self.model.people.state,\n            State.EXPOSED.value,\n            self.model.people.etimer,\n            State.INFECTIOUS.value,\n            newly_infectious_by_node,\n            self.model.people.nodeid,\n        )\n        newly_infectious_by_node = newly_infectious_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads\n\n        # state(t+1) = state(t) + \u2206state(t)\n        self.model.nodes.E[tick + 1] -= newly_infectious_by_node\n        self.model.nodes.I[tick + 1] += newly_infectious_by_node\n        # Record today's \u2206\n        self.model.nodes.newly_infectious[tick] = newly_infectious_by_node\n\n        return\n</pre> import numba as nb import numpy as np from laser.generic.SI import State from laser.generic.components import nb_timer_update  # Implement a new nb_exposed_step() function which tests the state and etimer and transitions the agent to the INFECTIOUS state when the timer expires. This function will not take itimers, infdurdist, infdurmin, or tick parameters and will not set an infectious duration timer. The function should use Numba's njit decorator for performance and prange to parallelize over agents. # Implement a new step() function, modeled after the SEIR model Exposed step(), which updates the node count E, calls the new nb_exposed_step() function with an accumulation array - newly_infectious - and updates the node E and I counters.  class ExposedSEI(Exposed):      def __init__(self, model, expdurdist, expdurmin=1):         # We only need the incubation (exposure) duration distribution parameters during initialization.         super().__init__(model, expdurdist, infdurdist=None, expdurmin=expdurmin, infdurmin=None)          return      def step(self, tick: int) -&gt; None:         # Propagate the number of exposed individuals in each patch         # state(t+1) = state(t) + \u2206state(t), initialize state(t+1) with state(t)         self.model.nodes.E[tick + 1] = self.model.nodes.E[tick]          newly_infectious_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.int32)         nb_timer_update(             self.model.people.state,             State.EXPOSED.value,             self.model.people.etimer,             State.INFECTIOUS.value,             newly_infectious_by_node,             self.model.people.nodeid,         )         newly_infectious_by_node = newly_infectious_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads          # state(t+1) = state(t) + \u2206state(t)         self.model.nodes.E[tick + 1] -= newly_infectious_by_node         self.model.nodes.I[tick + 1] += newly_infectious_by_node         # Record today's \u2206         self.model.nodes.newly_infectious[tick] = newly_infectious_by_node          return In\u00a0[5]: Copied! <pre>from laser.core.utils import grid\nfrom laser.core.random import seed as set_seed\nfrom laser.generic import Model\nfrom laser.core import PropertySet\nfrom laser.core.distributions import normal\n\ninitial_infectious = 10\nseeds = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\nnticks = 365\n\nscenario = grid(M=1, N=1, node_size_degs=0.1, population_fn=lambda x, y: 1_000_000)\nscenario[\"S\"] = scenario.population - initial_infectious\nscenario[\"E\"] = 0\nscenario[\"I\"] = initial_infectious\n\nresults_sei = []\nfor i, seed in enumerate(seeds):\n    set_seed(seed)\n    model = Model(scenario, params=PropertySet({\"beta\": 0.3, \"seed\": seed, \"nticks\": nticks}), skip_capacity=True)\n    exposure_duration = normal(loc=5, scale=1.5)\n    model.components = [\n        Susceptible(model),\n        Infectious(model),  # Infectious goes _before_ Exposed so the previous I count is propagated before the Exposed step updates it.\n        ExposedSEI(model, expdurdist=exposure_duration, expdurmin=1), # ExposedSEI needs the exposure duration distribution for initializing exposed agents.\n        Transmission(model, expdurdist=exposure_duration, expdurmin=1), # Transmission needs the exposure duration distribution to set the exposure timers on newly infected agents.\n    ]\n\n    model.run(f\"Scenario {i+1:2}/{len(seeds)} (seed={seed:2})\")\n    results_sei.append((model.nodes.S, model.nodes.E, model.nodes.I))\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(3, 1, figsize=(10, 12), sharex=True)\nfor i, (S, E, I) in enumerate(results_sei):\n    ax[0].plot(S.sum(axis=1), label=f\"Sim {i+1}\")\n    ax[1].plot(E.sum(axis=1), label=f\"Sim {i+1}\")\n    ax[2].plot(I.sum(axis=1), label=f\"Sim {i+1}\")\nax[0].set_ylabel(\"Susceptible\")\nax[1].set_ylabel(\"Exposed\")\nax[2].set_ylabel(\"Infectious\")\nax[2].set_xlabel(\"Days\")\nax[0].legend()\nplt.suptitle(\"SEI Model: Single Node Suite (1,000,000 agents each)\")\nplt.show()\n</pre> from laser.core.utils import grid from laser.core.random import seed as set_seed from laser.generic import Model from laser.core import PropertySet from laser.core.distributions import normal  initial_infectious = 10 seeds = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89] nticks = 365  scenario = grid(M=1, N=1, node_size_degs=0.1, population_fn=lambda x, y: 1_000_000) scenario[\"S\"] = scenario.population - initial_infectious scenario[\"E\"] = 0 scenario[\"I\"] = initial_infectious  results_sei = [] for i, seed in enumerate(seeds):     set_seed(seed)     model = Model(scenario, params=PropertySet({\"beta\": 0.3, \"seed\": seed, \"nticks\": nticks}), skip_capacity=True)     exposure_duration = normal(loc=5, scale=1.5)     model.components = [         Susceptible(model),         Infectious(model),  # Infectious goes _before_ Exposed so the previous I count is propagated before the Exposed step updates it.         ExposedSEI(model, expdurdist=exposure_duration, expdurmin=1), # ExposedSEI needs the exposure duration distribution for initializing exposed agents.         Transmission(model, expdurdist=exposure_duration, expdurmin=1), # Transmission needs the exposure duration distribution to set the exposure timers on newly infected agents.     ]      model.run(f\"Scenario {i+1:2}/{len(seeds)} (seed={seed:2})\")     results_sei.append((model.nodes.S, model.nodes.E, model.nodes.I))  import matplotlib.pyplot as plt  fig, ax = plt.subplots(3, 1, figsize=(10, 12), sharex=True) for i, (S, E, I) in enumerate(results_sei):     ax[0].plot(S.sum(axis=1), label=f\"Sim {i+1}\")     ax[1].plot(E.sum(axis=1), label=f\"Sim {i+1}\")     ax[2].plot(I.sum(axis=1), label=f\"Sim {i+1}\") ax[0].set_ylabel(\"Susceptible\") ax[1].set_ylabel(\"Exposed\") ax[2].set_ylabel(\"Infectious\") ax[2].set_xlabel(\"Days\") ax[0].legend() plt.suptitle(\"SEI Model: Single Node Suite (1,000,000 agents each)\") plt.show()  <pre>Scenario  1/10 (seed= 1): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 455.50it/s]\nScenario  2/10 (seed= 2): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 560.71it/s]\nScenario  3/10 (seed= 3): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 682.64it/s]\nScenario  4/10 (seed= 5): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 824.01it/s]\nScenario  5/10 (seed= 8): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 862.41it/s]\nScenario  6/10 (seed=13): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 1112.44it/s]\nScenario  7/10 (seed=21): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 817.47it/s]\nScenario  8/10 (seed=34): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 855.30it/s]\nScenario  9/10 (seed=55): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 871.88it/s]\nScenario 10/10 (seed=89): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 847.90it/s]\n</pre> In\u00a0[6]: Copied! <pre>from laser.generic import SI\n\n# Let's run 10 SI models with same R0 for comparison.\nresults_si = []\nfor i, seed in enumerate(seeds):\n    set_seed(seed)\n    model = Model(scenario, params=PropertySet({\"beta\": 0.3, \"seed\": seed, \"nticks\": nticks}), skip_capacity=True)\n    exposure_duration = normal(loc=5, scale=1.5)\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.Transmission(model),\n    ]\n\n    model.run(f\"Scenario {i+1:2}/{len(seeds)} (seed={seed:2})\")\n    results_si.append((model.nodes.S, model.nodes.I))\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(2, 1, figsize=(10, 12), sharex=True)\nfor i, (S, I) in enumerate(results_si):\n    ax[0].plot(S.sum(axis=1), label=f\"Sim {i+1}\")\n    ax[1].plot(I.sum(axis=1), label=f\"Sim {i+1}\")\nax[0].set_ylabel(\"Susceptible\")\nax[1].set_ylabel(\"Infectious\")\nax[1].set_xlabel(\"Days\")\nax[0].legend()\nplt.suptitle(\"SI Model: Single Node Suite (1,000,000 agents each)\")\nplt.show()\n</pre> from laser.generic import SI  # Let's run 10 SI models with same R0 for comparison. results_si = [] for i, seed in enumerate(seeds):     set_seed(seed)     model = Model(scenario, params=PropertySet({\"beta\": 0.3, \"seed\": seed, \"nticks\": nticks}), skip_capacity=True)     exposure_duration = normal(loc=5, scale=1.5)     model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.Transmission(model),     ]      model.run(f\"Scenario {i+1:2}/{len(seeds)} (seed={seed:2})\")     results_si.append((model.nodes.S, model.nodes.I))  import matplotlib.pyplot as plt  fig, ax = plt.subplots(2, 1, figsize=(10, 12), sharex=True) for i, (S, I) in enumerate(results_si):     ax[0].plot(S.sum(axis=1), label=f\"Sim {i+1}\")     ax[1].plot(I.sum(axis=1), label=f\"Sim {i+1}\") ax[0].set_ylabel(\"Susceptible\") ax[1].set_ylabel(\"Infectious\") ax[1].set_xlabel(\"Days\") ax[0].legend() plt.suptitle(\"SI Model: Single Node Suite (1,000,000 agents each)\") plt.show()  <pre>Scenario  1/10 (seed= 1): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 1153.64it/s]\nScenario  2/10 (seed= 2): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 2441.70it/s]\nScenario  3/10 (seed= 3): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 2466.45it/s]\nScenario  4/10 (seed= 5): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 2375.03it/s]\nScenario  5/10 (seed= 8): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 2489.74it/s]\nScenario  6/10 (seed=13): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 2599.61it/s]\nScenario  7/10 (seed=21): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 2478.46it/s]\nScenario  8/10 (seed=34): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 2554.16it/s]\nScenario  9/10 (seed=55): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 2504.36it/s]\nScenario 10/10 (seed=89): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 2780.59it/s]\n</pre> <p>Let's plot a comparison between the two.</p> In\u00a0[7]: Copied! <pre>import numpy as np\n\nimport matplotlib.pyplot as plt\n\n# Compute mean S and I for SEI model\nS_sei = np.array([S for S, E, I in results_sei])  # shape: (n_sim, n_time, 1)\nI_sei = np.array([I for S, E, I in results_sei])\nmean_S_sei = S_sei.mean(axis=0).squeeze()\nmean_I_sei = I_sei.mean(axis=0).squeeze()\n\n# Compute mean S and I for SI model\nS_si = np.array([S for S, I in results_si])\nI_si = np.array([I for S, I in results_si])\nmean_S_si = S_si.mean(axis=0).squeeze()\nmean_I_si = I_si.mean(axis=0).squeeze()\n\nplt.figure(figsize=(10, 6))\nplt.plot(mean_S_sei, label=\"SEI Mean Susceptible\", color=\"tab:blue\")\nplt.plot(mean_I_sei, label=\"SEI Mean Infectious\", color=\"tab:orange\")\nplt.plot(mean_S_si, label=\"SI Mean Susceptible\", color=\"tab:blue\", linestyle=\"--\")\nplt.plot(mean_I_si, label=\"SI Mean Infectious\", color=\"tab:orange\", linestyle=\"--\")\nplt.xlabel(\"Days\")\nplt.ylabel(\"Number of Agents\")\nplt.title(\"Mean S and I: SEI vs SI Models\")\nplt.legend()\nplt.show()\n</pre> import numpy as np  import matplotlib.pyplot as plt  # Compute mean S and I for SEI model S_sei = np.array([S for S, E, I in results_sei])  # shape: (n_sim, n_time, 1) I_sei = np.array([I for S, E, I in results_sei]) mean_S_sei = S_sei.mean(axis=0).squeeze() mean_I_sei = I_sei.mean(axis=0).squeeze()  # Compute mean S and I for SI model S_si = np.array([S for S, I in results_si]) I_si = np.array([I for S, I in results_si]) mean_S_si = S_si.mean(axis=0).squeeze() mean_I_si = I_si.mean(axis=0).squeeze()  plt.figure(figsize=(10, 6)) plt.plot(mean_S_sei, label=\"SEI Mean Susceptible\", color=\"tab:blue\") plt.plot(mean_I_sei, label=\"SEI Mean Infectious\", color=\"tab:orange\") plt.plot(mean_S_si, label=\"SI Mean Susceptible\", color=\"tab:blue\", linestyle=\"--\") plt.plot(mean_I_si, label=\"SI Mean Infectious\", color=\"tab:orange\", linestyle=\"--\") plt.xlabel(\"Days\") plt.ylabel(\"Number of Agents\") plt.title(\"Mean S and I: SEI vs SI Models\") plt.legend() plt.show() In\u00a0[8]: Copied! <pre>from laser.generic import SEIR\n\nclass InfectiousSEIS(SEIR.Infectious):\n\n    def step(self, tick: int) -&gt; None:\n        # Propagate the number of infectious individuals in each patch\n        # state(t+1) = state(t) + \u2206state(t), initialize state(t+1) with state(t)\n        self.model.nodes.I[tick + 1] = self.model.nodes.I[tick]\n\n        newly_recovered_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.int32)\n        nb_timer_update(\n            self.model.people.state,\n            State.INFECTIOUS.value,\n            self.model.people.itimer,\n            State.SUSCEPTIBLE.value,  # Transition to SUSCEPTIBLE\n            newly_recovered_by_node,\n            self.model.people.nodeid,\n        )\n        newly_recovered_by_node = newly_recovered_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads\n\n        # state(t+1) = state(t) + \u2206state(t)\n        self.model.nodes.I[tick + 1] -= newly_recovered_by_node\n        self.model.nodes.S[tick + 1] += newly_recovered_by_node\n        # Record today's \u2206\n        self.model.nodes.newly_recovered[tick] = newly_recovered_by_node\n\n        return\n</pre> from laser.generic import SEIR  class InfectiousSEIS(SEIR.Infectious):      def step(self, tick: int) -&gt; None:         # Propagate the number of infectious individuals in each patch         # state(t+1) = state(t) + \u2206state(t), initialize state(t+1) with state(t)         self.model.nodes.I[tick + 1] = self.model.nodes.I[tick]          newly_recovered_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.int32)         nb_timer_update(             self.model.people.state,             State.INFECTIOUS.value,             self.model.people.itimer,             State.SUSCEPTIBLE.value,  # Transition to SUSCEPTIBLE             newly_recovered_by_node,             self.model.people.nodeid,         )         newly_recovered_by_node = newly_recovered_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads          # state(t+1) = state(t) + \u2206state(t)         self.model.nodes.I[tick + 1] -= newly_recovered_by_node         self.model.nodes.S[tick + 1] += newly_recovered_by_node         # Record today's \u2206         self.model.nodes.newly_recovered[tick] = newly_recovered_by_node          return In\u00a0[9]: Copied! <pre>initial_infectious = 10\nseeds = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\nnticks = 365\n\nscenario = grid(M=1, N=1, node_size_degs=0.1, population_fn=lambda x, y: 1_000_000)\nscenario[\"S\"] = scenario.population - initial_infectious\nscenario[\"E\"] = 0\nscenario[\"I\"] = initial_infectious\n\nresults_seis = []\nfor i, seed in enumerate(seeds):\n    set_seed(seed)\n    model = Model(scenario, params=PropertySet({\"beta\": 0.3, \"seed\": seed, \"nticks\": nticks}), skip_capacity=True)\n    exposure_duration = normal(loc=5, scale=1.5)\n    infectious_duration = normal(loc=14, scale=2.0)\n    model.components = [\n        Susceptible(model),\n        InfectiousSEIS(model, infdurdist=infectious_duration, infdurmin=1),  # Infectious goes _before_ Exposed so the previous I count is propagated before the Exposed step updates it.\n        SEIR.Exposed(model, expdurdist=exposure_duration, expdurmin=1, infdurdist=infectious_duration, infdurmin=1), # ExposedSEI needs the exposure duration distribution for initializing exposed agents.\n        SEIR.Transmission(model, expdurdist=exposure_duration, expdurmin=1), # Transmission needs the exposure duration distribution to set the exposure timers on newly infected agents.\n    ]\n\n    model.run(f\"Scenario {i+1:2}/{len(seeds)} (seed={seed:2})\")\n    results_seis.append((model.nodes.S, model.nodes.E, model.nodes.I))\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(3, 1, figsize=(10, 12), sharex=True)\nfor i, (S, E, I) in enumerate(results_seis):\n    ax[0].plot(S.sum(axis=1), label=f\"Sim {i+1}\")\n    ax[1].plot(E.sum(axis=1), label=f\"Sim {i+1}\")\n    ax[2].plot(I.sum(axis=1), label=f\"Sim {i+1}\")\nax[0].set_ylabel(\"Susceptible\")\nax[1].set_ylabel(\"Exposed\")\nax[2].set_ylabel(\"Infectious\")\nax[2].set_xlabel(\"Days\")\nax[0].legend()\nplt.suptitle(\"SEIS Model: Single Node Suite (1,000,000 agents each)\")\nplt.show()\n</pre> initial_infectious = 10 seeds = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89] nticks = 365  scenario = grid(M=1, N=1, node_size_degs=0.1, population_fn=lambda x, y: 1_000_000) scenario[\"S\"] = scenario.population - initial_infectious scenario[\"E\"] = 0 scenario[\"I\"] = initial_infectious  results_seis = [] for i, seed in enumerate(seeds):     set_seed(seed)     model = Model(scenario, params=PropertySet({\"beta\": 0.3, \"seed\": seed, \"nticks\": nticks}), skip_capacity=True)     exposure_duration = normal(loc=5, scale=1.5)     infectious_duration = normal(loc=14, scale=2.0)     model.components = [         Susceptible(model),         InfectiousSEIS(model, infdurdist=infectious_duration, infdurmin=1),  # Infectious goes _before_ Exposed so the previous I count is propagated before the Exposed step updates it.         SEIR.Exposed(model, expdurdist=exposure_duration, expdurmin=1, infdurdist=infectious_duration, infdurmin=1), # ExposedSEI needs the exposure duration distribution for initializing exposed agents.         SEIR.Transmission(model, expdurdist=exposure_duration, expdurmin=1), # Transmission needs the exposure duration distribution to set the exposure timers on newly infected agents.     ]      model.run(f\"Scenario {i+1:2}/{len(seeds)} (seed={seed:2})\")     results_seis.append((model.nodes.S, model.nodes.E, model.nodes.I))  import matplotlib.pyplot as plt  fig, ax = plt.subplots(3, 1, figsize=(10, 12), sharex=True) for i, (S, E, I) in enumerate(results_seis):     ax[0].plot(S.sum(axis=1), label=f\"Sim {i+1}\")     ax[1].plot(E.sum(axis=1), label=f\"Sim {i+1}\")     ax[2].plot(I.sum(axis=1), label=f\"Sim {i+1}\") ax[0].set_ylabel(\"Susceptible\") ax[1].set_ylabel(\"Exposed\") ax[2].set_ylabel(\"Infectious\") ax[2].set_xlabel(\"Days\") ax[0].legend() plt.suptitle(\"SEIS Model: Single Node Suite (1,000,000 agents each)\") plt.show() <pre>Scenario  1/10 (seed= 1): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:01&lt;00:00, 310.68it/s]\nScenario  2/10 (seed= 2): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 413.37it/s]\nScenario  3/10 (seed= 3): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 393.92it/s]\nScenario  4/10 (seed= 5): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 403.23it/s]\nScenario  5/10 (seed= 8): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 417.49it/s]\nScenario  6/10 (seed=13): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 376.40it/s]\nScenario  7/10 (seed=21): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 400.40it/s]\nScenario  8/10 (seed=34): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 431.61it/s]\nScenario  9/10 (seed=55): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 420.21it/s]\nScenario 10/10 (seed=89): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:00&lt;00:00, 435.73it/s]\n</pre> In\u00a0[10]: Copied! <pre># # Compute mean S, E, and I for SEI model\n# S_sei = np.array([S for S, E, I in results_sei])  # shape: (n_sim, n_time, 1)\nE_sei = np.array([E for S, E, I in results_sei])\n# I_sei = np.array([I for S, E, I in results_sei])\n# mean_S_sei = S_sei.mean(axis=0).squeeze()\nmean_E_sei = E_sei.mean(axis=0).squeeze()\n# mean_I_sei = I_sei.mean(axis=0).squeeze()\n\n# Compute mean S, E, and I for SEIS model\nS_seis = np.array([S for S, E, I in results_seis])\nE_seis = np.array([E for S, E, I in results_seis])\nI_seis = np.array([I for S, E, I in results_seis])\nmean_S_seis = S_seis.mean(axis=0).squeeze()\nmean_E_seis = E_seis.mean(axis=0).squeeze()\nmean_I_seis = I_seis.mean(axis=0).squeeze()\n\nplt.figure(figsize=(10, 6))\nplt.plot(mean_S_sei, label=\"SEI Mean Susceptible\", color=\"tab:blue\")\nplt.plot(mean_E_sei, label=\"SEI Mean Exposed\", color=\"tab:green\")\nplt.plot(mean_I_sei, label=\"SEI Mean Infectious\", color=\"tab:orange\")\nplt.plot(mean_S_seis, label=\"SEIS Mean Susceptible\", color=\"tab:blue\", linestyle=\"--\")\nplt.plot(mean_E_seis, label=\"SEIS Mean Exposed\", color=\"tab:green\", linestyle=\"--\")\nplt.plot(mean_I_seis, label=\"SEIS Mean Infectious\", color=\"tab:orange\", linestyle=\"--\")\nplt.xlabel(\"Days\")\nplt.ylabel(\"Number of Agents\")\nplt.title(\"Mean S, E, and I: SEI vs SEIS Models\")\nplt.legend()\nplt.show()\n</pre> # # Compute mean S, E, and I for SEI model # S_sei = np.array([S for S, E, I in results_sei])  # shape: (n_sim, n_time, 1) E_sei = np.array([E for S, E, I in results_sei]) # I_sei = np.array([I for S, E, I in results_sei]) # mean_S_sei = S_sei.mean(axis=0).squeeze() mean_E_sei = E_sei.mean(axis=0).squeeze() # mean_I_sei = I_sei.mean(axis=0).squeeze()  # Compute mean S, E, and I for SEIS model S_seis = np.array([S for S, E, I in results_seis]) E_seis = np.array([E for S, E, I in results_seis]) I_seis = np.array([I for S, E, I in results_seis]) mean_S_seis = S_seis.mean(axis=0).squeeze() mean_E_seis = E_seis.mean(axis=0).squeeze() mean_I_seis = I_seis.mean(axis=0).squeeze()  plt.figure(figsize=(10, 6)) plt.plot(mean_S_sei, label=\"SEI Mean Susceptible\", color=\"tab:blue\") plt.plot(mean_E_sei, label=\"SEI Mean Exposed\", color=\"tab:green\") plt.plot(mean_I_sei, label=\"SEI Mean Infectious\", color=\"tab:orange\") plt.plot(mean_S_seis, label=\"SEIS Mean Susceptible\", color=\"tab:blue\", linestyle=\"--\") plt.plot(mean_E_seis, label=\"SEIS Mean Exposed\", color=\"tab:green\", linestyle=\"--\") plt.plot(mean_I_seis, label=\"SEIS Mean Infectious\", color=\"tab:orange\", linestyle=\"--\") plt.xlabel(\"Days\") plt.ylabel(\"Number of Agents\") plt.title(\"Mean S, E, and I: SEI vs SEIS Models\") plt.legend() plt.show()"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#sei-and-seis-model-implementations","title":"SEI and SEIS model implementations\u00b6","text":"<p>The current stable of models does not include the less common SEI and SEIS models. In this notebook we will implement the required components for these models.</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#sei","title":"SEI\u00b6","text":"<p>We can use the common Susceptible component. \u2705</p> <p>\u21d2 We will need a new Exposed component which transitions agents from exposed to infectious when the incubation timer expires but does not set an infectious duration timer. \u21d0</p> <p>We can use the Infectious component from the SI model. \u2705</p> <p>We can use the Transmission component from the SEIR/SEIRS models which knows to transition susceptible agents into exposed agents upon infection. \u2705</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#review-exposed-implementation-__init__","title":"Review Exposed implementation - <code>__init__()</code>\u00b6","text":"<p>Let's look at the source for the Exposed <code>__init__()</code> function.</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#review-exposed-implementation-step","title":"Review Exposed implementation - <code>step()</code>\u00b6","text":"<p>Let's look at the source for the Exposed <code>step()</code> function.</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#exposedseir-implementation","title":"<code>ExposedSEIR</code> implementation\u00b6","text":"<p>We will implement a new ExposedSEIR class which overrides <code>__init__()</code> and <code>step()</code> without the infectious duration distribution and infectious duration minimum.</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#single-node-suite","title":"Single node suite\u00b6","text":"<p>Let's run 10 simulations with $10^6$ agents each.</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#si-model-for-comparison","title":"SI model for comparison\u00b6","text":"<p>Let's run 10 SI models with same R0 for comparison.</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#results","title":"Results\u00b6","text":"<p>As expected, the SEI model takes longer to get started due to the delay imposed by the incubation period (exposed state).</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#an-seis-model-implementation","title":"An SEIS model implementation\u00b6","text":"<p>We can use the common Susceptible component. \u2705</p> <p>We can use the Exposed component from the SEIR model which expects both an incubation/exposure timer and an infectious duration timer. \u2705</p> <p>\u21d2 We will need a new Infectious component which transitions agents from infectious to susceptible when the infectious timer expires. \u21d0</p> <p>We can use the Transmission component from the SEIR/SEIRS models which knows to transition susceptible agents into exposed agents upon infection. \u2705</p> <p>We will base the new Infectious component on the SEIR.Infectious component but will transition from I to S rather than from I to R.</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#seis-model","title":"SEIS model\u00b6","text":"<p>Let's compose and run this model.</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#comparison-with-sei-model","title":"Comparison with SEI model\u00b6","text":"<p>We already have the results for the SEI model, let's compare.</p>"},{"location":"tutorials/notebooks/SEI_and_SEIS_implementations/#results","title":"Results\u00b6","text":"<p>As we might expect, the SEIS model proceeds a little more slowly because infectious agents are recovering and returning to the susceptible state which lowers the force of infection.</p> <p>In addition, while the SEI model eventually infects everyone, the SEIS model reaches an equilibrium state between ongoing incidence and return to the susceptible state.</p>"},{"location":"tutorials/notebooks/births/","title":"Explore the vital dynamics births components","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nimport numpy as np\n\nfrom laser.core.utils import grid\nfrom laser.core import PropertySet\nfrom laser.generic.utils import ValuesMap\nfrom laser.generic import Model\nfrom laser.generic import SEIR\nimport laser.core.distributions as dists\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.generic.vitaldynamics import BirthsByCBR\n\nfrom laser.core import __version__ as laser_core_version\nfrom laser.generic import __version__ as laser_generic_version\nprint(f\"LASER version: {laser_core_version}\")\nprint(f\"LASER Generic version: {laser_generic_version}\")\n</pre> from pathlib import Path  import numpy as np  from laser.core.utils import grid from laser.core import PropertySet from laser.generic.utils import ValuesMap from laser.generic import Model from laser.generic import SEIR import laser.core.distributions as dists from laser.core.demographics import AliasedDistribution from laser.generic.vitaldynamics import BirthsByCBR  from laser.core import __version__ as laser_core_version from laser.generic import __version__ as laser_generic_version print(f\"LASER version: {laser_core_version}\") print(f\"LASER Generic version: {laser_generic_version}\")  <pre>LASER version: 0.9.1\nLASER Generic version: 0.0.0\n</pre> In\u00a0[2]: Copied! <pre>ROWS = 1\nCOLS = 1\nNNODES = ROWS * COLS\nNTICKS = 3650\nCBR = 20.0  # Crude Birth Rate 20.0 per 1000 per year\n\nscenario = grid(M=ROWS, N=COLS)\nscenario[\"S\"] = scenario.population\nscenario[\"E\"] = scenario[\"I\"] = scenario[\"R\"] = 0\nparameters = PropertySet({\"nticks\": NTICKS})\nbirthrates = ValuesMap.from_scalar(CBR, NTICKS, NNODES)\n\nexpdurdist = dists.normal(loc=5.0, scale=1.0)\ninfdurdist = dists.normal(loc=7.0, scale=2.0)\n\n# https://population.un.org/wpp/downloads?folder=Standard%20Projections&amp;group=Population WPP2024_POP_F01_1_POPULATION_SINGLE_AGE_BOTH_SEXES.xlsx\nage_data = np.loadtxt(Path.cwd() / \"data\" / \"Nigeria-Distribution-2020.csv\", delimiter=\",\", usecols=0)[0:89]  # Up to age 89 (largest value int16 can hold.)\npyramid = AliasedDistribution(age_data)\n</pre> ROWS = 1 COLS = 1 NNODES = ROWS * COLS NTICKS = 3650 CBR = 20.0  # Crude Birth Rate 20.0 per 1000 per year  scenario = grid(M=ROWS, N=COLS) scenario[\"S\"] = scenario.population scenario[\"E\"] = scenario[\"I\"] = scenario[\"R\"] = 0 parameters = PropertySet({\"nticks\": NTICKS}) birthrates = ValuesMap.from_scalar(CBR, NTICKS, NNODES)  expdurdist = dists.normal(loc=5.0, scale=1.0) infdurdist = dists.normal(loc=7.0, scale=2.0)  # https://population.un.org/wpp/downloads?folder=Standard%20Projections&amp;group=Population WPP2024_POP_F01_1_POPULATION_SINGLE_AGE_BOTH_SEXES.xlsx age_data = np.loadtxt(Path.cwd() / \"data\" / \"Nigeria-Distribution-2020.csv\", delimiter=\",\", usecols=0)[0:89]  # Up to age 89 (largest value int16 can hold.) pyramid = AliasedDistribution(age_data)  In\u00a0[3]: Copied! <pre>model = Model(scenario, parameters, birthrates=birthrates)\n\nmodel.components = [\n    SEIR.Susceptible(model),\n    SEIR.Exposed(model, expdurdist, infdurdist),\n    SEIR.Infectious(model, infdurdist),\n    SEIR.Recovered(model),\n    BirthsByCBR(model, birthrates, pyramid),\n]\n\npop_start = model.people.count\nprint(f\"At t=0    {pop_start =:,}\")\nmodel.run()\npop_finish = model.people.count\nprint(f\"At t={model.params.nticks} {pop_finish=:,}\")\n</pre> model = Model(scenario, parameters, birthrates=birthrates)  model.components = [     SEIR.Susceptible(model),     SEIR.Exposed(model, expdurdist, infdurdist),     SEIR.Infectious(model, infdurdist),     SEIR.Recovered(model),     BirthsByCBR(model, birthrates, pyramid), ]  pop_start = model.people.count print(f\"At t=0    {pop_start =:,}\") model.run() pop_finish = model.people.count print(f\"At t={model.params.nticks} {pop_finish=:,}\")  <pre>At t=0    pop_start =59,116\n</pre> <pre>59,116 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2430.27it/s]</pre> <pre>At t=3650 pop_finish=72,060\n</pre> <pre>\n</pre> <p>Let's check births over the simulation.</p> In\u00a0[4]: Copied! <pre>growth = (1.0 + CBR / 1000.0) ** (NTICKS / 365.0)\nexpected_pop = int(pop_start * growth)\nprint(f\"Expected population: {expected_pop:,}\")\nprint(f\"Actual population:   {pop_finish:,}\")\nprint(f\"Difference:          {pop_finish - expected_pop:,} ({(pop_finish - expected_pop) / expected_pop * 100:.2f}%)\")\n</pre> growth = (1.0 + CBR / 1000.0) ** (NTICKS / 365.0) expected_pop = int(pop_start * growth) print(f\"Expected population: {expected_pop:,}\") print(f\"Actual population:   {pop_finish:,}\") print(f\"Difference:          {pop_finish - expected_pop:,} ({(pop_finish - expected_pop) / expected_pop * 100:.2f}%)\") <pre>Expected population: 72,062\nActual population:   72,060\nDifference:          -2 (-0.00%)\n</pre> In\u00a0[5]: Copied! <pre># \"Please plot the total population, model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R, over time with the expected growth based on pop_start and the CBR overlaid.\"\n\nimport matplotlib.pyplot as plt\n\n# Calculate total population over time\ntotal_population = model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R\n\n# Calculate expected population growth curve\ntime = np.arange(NTICKS + 1)\nexpected_curve = pop_start * (1.0 + CBR / 1000.0) ** (time / 365.0)\n\nplt.figure(figsize=(10, 6))\nplt.plot(time, total_population, label=\"Simulated Total Population\")\nplt.plot(time, expected_curve, '--', label=\"Expected Growth (CBR)\", color='orange')\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Population\")\nplt.title(\"Total Population Over Time vs. Expected Growth\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</pre> # \"Please plot the total population, model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R, over time with the expected growth based on pop_start and the CBR overlaid.\"  import matplotlib.pyplot as plt  # Calculate total population over time total_population = model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R  # Calculate expected population growth curve time = np.arange(NTICKS + 1) expected_curve = pop_start * (1.0 + CBR / 1000.0) ** (time / 365.0)  plt.figure(figsize=(10, 6)) plt.plot(time, total_population, label=\"Simulated Total Population\") plt.plot(time, expected_curve, '--', label=\"Expected Growth (CBR)\", color='orange') plt.xlabel(\"Time (days)\") plt.ylabel(\"Population\") plt.title(\"Total Population Over Time vs. Expected Growth\") plt.legend() plt.grid(True) plt.show() In\u00a0[6]: Copied! <pre># Set up a 2-node scenario with 100_000 people in the rural node and 500_000 people in the urban node.\nscenario = grid(M=1, N=2)\nscenario.population = [100_000, 500_000]\nscenario[\"S\"] = scenario.population\nscenario[\"E\"] = scenario[\"I\"] = scenario[\"R\"] = 0\nparameters = PropertySet({\"nticks\": NTICKS})\nrural_cbr = 30.0  # CBR = 30 per 1000 per year in rural\nurban_cbr = 15.0  # CBR = 15 per 1000 per year in urban\nbirthrates = ValuesMap.from_nodes(np.array([rural_cbr, urban_cbr]), NTICKS)\n\nspatial = Model(scenario, parameters, birthrates=birthrates)\n\nspatial.components = [\n    SEIR.Susceptible(spatial),\n    SEIR.Exposed(spatial, expdurdist, infdurdist),\n    SEIR.Infectious(spatial, infdurdist),\n    SEIR.Recovered(spatial),\n    BirthsByCBR(spatial, birthrates, pyramid),\n]\n\npop_start = spatial.people.count\nprint(f\"At t=0    {pop_start  =:8,}\")\nspatial.run()\npop_finish = spatial.people.count\nprint(f\"At t={spatial.params.nticks} {pop_finish =:8,}\")\n\nprint()\n\ntotal_pop = spatial.nodes.S + spatial.nodes.E + spatial.nodes.I + spatial.nodes.R\nfor node_idx, cbr in enumerate([rural_cbr, urban_cbr]):\n    growth = (1.0 + cbr / 1000.0) ** (NTICKS / 365.0)\n    expected_pop = int(total_pop[0,node_idx] * growth)\n    actual_pop = total_pop[-1,node_idx]\n    print(f\"Node {node_idx} (CBR={cbr}):\")\n    print(f\"  Expected population: {expected_pop:,}\")\n    print(f\"  Actual population:   {actual_pop:,}\")\n    print(f\"  Difference:          {actual_pop - expected_pop:,} ({(actual_pop - expected_pop) / expected_pop * 100:.2f}%)\")\n</pre> # Set up a 2-node scenario with 100_000 people in the rural node and 500_000 people in the urban node. scenario = grid(M=1, N=2) scenario.population = [100_000, 500_000] scenario[\"S\"] = scenario.population scenario[\"E\"] = scenario[\"I\"] = scenario[\"R\"] = 0 parameters = PropertySet({\"nticks\": NTICKS}) rural_cbr = 30.0  # CBR = 30 per 1000 per year in rural urban_cbr = 15.0  # CBR = 15 per 1000 per year in urban birthrates = ValuesMap.from_nodes(np.array([rural_cbr, urban_cbr]), NTICKS)  spatial = Model(scenario, parameters, birthrates=birthrates)  spatial.components = [     SEIR.Susceptible(spatial),     SEIR.Exposed(spatial, expdurdist, infdurdist),     SEIR.Infectious(spatial, infdurdist),     SEIR.Recovered(spatial),     BirthsByCBR(spatial, birthrates, pyramid), ]  pop_start = spatial.people.count print(f\"At t=0    {pop_start  =:8,}\") spatial.run() pop_finish = spatial.people.count print(f\"At t={spatial.params.nticks} {pop_finish =:8,}\")  print()  total_pop = spatial.nodes.S + spatial.nodes.E + spatial.nodes.I + spatial.nodes.R for node_idx, cbr in enumerate([rural_cbr, urban_cbr]):     growth = (1.0 + cbr / 1000.0) ** (NTICKS / 365.0)     expected_pop = int(total_pop[0,node_idx] * growth)     actual_pop = total_pop[-1,node_idx]     print(f\"Node {node_idx} (CBR={cbr}):\")     print(f\"  Expected population: {expected_pop:,}\")     print(f\"  Actual population:   {actual_pop:,}\")     print(f\"  Difference:          {actual_pop - expected_pop:,} ({(actual_pop - expected_pop) / expected_pop * 100:.2f}%)\") <pre>At t=0    pop_start  = 600,000\n</pre> <pre>600,000 agents in 2 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2932.45it/s]</pre> <pre>At t=3650 pop_finish = 714,291\n\nNode 0 (CBR=30.0):\n  Expected population: 134,391\n  Actual population:   134,092\n  Difference:          -299 (-0.22%)\nNode 1 (CBR=15.0):\n  Expected population: 580,270\n  Actual population:   580,199\n  Difference:          -71 (-0.01%)\n</pre> <pre>\n</pre> In\u00a0[7]: Copied! <pre># Set up a single-node scenario with decreasing CBR over time.\nscenario = grid(M=1, N=1, population_fn=lambda r, c: 100_000)\nscenario[\"S\"] = scenario.population\nscenario[\"E\"] = scenario[\"I\"] = scenario[\"R\"] = 0\nparameters = PropertySet({\"nticks\": NTICKS})\ntime_varying_cbr = np.linspace(30.0, 10.0, NTICKS)  # CBR decreases from 30 to 10 per 1000 per year\nbirthrates = ValuesMap.from_timeseries(time_varying_cbr, 1)\ntemporal = Model(scenario, parameters, birthrates=birthrates)\ntemporal.components = [\n    SEIR.Susceptible(temporal),\n    SEIR.Exposed(temporal, expdurdist, infdurdist),\n    SEIR.Infectious(temporal, infdurdist),\n    SEIR.Recovered(temporal),\n    BirthsByCBR(temporal, birthrates, pyramid),\n]\npop_start = temporal.people.count\nprint(f\"At t=0    {pop_start  =:8,}\")\ntemporal.run()\npop_finish = temporal.people.count\nprint(f\"At t={temporal.params.nticks} {pop_finish =:8,}\")\n\nprint()\n\n# Calculate expected population with time-varying CBR\ntotal_pop = temporal.nodes.S + temporal.nodes.E + temporal.nodes.I + temporal.nodes.R\nexpected_pop = pop_start\nfor cbr in time_varying_cbr:\n    growth = (1.0 + cbr / 1000.0) ** (1.0 / 365.0)\n    expected_pop *= growth\nexpected_pop = int(expected_pop)\nprint(f\"Expected population: {expected_pop:,}\")\nprint(f\"Actual population:   {pop_finish:,}\")\nprint(f\"Difference:          {pop_finish - expected_pop:,} ({(pop_finish - expected_pop) / expected_pop * 100:.2f}%)\")\n\n# Let's plot the total population over time with the expected growth based on time-varying CBR overlaid.\nimport matplotlib.pyplot as plt\n\n# Calculate total population over time\ntotal_population = temporal.nodes.S + temporal.nodes.E + temporal.nodes.I + temporal.nodes.R\n\n# Calculate expected population growth curve with time-varying CBR\ntime = np.arange(NTICKS + 1)\nexpected_curve = np.zeros(NTICKS + 1)\nexpected_curve[0] = pop_start\nfor t in range(1, NTICKS + 1):\n    cbr = time_varying_cbr[t - 1]\n    growth = (1.0 + cbr / 1000.0) ** (1.0 / 365.0)\n    expected_curve[t] = expected_curve[t - 1] * growth\n\nplt.figure(figsize=(10, 6))\nplt.plot(time, total_population, label=\"Simulated Total Population\")\nplt.plot(time, expected_curve, '--', label=\"Expected Growth (Time-varying CBR)\", color='orange')\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Population\")\nplt.title(\"Total Population Over Time vs. Expected Growth (Time-varying CBR)\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</pre> # Set up a single-node scenario with decreasing CBR over time. scenario = grid(M=1, N=1, population_fn=lambda r, c: 100_000) scenario[\"S\"] = scenario.population scenario[\"E\"] = scenario[\"I\"] = scenario[\"R\"] = 0 parameters = PropertySet({\"nticks\": NTICKS}) time_varying_cbr = np.linspace(30.0, 10.0, NTICKS)  # CBR decreases from 30 to 10 per 1000 per year birthrates = ValuesMap.from_timeseries(time_varying_cbr, 1) temporal = Model(scenario, parameters, birthrates=birthrates) temporal.components = [     SEIR.Susceptible(temporal),     SEIR.Exposed(temporal, expdurdist, infdurdist),     SEIR.Infectious(temporal, infdurdist),     SEIR.Recovered(temporal),     BirthsByCBR(temporal, birthrates, pyramid), ] pop_start = temporal.people.count print(f\"At t=0    {pop_start  =:8,}\") temporal.run() pop_finish = temporal.people.count print(f\"At t={temporal.params.nticks} {pop_finish =:8,}\")  print()  # Calculate expected population with time-varying CBR total_pop = temporal.nodes.S + temporal.nodes.E + temporal.nodes.I + temporal.nodes.R expected_pop = pop_start for cbr in time_varying_cbr:     growth = (1.0 + cbr / 1000.0) ** (1.0 / 365.0)     expected_pop *= growth expected_pop = int(expected_pop) print(f\"Expected population: {expected_pop:,}\") print(f\"Actual population:   {pop_finish:,}\") print(f\"Difference:          {pop_finish - expected_pop:,} ({(pop_finish - expected_pop) / expected_pop * 100:.2f}%)\")  # Let's plot the total population over time with the expected growth based on time-varying CBR overlaid. import matplotlib.pyplot as plt  # Calculate total population over time total_population = temporal.nodes.S + temporal.nodes.E + temporal.nodes.I + temporal.nodes.R  # Calculate expected population growth curve with time-varying CBR time = np.arange(NTICKS + 1) expected_curve = np.zeros(NTICKS + 1) expected_curve[0] = pop_start for t in range(1, NTICKS + 1):     cbr = time_varying_cbr[t - 1]     growth = (1.0 + cbr / 1000.0) ** (1.0 / 365.0)     expected_curve[t] = expected_curve[t - 1] * growth  plt.figure(figsize=(10, 6)) plt.plot(time, total_population, label=\"Simulated Total Population\") plt.plot(time, expected_curve, '--', label=\"Expected Growth (Time-varying CBR)\", color='orange') plt.xlabel(\"Time (days)\") plt.ylabel(\"Population\") plt.title(\"Total Population Over Time vs. Expected Growth (Time-varying CBR)\") plt.legend() plt.grid(True) plt.show()  <pre>At t=0    pop_start  = 100,000\n</pre> <pre>100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 3509.92it/s]</pre> <pre>At t=3650 pop_finish = 121,970\n\nExpected population: 121,879\nActual population:   121,970\nDifference:          91 (0.07%)\n</pre> <pre>\n</pre>"},{"location":"tutorials/notebooks/births/#explore-the-vital-dynamics-births-components","title":"Explore the vital dynamics births components\u00b6","text":""},{"location":"tutorials/notebooks/births/#spatially-varying-cbr","title":"Spatially-varying CBR\u00b6","text":"<p>Let's try a 2 node simulation with a high CBR rural node and lower CBR urban node.</p>"},{"location":"tutorials/notebooks/births/#temporally-varying-cbr","title":"Temporally-varying CBR\u00b6","text":"<p>Let's set up a single node scenario with decreasing CBR over time.</p>"},{"location":"tutorials/notebooks/constant_pop/","title":"Test ConstantPopVitalDynamics","text":"In\u00a0[1]: Copied! <pre>import numba as nb\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> import numba as nb import numpy as np import matplotlib.pyplot as plt   In\u00a0[2]: Copied! <pre>import laser.core.distributions as dists\nfrom laser.core import PropertySet\nfrom laser.core.utils import grid\nfrom laser.generic.utils import ValuesMap\nfrom laser.generic import Model\nfrom laser.generic import SEIR\nfrom laser.generic.vitaldynamics import ConstantPopVitalDynamics\nfrom laser.generic import State\n</pre> import laser.core.distributions as dists from laser.core import PropertySet from laser.core.utils import grid from laser.generic.utils import ValuesMap from laser.generic import Model from laser.generic import SEIR from laser.generic.vitaldynamics import ConstantPopVitalDynamics from laser.generic import State  In\u00a0[\u00a0]: Copied! <pre>NTICKS = 10 * 365\nR0 = 10  # measles-ish\nEXPOSED_DURATION_MEAN = 4.5\nEXPOSED_DURATION_SCALE = 1.0\nINFECTIOUS_DURATION_MEAN = 7.0\nINFECTIOUS_DURATION_SCALE = 2.0\n\nscenario = grid(M=5, N=5, population_fn=lambda x, y: int(np.random.uniform(10_000, 1_000_000)))\ninit_susceptible = np.round(scenario.population / R0).astype(np.int32)  # 1/R0 already recovered\nequilibrium_prevalence = 9000 / 12_000_000\ninit_infected = np.round(equilibrium_prevalence * scenario.population).astype(np.int32)\nscenario[\"S\"] = init_susceptible\nscenario[\"E\"] = 0\nscenario[\"I\"] = init_infected\nscenario[\"R\"] = scenario.population - init_susceptible - init_infected\n\nparams = PropertySet({\"nticks\": NTICKS, \"beta\": R0 / INFECTIOUS_DURATION_MEAN})\nbirthrates_map = ValuesMap.from_scalar(35, nticks=NTICKS, nnodes=len(scenario))\n\nmodel = Model(scenario, params, birthrates=birthrates_map)\n# model.validating = True\n\nexpdist = dists.normal(loc=EXPOSED_DURATION_MEAN, scale=EXPOSED_DURATION_SCALE)\ninfdist = dists.normal(loc=INFECTIOUS_DURATION_MEAN, scale=INFECTIOUS_DURATION_SCALE)\n\ns = SEIR.Susceptible(model)\ne = SEIR.Exposed(model, expdist, infdist)\ni = SEIR.Infectious(model, infdist)\nr = SEIR.Recovered(model)\ntx = SEIR.Transmission(model, expdist)\n\nvitals = ConstantPopVitalDynamics(\n    model,\n    recycle_rates=birthrates_map,\n)\n\nmodel.components = [s, r, i, e, tx, vitals]\n\nlabel = f\"SEIR with ({model.people.count:,} agents in {model.nodes.count:,} nodes)\"\nmodel.run(label)\n</pre> NTICKS = 10 * 365 R0 = 10  # measles-ish EXPOSED_DURATION_MEAN = 4.5 EXPOSED_DURATION_SCALE = 1.0 INFECTIOUS_DURATION_MEAN = 7.0 INFECTIOUS_DURATION_SCALE = 2.0  scenario = grid(M=5, N=5, population_fn=lambda x, y: int(np.random.uniform(10_000, 1_000_000))) init_susceptible = np.round(scenario.population / R0).astype(np.int32)  # 1/R0 already recovered equilibrium_prevalence = 9000 / 12_000_000 init_infected = np.round(equilibrium_prevalence * scenario.population).astype(np.int32) scenario[\"S\"] = init_susceptible scenario[\"E\"] = 0 scenario[\"I\"] = init_infected scenario[\"R\"] = scenario.population - init_susceptible - init_infected  params = PropertySet({\"nticks\": NTICKS, \"beta\": R0 / INFECTIOUS_DURATION_MEAN}) birthrates_map = ValuesMap.from_scalar(35, nticks=NTICKS, nnodes=len(scenario))  model = Model(scenario, params, birthrates=birthrates_map) # model.validating = True  expdist = dists.normal(loc=EXPOSED_DURATION_MEAN, scale=EXPOSED_DURATION_SCALE) infdist = dists.normal(loc=INFECTIOUS_DURATION_MEAN, scale=INFECTIOUS_DURATION_SCALE)  s = SEIR.Susceptible(model) e = SEIR.Exposed(model, expdist, infdist) i = SEIR.Infectious(model, infdist) r = SEIR.Recovered(model) tx = SEIR.Transmission(model, expdist)  vitals = ConstantPopVitalDynamics(     model,     recycle_rates=birthrates_map, )  model.components = [s, r, i, e, tx, vitals]  label = f\"SEIR with ({model.people.count:,} agents in {model.nodes.count:,} nodes)\" model.run(label)  <pre>SEIR with (14,202,010 agents in 25 nodes): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:48&lt;00:00, 75.10it/s]\n</pre> In\u00a0[4]: Copied! <pre>fig, ax1 = plt.subplots(figsize=(12, 6))\n\ntotal_pop = model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R\n\n# Primary axis: S and R\nax1.plot(total_pop.sum(axis=1), label=\"Total Population\", color=\"black\")\nax1.plot(model.nodes.S.sum(axis=1), label=\"Susceptible (S)\", color=\"tab:blue\")\nax1.plot(model.nodes.R.sum(axis=1), label=\"Recovered (R)\", color=\"tab:green\")\nax1.set_xlabel(\"Time (days)\")\nax1.set_ylabel(\"Population (Total, S, R)\")\nax1.legend(loc=\"upper left\")\n\n# Secondary axis: E, I, births, deaths\nax2 = ax1.twinx()\nax2.plot(model.nodes.E.sum(axis=1), label=\"Exposed (E)\", color=\"tab:orange\", linestyle=\"--\")\nax2.plot(model.nodes.I.sum(axis=1), label=\"Infectious (I)\", color=\"tab:red\", linestyle=\"--\")\nax2.plot(model.nodes.births.sum(axis=1), label=\"Births\", color=\"tab:purple\", linestyle=\":\")\nax2.plot(model.nodes.deaths.sum(axis=1), label=\"Deaths\", color=\"tab:brown\", linestyle=\":\")\n\nax2.set_ylabel(\"Counts (E, I, Births, Deaths)\")\nax2.legend(loc=\"upper right\")\n\nplt.title(\"SEIR Model: S, E, I, R, Births, and Deaths Over Time\")\nax1.grid()\nax2.grid(color=\"lightgray\", linestyle=\"--\")\nplt.tight_layout()\nplt.show()\n</pre> fig, ax1 = plt.subplots(figsize=(12, 6))  total_pop = model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R  # Primary axis: S and R ax1.plot(total_pop.sum(axis=1), label=\"Total Population\", color=\"black\") ax1.plot(model.nodes.S.sum(axis=1), label=\"Susceptible (S)\", color=\"tab:blue\") ax1.plot(model.nodes.R.sum(axis=1), label=\"Recovered (R)\", color=\"tab:green\") ax1.set_xlabel(\"Time (days)\") ax1.set_ylabel(\"Population (Total, S, R)\") ax1.legend(loc=\"upper left\")  # Secondary axis: E, I, births, deaths ax2 = ax1.twinx() ax2.plot(model.nodes.E.sum(axis=1), label=\"Exposed (E)\", color=\"tab:orange\", linestyle=\"--\") ax2.plot(model.nodes.I.sum(axis=1), label=\"Infectious (I)\", color=\"tab:red\", linestyle=\"--\") ax2.plot(model.nodes.births.sum(axis=1), label=\"Births\", color=\"tab:purple\", linestyle=\":\") ax2.plot(model.nodes.deaths.sum(axis=1), label=\"Deaths\", color=\"tab:brown\", linestyle=\":\")  ax2.set_ylabel(\"Counts (E, I, Births, Deaths)\") ax2.legend(loc=\"upper right\")  plt.title(\"SEIR Model: S, E, I, R, Births, and Deaths Over Time\") ax1.grid() ax2.grid(color=\"lightgray\", linestyle=\"--\") plt.tight_layout() plt.show()"},{"location":"tutorials/notebooks/constant_pop/#test-constantpopvitaldynamics","title":"Test ConstantPopVitalDynamics\u00b6","text":"<p>Let's set up an endemic infection scenario with constant population.</p>"},{"location":"tutorials/notebooks/constant_pop/#recycling-over-time","title":"Recycling Over Time\u00b6","text":""},{"location":"tutorials/notebooks/distributions/","title":"Numba compatible distributions","text":"In\u00a0[1]: Copied! <pre>import numba as nb\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nimport laser.core.distributions as distributions\n</pre> import numba as nb import numpy as np from matplotlib import pyplot as plt  import laser.core.distributions as distributions  In\u00a0[2]: Copied! <pre>def plot_histogram(data: list[tuple[np.ndarray, str, str]], bins: int = 101) -&gt; None:\n\n    for d, label, color in data:\n        plt.hist(d, bins=bins, density=True, alpha=0.6, color=color, label=label)\n    plt.xlabel('Value')\n    plt.ylabel('Density')\n    plt.title('Histogram')\n    plt.grid(True)\n    plt.legend()\n    plt.tight_layout()\n    plt.show()\n</pre> def plot_histogram(data: list[tuple[np.ndarray, str, str]], bins: int = 101) -&gt; None:      for d, label, color in data:         plt.hist(d, bins=bins, density=True, alpha=0.6, color=color, label=label)     plt.xlabel('Value')     plt.ylabel('Density')     plt.title('Histogram')     plt.grid(True)     plt.legend()     plt.tight_layout()     plt.show()  In\u00a0[3]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor alpha, beta, color in [(0.5, 0.5, \"red\"), (5.0, 1.0, \"blue\"), (1.0, 3.0, \"green\"), (2.0, 2.0, \"purple\"), (2.0, 5.0, \"orange\")]:\n\n    dist = distributions.beta(a=alpha, b=beta)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples, f'Beta({alpha}, {beta})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for alpha, beta, color in [(0.5, 0.5, \"red\"), (5.0, 1.0, \"blue\"), (1.0, 3.0, \"green\"), (2.0, 2.0, \"purple\"), (2.0, 5.0, \"orange\")]:      dist = distributions.beta(a=alpha, b=beta)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples, f'Beta({alpha}, {beta})', color))  plot_histogram(traces)  In\u00a0[4]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor p, n, color in [(0.5, 20, \"blue\"), (0.7, 20, \"green\"), (0.5, 40, \"red\")]:\n\n    dist = distributions.binomial(n=n, p=p)\n    distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))\n\n    traces.append((samples, f'Binomial({n}, {p})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for p, n, color in [(0.5, 20, \"blue\"), (0.7, 20, \"green\"), (0.5, 40, \"red\")]:      dist = distributions.binomial(n=n, p=p)     distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))      traces.append((samples, f'Binomial({n}, {p})', color))  plot_histogram(traces)  In\u00a0[5]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor lamda, color in [(0.5, \"red\"), (1.0, \"green\"), (1.5, \"lightblue\")]:\n\n    dist = distributions.exponential(scale=1/lamda)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[samples &lt; 8], f'Exponential(1/{lamda})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for lamda, color in [(0.5, \"red\"), (1.0, \"green\"), (1.5, \"lightblue\")]:      dist = distributions.exponential(scale=1/lamda)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[samples &lt; 8], f'Exponential(1/{lamda})', color))  plot_histogram(traces)  In\u00a0[6]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor alpha, theta, color in [(1.0, 2.0, \"red\"), (2.0, 2.0, \"orange\"), (3.0, 2.0, \"yellow\"), (5.0, 1.0, \"green\"), (9.0, 0.5, \"black\"), (7.5, 1.0, \"blue\"), (0.5, 1.0, \"purple\")]:\n\n    dist = distributions.gamma(shape=alpha, scale=theta)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[(samples &gt; 0.25) &amp; (samples &lt;= 15)], f'Gamma({alpha}, {theta})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for alpha, theta, color in [(1.0, 2.0, \"red\"), (2.0, 2.0, \"orange\"), (3.0, 2.0, \"yellow\"), (5.0, 1.0, \"green\"), (9.0, 0.5, \"black\"), (7.5, 1.0, \"blue\"), (0.5, 1.0, \"purple\")]:      dist = distributions.gamma(shape=alpha, scale=theta)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[(samples &gt; 0.25) &amp; (samples &lt;= 15)], f'Gamma({alpha}, {theta})', color))  plot_histogram(traces)  In\u00a0[7]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor mu, s, color in [(5, 2, \"blue\"), (9, 3, \"green\"), (9, 4, \"red\"), (6, 2, \"lightblue\"), (2, 1, \"purple\")]:\n\n    dist = distributions.logistic(loc=mu, scale=s)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 25)], f'Logistic({mu}, {s})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for mu, s, color in [(5, 2, \"blue\"), (9, 3, \"green\"), (9, 4, \"red\"), (6, 2, \"lightblue\"), (2, 1, \"purple\")]:      dist = distributions.logistic(loc=mu, scale=s)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 25)], f'Logistic({mu}, {s})', color))  plot_histogram(traces)  In\u00a0[8]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor mu, sigma, color in [(0, 1, \"blue\"), (0, 0.5, \"green\"), (0, 0.25, \"red\")]:\n\n    dist = distributions.lognormal(mean=mu, sigma=sigma)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[samples &lt;= 3], f'Lognormal({mu}, {sigma})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for mu, sigma, color in [(0, 1, \"blue\"), (0, 0.5, \"green\"), (0, 0.25, \"red\")]:      dist = distributions.lognormal(mean=mu, sigma=sigma)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[samples &lt;= 3], f'Lognormal({mu}, {sigma})', color))  plot_histogram(traces)  In\u00a0[9]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor mu, sigmasq, color in [(0, 0.2, \"blue\"), (0, 1.0, \"red\"), (0, 5.0, \"orange\"), (-2, 0.5, \"green\")]:\n\n    dist = distributions.normal(loc=mu, scale=np.sqrt(sigmasq))\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 5)], f'Normal({mu}, {np.sqrt(sigmasq)})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for mu, sigmasq, color in [(0, 0.2, \"blue\"), (0, 1.0, \"red\"), (0, 5.0, \"orange\"), (-2, 0.5, \"green\")]:      dist = distributions.normal(loc=mu, scale=np.sqrt(sigmasq))     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 5)], f'Normal({mu}, {np.sqrt(sigmasq)})', color))  plot_histogram(traces)  In\u00a0[10]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor lamda, color in [(1, \"orange\"), (4, \"purple\"), (10, \"lightblue\")]:\n\n    dist = distributions.poisson(lam=lamda)\n    distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))\n\n    traces.append((samples[samples &lt;= 20], f'Poisson({lamda})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for lamda, color in [(1, \"orange\"), (4, \"purple\"), (10, \"lightblue\")]:      dist = distributions.poisson(lam=lamda)     distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))      traces.append((samples[samples &lt;= 20], f'Poisson({lamda})', color))  plot_histogram(traces)  In\u00a0[11]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor low, high, color in [(0.0, 1.0, \"red\"), (0.25, 1.25, \"orange\"), (0.0, 2.0, \"green\"), (-1.0, 1.0,\"blue\"), (2.71828, 3.14159, \"indigo\"), (1.30, 4.20, \"violet\")]:\n\n    dist = distributions.uniform(low=low, high=high)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples, f'Uniform({low}, {high})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for low, high, color in [(0.0, 1.0, \"red\"), (0.25, 1.25, \"orange\"), (0.0, 2.0, \"green\"), (-1.0, 1.0,\"blue\"), (2.71828, 3.14159, \"indigo\"), (1.30, 4.20, \"violet\")]:      dist = distributions.uniform(low=low, high=high)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples, f'Uniform({low}, {high})', color))  plot_histogram(traces)  In\u00a0[12]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor k, lamda, color in [(0.5, 1.0, \"blue\"), (1.0, 1.0, \"red\"), (1.5, 1.0, \"purple\"), (5.0, 1.0, \"green\")]:\n\n    dist = distributions.weibull(a=k, lam=lamda)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[samples &lt;= 2.5], f'Weibull({k}, {lamda})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for k, lamda, color in [(0.5, 1.0, \"blue\"), (1.0, 1.0, \"red\"), (1.5, 1.0, \"purple\"), (5.0, 1.0, \"green\")]:      dist = distributions.weibull(a=k, lam=lamda)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[samples &lt;= 2.5], f'Weibull({k}, {lamda})', color))  plot_histogram(traces)"},{"location":"tutorials/notebooks/distributions/#numba-compatible-distributions","title":"Numba compatible distributions\u00b6","text":"<p>Test each of the Numba compatible distributions.</p>"},{"location":"tutorials/notebooks/distributions/#beta","title":"Beta\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#binomial","title":"Binomial\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#exponential","title":"Exponential\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#gamma","title":"Gamma\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#logistic","title":"Logistic\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#lognormal","title":"LogNormal\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#multinomial","title":"Multinomial\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#negativebinomial","title":"NegativeBinomial\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#normal","title":"Normal\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#poisson","title":"Poisson\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#uniform","title":"Uniform\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#weibull","title":"Weibull\u00b6","text":""},{"location":"tutorials/notebooks/grid_examples/","title":"function examples","text":"In\u00a0[1]: Copied! <pre>from laser.core.utils import grid\n</pre> from laser.core.utils import grid In\u00a0[2]: Copied! <pre>M = 7\nCY = M // 2\nN = 7\nCX = N // 2\n\ndef central_pop(x, y):\n    d = abs(x - CX) + abs(y - CY) + 1\n    p = 1_000_000 / (10 * d)\n    return int(p)\n\nscenario = grid(M, N, population_fn=central_pop)\nprj = scenario.to_crs(3857)\nax = prj.plot(column=\"population\", cmap=\"viridis\", legend=True, figsize=(12, 9))\nprj.centroid.plot(ax=ax, color=\"red\", marker=\"x\", markersize=100)\n_ = ax.set_xlabel(\"meters\")\n_ = ax.set_ylabel(\"meters\")\n</pre> M = 7 CY = M // 2 N = 7 CX = N // 2  def central_pop(x, y):     d = abs(x - CX) + abs(y - CY) + 1     p = 1_000_000 / (10 * d)     return int(p)  scenario = grid(M, N, population_fn=central_pop) prj = scenario.to_crs(3857) ax = prj.plot(column=\"population\", cmap=\"viridis\", legend=True, figsize=(12, 9)) prj.centroid.plot(ax=ax, color=\"red\", marker=\"x\", markersize=100) _ = ax.set_xlabel(\"meters\") _ = ax.set_ylabel(\"meters\") In\u00a0[3]: Copied! <pre>LEFT = 0\nRIGHT = N - 1\nTOP = M - 1\nBOTTOM = 0\n\ndef ring_pop(x, y):\n\n    dx = min(x - LEFT, RIGHT - x)\n    dy = min(y - BOTTOM, TOP - y)\n    d = min(dx, dy) + 1\n\n    pop = int(round(1_000_000 / (5 * d)))\n\n    return pop\n\nscenario = grid(M, N, population_fn=ring_pop)\nprj = scenario.to_crs(3857)\nax = prj.plot(column=\"population\", cmap=\"viridis\", legend=True, figsize=(12, 9))\nprj.centroid.plot(ax=ax, color=\"red\", marker=\"x\", markersize=100)\n_ = ax.set_xlabel(\"meters\")\n_ = ax.set_ylabel(\"meters\")\n</pre> LEFT = 0 RIGHT = N - 1 TOP = M - 1 BOTTOM = 0  def ring_pop(x, y):      dx = min(x - LEFT, RIGHT - x)     dy = min(y - BOTTOM, TOP - y)     d = min(dx, dy) + 1      pop = int(round(1_000_000 / (5 * d)))      return pop  scenario = grid(M, N, population_fn=ring_pop) prj = scenario.to_crs(3857) ax = prj.plot(column=\"population\", cmap=\"viridis\", legend=True, figsize=(12, 9)) prj.centroid.plot(ax=ax, color=\"red\", marker=\"x\", markersize=100) _ = ax.set_xlabel(\"meters\") _ = ax.set_ylabel(\"meters\") In\u00a0[4]: Copied! <pre>ROWS = 1\nCY = ROWS // 2\nCOLUMNS = 9\nCX = COLUMNS // 2\n\ndef linear_pop(row, col):\n    d = abs(col - CX) + 1\n    pop = int(round(1_000_000 / d))\n    return pop\n\nscenario = grid(ROWS, COLUMNS, population_fn=linear_pop)\nprj = scenario.to_crs(3857)\nax = prj.plot(column=\"population\", cmap=\"viridis\", legend=True, figsize=(12, 9))\nprj.centroid.plot(ax=ax, color=\"red\", marker=\"x\", markersize=100)\n_ = ax.set_xlabel(\"meters\")\n_ = ax.set_ylabel(\"meters\")\n</pre> ROWS = 1 CY = ROWS // 2 COLUMNS = 9 CX = COLUMNS // 2  def linear_pop(row, col):     d = abs(col - CX) + 1     pop = int(round(1_000_000 / d))     return pop  scenario = grid(ROWS, COLUMNS, population_fn=linear_pop) prj = scenario.to_crs(3857) ax = prj.plot(column=\"population\", cmap=\"viridis\", legend=True, figsize=(12, 9)) prj.centroid.plot(ax=ax, color=\"red\", marker=\"x\", markersize=100) _ = ax.set_xlabel(\"meters\") _ = ax.set_ylabel(\"meters\") In\u00a0[5]: Copied! <pre>scenario.head()\n</pre> scenario.head()  Out[5]: nodeid population geometry 0 0 200000 POLYGON ((0 0, 0.08983 0, 0.08983 0.08983, 0 0... 1 1 250000 POLYGON ((0.08983 0, 0.17966 0, 0.17966 0.0898... 2 2 333333 POLYGON ((0.17966 0, 0.26949 0, 0.26949 0.0898... 3 3 500000 POLYGON ((0.26949 0, 0.35932 0, 0.35932 0.0898... 4 4 1000000 POLYGON ((0.35932 0, 0.44915 0, 0.44915 0.0898... In\u00a0[6]: Copied! <pre>import geopandas as gpd\nfrom shapely import Point\nimport math\n\n# We will create a central city of 1,000,000 population with five surrounding towns of 100,000 population each 150 kilometers away.\n# Each surrounding town will have two intermediate population centers of 25,000 between it and the central city.\nnodes = []\nnodeid = 0\n# Add central city node at 0,0 with a circle geometry of radius 10 km\nnodes.append({\"name\": \"Central City\", \"population\": 1_000_000, \"geometry\": Point(0, 0).buffer(10_000), \"nodeid\": nodeid})\nnodeid += 1\n# Surrounding towns\nNTOWNS  = 5\nfor i in range(NTOWNS):\n    angle = (i * 2 * math.pi / NTOWNS)\n    tx = 150_000 * (cos := math.cos(angle))\n    ty = 150_000 * (sin := math.sin(angle))\n    nodes.append({\"name\": f\"Town {i+1}\", \"population\": 100_000, \"geometry\": Point(tx, ty).buffer(10_000), \"nodeid\": nodeid})\n    nodeid += 1\n    # Intermediate population centers\n    ix1 = 50_000 * cos\n    iy1 = 50_000 * sin\n    nodes.append({\"name\": f\"Interim {i+1}a\", \"population\": 25_000, \"geometry\": Point(ix1, iy1).buffer(5_000), \"nodeid\": nodeid})\n    nodeid += 1\n    ix2 = 100_000 * cos\n    iy2 = 100_000 * sin\n    nodes.append({\"name\": f\"Interim {i+1}b\", \"population\": 25_000, \"geometry\": Point(ix2, iy2).buffer(5_000), \"nodeid\": nodeid})\n    nodeid += 1\n\nscenario = gpd.GeoDataFrame(nodes, crs=\"EPSG:3857\") # Mark as 3857 since we're working in meters/metres.\nscenario.head()\n</pre> import geopandas as gpd from shapely import Point import math  # We will create a central city of 1,000,000 population with five surrounding towns of 100,000 population each 150 kilometers away. # Each surrounding town will have two intermediate population centers of 25,000 between it and the central city. nodes = [] nodeid = 0 # Add central city node at 0,0 with a circle geometry of radius 10 km nodes.append({\"name\": \"Central City\", \"population\": 1_000_000, \"geometry\": Point(0, 0).buffer(10_000), \"nodeid\": nodeid}) nodeid += 1 # Surrounding towns NTOWNS  = 5 for i in range(NTOWNS):     angle = (i * 2 * math.pi / NTOWNS)     tx = 150_000 * (cos := math.cos(angle))     ty = 150_000 * (sin := math.sin(angle))     nodes.append({\"name\": f\"Town {i+1}\", \"population\": 100_000, \"geometry\": Point(tx, ty).buffer(10_000), \"nodeid\": nodeid})     nodeid += 1     # Intermediate population centers     ix1 = 50_000 * cos     iy1 = 50_000 * sin     nodes.append({\"name\": f\"Interim {i+1}a\", \"population\": 25_000, \"geometry\": Point(ix1, iy1).buffer(5_000), \"nodeid\": nodeid})     nodeid += 1     ix2 = 100_000 * cos     iy2 = 100_000 * sin     nodes.append({\"name\": f\"Interim {i+1}b\", \"population\": 25_000, \"geometry\": Point(ix2, iy2).buffer(5_000), \"nodeid\": nodeid})     nodeid += 1  scenario = gpd.GeoDataFrame(nodes, crs=\"EPSG:3857\") # Mark as 3857 since we're working in meters/metres. scenario.head() Out[6]: name population geometry nodeid 0 Central City 1000000 POLYGON ((10000 0, 9951.847 -980.171, 9807.853... 0 1 Town 1 100000 POLYGON ((160000 0, 159951.847 -980.171, 15980... 1 2 Interim 1a 25000 POLYGON ((55000 0, 54975.924 -490.086, 54903.9... 2 3 Interim 1b 25000 POLYGON ((105000 0, 104975.924 -490.086, 10490... 3 4 Town 2 100000 POLYGON ((56352.549 142658.477, 56304.396 1416... 4 In\u00a0[7]: Copied! <pre>scenario.plot(column=\"population\", cmap=\"viridis\", legend=True, figsize=(12, 9))\n</pre> scenario.plot(column=\"population\", cmap=\"viridis\", legend=True, figsize=(12, 9)) Out[7]: <pre>&lt;Axes: &gt;</pre> In\u00a0[8]: Copied! <pre>from laser.core import PropertySet\nfrom laser.generic import Model\nimport laser.generic.SEIR as SEIR\nfrom laser.core.distributions import normal\n\nexp_mean = 7.0\nexp_stddev = 1.0\ninf_mean = 14.0\ninf_stddev = 2.0\nR0 = 2.0\nbeta = R0 / inf_mean\n\nparameters = PropertySet({\"nticks\": 365, \"beta\": beta, \"gravity_c\": 2.5})\nscenario[\"S\"] = scenario.population\nscenario[\"E\"] = 0\nscenario[\"I\"] = 0\nscenario[\"R\"] = 0\nscenario.loc[scenario.name == \"Town 1\", \"S\"] -= 100\nscenario.loc[scenario.name == \"Town 1\", \"I\"] += 100\nprj = scenario.to_crs(4326)\nmodel = Model(prj, parameters)\nincubation_distribution = normal(loc=exp_mean, scale=exp_stddev)\ninfectious_distribution = normal(loc=inf_mean, scale=inf_stddev)\nmodel.components = [\n    SEIR.Susceptible(model),\n    SEIR.Recovered(model),\n    SEIR.Infectious(model, infectious_distribution, 1),\n    SEIR.Exposed(model, incubation_distribution, infectious_distribution, 1, 1),\n    SEIR.Transmission(model, incubation_distribution, 1)\n]\nmodel.run()\n\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(4, 1, figsize=(14, 18), sharex=True)\ncompartments = ['S', 'E', 'I', 'R']\n\nfor idx, comp in enumerate(compartments):\n    for node in scenario.index:\n        axes[idx].plot(getattr(model.nodes, comp)[:, node], label=scenario.loc[node, \"name\"])\n    axes[idx].set_ylabel(comp)\n    axes[idx].legend(loc='upper right', fontsize='small')\naxes[-1].set_xlabel(\"Time (days)\")\nplt.tight_layout()\nplt.show()\n</pre> from laser.core import PropertySet from laser.generic import Model import laser.generic.SEIR as SEIR from laser.core.distributions import normal  exp_mean = 7.0 exp_stddev = 1.0 inf_mean = 14.0 inf_stddev = 2.0 R0 = 2.0 beta = R0 / inf_mean  parameters = PropertySet({\"nticks\": 365, \"beta\": beta, \"gravity_c\": 2.5}) scenario[\"S\"] = scenario.population scenario[\"E\"] = 0 scenario[\"I\"] = 0 scenario[\"R\"] = 0 scenario.loc[scenario.name == \"Town 1\", \"S\"] -= 100 scenario.loc[scenario.name == \"Town 1\", \"I\"] += 100 prj = scenario.to_crs(4326) model = Model(prj, parameters) incubation_distribution = normal(loc=exp_mean, scale=exp_stddev) infectious_distribution = normal(loc=inf_mean, scale=inf_stddev) model.components = [     SEIR.Susceptible(model),     SEIR.Recovered(model),     SEIR.Infectious(model, infectious_distribution, 1),     SEIR.Exposed(model, incubation_distribution, infectious_distribution, 1, 1),     SEIR.Transmission(model, incubation_distribution, 1) ] model.run()  import matplotlib.pyplot as plt  fig, axes = plt.subplots(4, 1, figsize=(14, 18), sharex=True) compartments = ['S', 'E', 'I', 'R']  for idx, comp in enumerate(compartments):     for node in scenario.index:         axes[idx].plot(getattr(model.nodes, comp)[:, node], label=scenario.loc[node, \"name\"])     axes[idx].set_ylabel(comp)     axes[idx].legend(loc='upper right', fontsize='small') axes[-1].set_xlabel(\"Time (days)\") plt.tight_layout() plt.show() <pre>1,750,000 agents in 16 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 365/365 [00:01&lt;00:00, 201.09it/s]\n</pre> In\u00a0[9]: Copied! <pre># model.network\n</pre> # model.network  In\u00a0[10]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(3, 4, figsize=(20, 15))\nticks = list(range(0, 361, 30))\n\nfor ax, tick in zip(axes.flat, ticks):\n    prj[\"I_tick\"] = model.nodes.I[tick, :] # / prj.population\n    prj.plot(column=\"I_tick\", cmap=\"Reds\", legend=True, ax=ax)\n    ax.set_title(f\"Infectious at tick {tick}\")\n    ax.axis('off')\n\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt  fig, axes = plt.subplots(3, 4, figsize=(20, 15)) ticks = list(range(0, 361, 30))  for ax, tick in zip(axes.flat, ticks):     prj[\"I_tick\"] = model.nodes.I[tick, :] # / prj.population     prj.plot(column=\"I_tick\", cmap=\"Reds\", legend=True, ax=ax)     ax.set_title(f\"Infectious at tick {tick}\")     ax.axis('off')  plt.tight_layout() plt.show()"},{"location":"tutorials/notebooks/grid_examples/#grid-function-examples","title":"<code>grid()</code> function examples\u00b6","text":"<p>The <code>grid()</code> function has an option to pass in a custom population function which receives the x and y indices of the current cell. This can be used to create specific scenarios.</p>"},{"location":"tutorials/notebooks/grid_examples/#central-city","title":"Central city\u00b6","text":"<p>Let's construct a scenario with a large central population and smaller outlying populations.</p>"},{"location":"tutorials/notebooks/grid_examples/#ring","title":"Ring\u00b6","text":"<p>Let's construct a scenario with an outer ring of highly populated nodes.</p>"},{"location":"tutorials/notebooks/grid_examples/#linear","title":"Linear\u00b6","text":"<p>Let's do a 1-D scenario.</p>"},{"location":"tutorials/notebooks/grid_examples/#non-grid-custom-scenario","title":"Non-<code>grid()</code> custom scenario\u00b6","text":"<p>Let's look at the GeoDataFrame returned by <code>grid()</code> and create our own, custom hub-and-spoke scenario.</p>"},{"location":"tutorials/notebooks/grid_examples/#seir-model","title":"SEIR model\u00b6","text":"<p>Let's run an SEIR model on that scenario. We will seed infections in one of the radial cities.</p>"},{"location":"tutorials/notebooks/mortality/","title":"Explore the vital dynamics mortality components","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nimport numpy as np\n\nfrom laser.core.utils import grid\nfrom laser.core import PropertySet\nfrom laser.generic.utils import ValuesMap\nfrom laser.generic import Model\nfrom laser.generic import SEIR\nimport laser.core.distributions as dists\nfrom laser.generic.vitaldynamics import MortalityByCDR\n\nfrom laser.core import __version__ as laser_core_version\nfrom laser.generic import __version__ as laser_generic_version\nprint(f\"LASER version: {laser_core_version}\")\nprint(f\"LASER Generic version: {laser_generic_version}\")\n</pre> from pathlib import Path  import numpy as np  from laser.core.utils import grid from laser.core import PropertySet from laser.generic.utils import ValuesMap from laser.generic import Model from laser.generic import SEIR import laser.core.distributions as dists from laser.generic.vitaldynamics import MortalityByCDR  from laser.core import __version__ as laser_core_version from laser.generic import __version__ as laser_generic_version print(f\"LASER version: {laser_core_version}\") print(f\"LASER Generic version: {laser_generic_version}\")  <pre>LASER version: 0.9.1\nLASER Generic version: 0.0.0\n</pre> In\u00a0[2]: Copied! <pre>ROWS = 1\nCOLS = 1\nNNODES = ROWS * COLS\nNTICKS = 3650\nCDR = 20.0  # Crude Mortality Rate 20.0 per 1000 per year\n\nscenario = grid(M=ROWS, N=COLS, population_fn=lambda i, j: 100_000)\n# scenario[\"S\"] = scenario.population\nscenario[\"E\"] = (scenario.population * 0.125).astype(np.int32)\nscenario[\"I\"] = (scenario.population * 0.125).astype(np.int32)\nscenario[\"R\"] = (scenario.population * 0.375).astype(np.int32)\nscenario[\"S\"] = (scenario.population - (scenario.E + scenario.I + scenario.R)).astype(np.int32)\nparameters = PropertySet({\"nticks\": NTICKS})\nmortalityrates = ValuesMap.from_scalar(CDR, NTICKS, NNODES)\n\nexpdurdist = dists.normal(loc=30.0, scale=3.0)\ninfdurdist = dists.normal(loc=30.0, scale=5.0)\n</pre> ROWS = 1 COLS = 1 NNODES = ROWS * COLS NTICKS = 3650 CDR = 20.0  # Crude Mortality Rate 20.0 per 1000 per year  scenario = grid(M=ROWS, N=COLS, population_fn=lambda i, j: 100_000) # scenario[\"S\"] = scenario.population scenario[\"E\"] = (scenario.population * 0.125).astype(np.int32) scenario[\"I\"] = (scenario.population * 0.125).astype(np.int32) scenario[\"R\"] = (scenario.population * 0.375).astype(np.int32) scenario[\"S\"] = (scenario.population - (scenario.E + scenario.I + scenario.R)).astype(np.int32) parameters = PropertySet({\"nticks\": NTICKS}) mortalityrates = ValuesMap.from_scalar(CDR, NTICKS, NNODES)  expdurdist = dists.normal(loc=30.0, scale=3.0) infdurdist = dists.normal(loc=30.0, scale=5.0)  In\u00a0[3]: Copied! <pre>from datetime import datetime\n\nparameters |= {\"prng_seed\": datetime.now().microsecond}\nprint(f\"PRNG Seed: {parameters['prng_seed']}\")\nmodel = Model(scenario, parameters, birthrates=None)\n\nmodel.components = [\n    SEIR.Susceptible(model),\n    SEIR.Exposed(model, expdurdist, infdurdist),\n    SEIR.Infectious(model, infdurdist),\n    SEIR.Recovered(model),\n    # BirthsByCBR(model, birthrates, pyramid),\n    MortalityByCDR(model, mortalityrates),\n]\n\npop_start = model.people.count\nprint(f\"At t=0    {model.people.count = :,}\")\nmodel.run()\npop_finish = model.people.count\nprint(f\"At t={model.params.nticks} {model.people.count = :,}\")\n</pre> from datetime import datetime  parameters |= {\"prng_seed\": datetime.now().microsecond} print(f\"PRNG Seed: {parameters['prng_seed']}\") model = Model(scenario, parameters, birthrates=None)  model.components = [     SEIR.Susceptible(model),     SEIR.Exposed(model, expdurdist, infdurdist),     SEIR.Infectious(model, infdurdist),     SEIR.Recovered(model),     # BirthsByCBR(model, birthrates, pyramid),     MortalityByCDR(model, mortalityrates), ]  pop_start = model.people.count print(f\"At t=0    {model.people.count = :,}\") model.run() pop_finish = model.people.count print(f\"At t={model.params.nticks} {model.people.count = :,}\")  <pre>PRNG Seed: 268548\nAt t=0    model.people.count = 100,000\n</pre> <pre>100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:02&lt;00:00, 1808.35it/s]</pre> <pre>At t=3650 model.people.count = 100,000\n</pre> <pre>\n</pre> In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(10, 6))\nplt.plot(model.nodes.S[:,0], label=\"Susceptible (S)\", color=\"blue\")\nplt.plot(model.nodes.E[:,0], label=\"Exposed (E)\", color=\"orange\")\nplt.plot(model.nodes.I[:,0], label=\"Infectious (I)\", color=\"red\")\nplt.plot(model.nodes.R[:,0], label=\"Recovered (R)\", color=\"green\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Population\")\nplt.title(\"SEIR Channels Over Time\")\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt  plt.figure(figsize=(10, 6)) plt.plot(model.nodes.S[:,0], label=\"Susceptible (S)\", color=\"blue\") plt.plot(model.nodes.E[:,0], label=\"Exposed (E)\", color=\"orange\") plt.plot(model.nodes.I[:,0], label=\"Infectious (I)\", color=\"red\") plt.plot(model.nodes.R[:,0], label=\"Recovered (R)\", color=\"green\") plt.xlabel(\"Time (days)\") plt.ylabel(\"Population\") plt.title(\"SEIR Channels Over Time\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() In\u00a0[5]: Copied! <pre>from laser.generic import State\n\nprint(f\"{(model.people.state != State.DECEASED.value).sum() = :,}\")\nprint(f\"{(model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R)[-1] =}\")\nN = model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R\nstarts = np.array(range(0, NTICKS, 365), dtype=np.int32)\nends = starts + 364\nmortality = (1000 * (N[starts] - N[ends]) / N[starts]).mean(axis=0)[0]\n# print(f\"{mortality.shape = }\")\nprint(f\"{mortality = } (c.f. CDR={CDR})\")\n</pre> from laser.generic import State  print(f\"{(model.people.state != State.DECEASED.value).sum() = :,}\") print(f\"{(model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R)[-1] =}\") N = model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R starts = np.array(range(0, NTICKS, 365), dtype=np.int32) ends = starts + 364 mortality = (1000 * (N[starts] - N[ends]) / N[starts]).mean(axis=0)[0] # print(f\"{mortality.shape = }\") print(f\"{mortality = } (c.f. CDR={CDR})\") <pre>(model.people.state != State.DECEASED.value).sum() = 81,631\n(model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R)[-1] =array([81631], dtype=int32)\nmortality = np.float64(20.038816388355553) (c.f. CDR=20.0)\n</pre> In\u00a0[6]: Copied! <pre>cdr_values = [2, 10, 20, 40]\nn_runs = 11\nresults = {}\n\nfor cdr in cdr_values:\n    run_mortalities = []\n    for index in range(n_runs):\n        # Set up scenario and parameters for each run\n        scenario = grid(M=ROWS, N=COLS, population_fn=lambda i, j: 100_000)\n        scenario[\"E\"] = (scenario.population * 0.125).astype(np.int32)\n        scenario[\"I\"] = (scenario.population * 0.125).astype(np.int32)\n        scenario[\"R\"] = (scenario.population * 0.375).astype(np.int32)\n        scenario[\"S\"] = (scenario.population - (scenario.E + scenario.I + scenario.R)).astype(np.int32)\n        parameters_run = PropertySet({\"nticks\": NTICKS, \"prng_seed\": np.random.randint(0, 1_000_000)})\n        mortalityrates_run = ValuesMap.from_scalar(cdr, NTICKS, NNODES)\n\n        model_run = Model(scenario, parameters_run, birthrates=None)\n        model_run.components = [\n            SEIR.Susceptible(model_run),\n            SEIR.Exposed(model_run, expdurdist, infdurdist),\n            SEIR.Infectious(model_run, infdurdist),\n            SEIR.Recovered(model_run),\n            MortalityByCDR(model_run, mortalityrates_run),\n        ]\n        model_run.run(f\"CDR {cdr:2} Run {index+1:02}/{n_runs:02}\")\n        N_run = model_run.nodes.S + model_run.nodes.E + model_run.nodes.I + model_run.nodes.R\n        starts_run = np.array(range(0, NTICKS, 365), dtype=np.int32)\n        ends_run = starts_run + 364\n        mortality_run = (1000 * (N_run[starts_run] - N_run[ends_run]) / N_run[starts_run]).mean(axis=0)[0]\n        run_mortalities.append(mortality_run)\n    results[cdr] = run_mortalities\n</pre> cdr_values = [2, 10, 20, 40] n_runs = 11 results = {}  for cdr in cdr_values:     run_mortalities = []     for index in range(n_runs):         # Set up scenario and parameters for each run         scenario = grid(M=ROWS, N=COLS, population_fn=lambda i, j: 100_000)         scenario[\"E\"] = (scenario.population * 0.125).astype(np.int32)         scenario[\"I\"] = (scenario.population * 0.125).astype(np.int32)         scenario[\"R\"] = (scenario.population * 0.375).astype(np.int32)         scenario[\"S\"] = (scenario.population - (scenario.E + scenario.I + scenario.R)).astype(np.int32)         parameters_run = PropertySet({\"nticks\": NTICKS, \"prng_seed\": np.random.randint(0, 1_000_000)})         mortalityrates_run = ValuesMap.from_scalar(cdr, NTICKS, NNODES)          model_run = Model(scenario, parameters_run, birthrates=None)         model_run.components = [             SEIR.Susceptible(model_run),             SEIR.Exposed(model_run, expdurdist, infdurdist),             SEIR.Infectious(model_run, infdurdist),             SEIR.Recovered(model_run),             MortalityByCDR(model_run, mortalityrates_run),         ]         model_run.run(f\"CDR {cdr:2} Run {index+1:02}/{n_runs:02}\")         N_run = model_run.nodes.S + model_run.nodes.E + model_run.nodes.I + model_run.nodes.R         starts_run = np.array(range(0, NTICKS, 365), dtype=np.int32)         ends_run = starts_run + 364         mortality_run = (1000 * (N_run[starts_run] - N_run[ends_run]) / N_run[starts_run]).mean(axis=0)[0]         run_mortalities.append(mortality_run)     results[cdr] = run_mortalities   <pre>CDR  2 Run 01/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2179.38it/s]\nCDR  2 Run 02/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2143.28it/s]\nCDR  2 Run 03/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2148.79it/s]\nCDR  2 Run 04/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2142.56it/s]\nCDR  2 Run 05/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2192.42it/s]\nCDR  2 Run 06/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2157.83it/s]\nCDR  2 Run 07/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2194.12it/s]\nCDR  2 Run 08/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2192.44it/s]\nCDR  2 Run 09/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2166.96it/s]\nCDR  2 Run 10/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2192.61it/s]\nCDR  2 Run 11/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2182.10it/s]\nCDR 10 Run 01/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2181.69it/s]\nCDR 10 Run 02/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2175.38it/s]\nCDR 10 Run 03/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2145.10it/s]\nCDR 10 Run 04/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2200.80it/s]\nCDR 10 Run 05/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2154.41it/s]\nCDR 10 Run 06/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2091.96it/s]\nCDR 10 Run 07/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2159.55it/s]\nCDR 10 Run 08/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2164.23it/s]\nCDR 10 Run 09/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2174.98it/s]\nCDR 10 Run 10/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2187.02it/s]\nCDR 10 Run 11/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2140.96it/s]\nCDR 20 Run 01/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2176.35it/s]\nCDR 20 Run 02/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2181.64it/s]\nCDR 20 Run 03/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2167.31it/s]\nCDR 20 Run 04/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2174.79it/s]\nCDR 20 Run 05/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2158.61it/s]\nCDR 20 Run 06/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2178.92it/s]\nCDR 20 Run 07/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2133.41it/s]\nCDR 20 Run 08/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2181.69it/s]\nCDR 20 Run 09/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2166.69it/s]\nCDR 20 Run 10/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2169.64it/s]\nCDR 20 Run 11/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2167.34it/s]\nCDR 40 Run 01/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2123.35it/s]\nCDR 40 Run 02/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2149.11it/s]\nCDR 40 Run 03/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2132.12it/s]\nCDR 40 Run 04/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2100.97it/s]\nCDR 40 Run 05/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2154.27it/s]\nCDR 40 Run 06/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2128.21it/s]\nCDR 40 Run 07/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2151.37it/s]\nCDR 40 Run 08/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 1999.53it/s]\nCDR 40 Run 09/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2086.76it/s]\nCDR 40 Run 10/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2092.85it/s]\nCDR 40 Run 11/11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2103.87it/s]\n</pre> In\u00a0[7]: Copied! <pre>fig, axes = plt.subplots(2, 2, figsize=(14, 10), sharex=True, sharey=True)\naxes = axes.flatten()\n\nfor idx, cdr in enumerate(cdr_values):\n    ax = axes[idx]\n    mortalities = results[cdr]\n    ax.scatter(range(1, n_runs + 1), mortalities, color=\"blue\", marker=\"x\", label=\"Observed\")\n    ax.axhline(np.mean(mortalities), color=\"green\", linestyle=\"--\", linewidth=2, label=f\"Mean {np.mean(mortalities):.2f}\")\n    ax.set_title(f\"CDR={cdr}\")\n    ax.set_xlabel(\"Run\")\n    ax.set_ylabel(\"Observed CDR\")\n    ax.grid(True)\n    ax.legend()\n\nplt.suptitle(\"Observed CDRs per Run for Each CDR Value\")\nplt.tight_layout(rect=[0, 0.03, 1, 0.95])\nplt.show()\n</pre> fig, axes = plt.subplots(2, 2, figsize=(14, 10), sharex=True, sharey=True) axes = axes.flatten()  for idx, cdr in enumerate(cdr_values):     ax = axes[idx]     mortalities = results[cdr]     ax.scatter(range(1, n_runs + 1), mortalities, color=\"blue\", marker=\"x\", label=\"Observed\")     ax.axhline(np.mean(mortalities), color=\"green\", linestyle=\"--\", linewidth=2, label=f\"Mean {np.mean(mortalities):.2f}\")     ax.set_title(f\"CDR={cdr}\")     ax.set_xlabel(\"Run\")     ax.set_ylabel(\"Observed CDR\")     ax.grid(True)     ax.legend()  plt.suptitle(\"Observed CDRs per Run for Each CDR Value\") plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() In\u00a0[8]: Copied! <pre>from laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\n\n# https://population.un.org/wpp/downloads?folder=Standard%20Projections&amp;group=Population WPP2024_POP_F01_1_POPULATION_SINGLE_AGE_BOTH_SEXES.xlsx\nage_data = np.loadtxt(Path.cwd() / \"data\" / \"Nigeria-Distribution-2020.csv\", delimiter=\",\", usecols=0)[0:89]  # Up to age 89 (largest value int16 can hold.)\npyramid = AliasedDistribution(age_data)\n\n# https://population.un.org/wpp/downloads?folder=Standard%20Projections&amp;group=Mortality WPP2024_MORT_F04_1_LIFE_TABLE_SURVIVORS_BOTH_SEXES.xlsx\n# Use `.cumsum()` because the KME takes cumulative counts.\nsurvival_data = np.loadtxt(Path.cwd() / \"data\" / \"Nigeria-Survival-2020.csv\", delimiter=\",\", usecols=1)[0:89].cumsum() # Up to age 89 (largest value int16 can hold.)\nsurvival = KaplanMeierEstimator(survival_data)\n</pre> from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator  # https://population.un.org/wpp/downloads?folder=Standard%20Projections&amp;group=Population WPP2024_POP_F01_1_POPULATION_SINGLE_AGE_BOTH_SEXES.xlsx age_data = np.loadtxt(Path.cwd() / \"data\" / \"Nigeria-Distribution-2020.csv\", delimiter=\",\", usecols=0)[0:89]  # Up to age 89 (largest value int16 can hold.) pyramid = AliasedDistribution(age_data)  # https://population.un.org/wpp/downloads?folder=Standard%20Projections&amp;group=Mortality WPP2024_MORT_F04_1_LIFE_TABLE_SURVIVORS_BOTH_SEXES.xlsx # Use `.cumsum()` because the KME takes cumulative counts. survival_data = np.loadtxt(Path.cwd() / \"data\" / \"Nigeria-Survival-2020.csv\", delimiter=\",\", usecols=1)[0:89].cumsum() # Up to age 89 (largest value int16 can hold.) survival = KaplanMeierEstimator(survival_data)  In\u00a0[9]: Copied! <pre>from laser.generic.vitaldynamics import BirthsByCBR\nfrom laser.generic.vitaldynamics import MortalityByEstimator\n\nparameters |= {\"prng_seed\": datetime.now().microsecond}\nprint(f\"PRNG Seed: {parameters['prng_seed']}\")\nmodel = Model(scenario, parameters, birthrates=None)\n\nmodel.components = [\n    SEIR.Susceptible(model),\n    SEIR.Exposed(model, expdurdist, infdurdist),\n    SEIR.Infectious(model, infdurdist),\n    SEIR.Recovered(model),\n    # No births, but we need to track initial population DOBs\n    BirthsByCBR(model, birthrates=ValuesMap.from_scalar(0.0, NTICKS, NNODES), pyramid=pyramid),\n    MortalityByEstimator(model, survival),\n]\n\npop_start = model.people.count\nprint(f\"At t=0    {model.people.count = :,}\")\nmodel.run()\npop_finish = model.people.count\nprint(f\"At t={model.params.nticks} {model.people.count = :,}\")\n</pre> from laser.generic.vitaldynamics import BirthsByCBR from laser.generic.vitaldynamics import MortalityByEstimator  parameters |= {\"prng_seed\": datetime.now().microsecond} print(f\"PRNG Seed: {parameters['prng_seed']}\") model = Model(scenario, parameters, birthrates=None)  model.components = [     SEIR.Susceptible(model),     SEIR.Exposed(model, expdurdist, infdurdist),     SEIR.Infectious(model, infdurdist),     SEIR.Recovered(model),     # No births, but we need to track initial population DOBs     BirthsByCBR(model, birthrates=ValuesMap.from_scalar(0.0, NTICKS, NNODES), pyramid=pyramid),     MortalityByEstimator(model, survival), ]  pop_start = model.people.count print(f\"At t=0    {model.people.count = :,}\") model.run() pop_finish = model.people.count print(f\"At t={model.params.nticks} {model.people.count = :,}\") <pre>PRNG Seed: 958354\nAt t=0    model.people.count = 100,000\n</pre> <pre>100,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2167.29it/s]</pre> <pre>At t=3650 model.people.count = 100,000\n</pre> <pre>\n</pre> In\u00a0[10]: Copied! <pre>plt.figure(figsize=(10, 6))\nplt.plot(model.nodes.S[:,0], label=\"Susceptible (S)\", color=\"blue\")\nplt.plot(model.nodes.E[:,0], label=\"Exposed (E)\", color=\"orange\")\nplt.plot(model.nodes.I[:,0], label=\"Infectious (I)\", color=\"red\")\nplt.plot(model.nodes.R[:,0], label=\"Recovered (R)\", color=\"green\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Population\")\nplt.title(\"SEIR Channels Over Time\")\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) plt.plot(model.nodes.S[:,0], label=\"Susceptible (S)\", color=\"blue\") plt.plot(model.nodes.E[:,0], label=\"Exposed (E)\", color=\"orange\") plt.plot(model.nodes.I[:,0], label=\"Infectious (I)\", color=\"red\") plt.plot(model.nodes.R[:,0], label=\"Recovered (R)\", color=\"green\") plt.xlabel(\"Time (days)\") plt.ylabel(\"Population\") plt.title(\"SEIR Channels Over Time\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()  In\u00a0[11]: Copied! <pre>print(f\"{(model.people.state != State.DECEASED.value).sum() = :8,}\")\nprint(f\"{(model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R)[-1] = :}\")\nN = model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R\nstarts = np.array(range(0, NTICKS, 365), dtype=np.int32)\nends = starts + 364\nmortality = (1000 * (N[starts] - N[ends]) / N[starts]).mean(axis=0)[0]\n# print(f\"{mortality.shape = }\")\nprint(f\"{mortality = }\")\n</pre> print(f\"{(model.people.state != State.DECEASED.value).sum() = :8,}\") print(f\"{(model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R)[-1] = :}\") N = model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R starts = np.array(range(0, NTICKS, 365), dtype=np.int32) ends = starts + 364 mortality = (1000 * (N[starts] - N[ends]) / N[starts]).mean(axis=0)[0] # print(f\"{mortality.shape = }\") print(f\"{mortality = }\")  <pre>(model.people.state != State.DECEASED.value).sum() =   89,041\n(model.nodes.S + model.nodes.E + model.nodes.I + model.nodes.R)[-1] = [89041]\nmortality = np.float64(11.50285312026774)\n</pre>"},{"location":"tutorials/notebooks/mortality/#explore-the-vital-dynamics-mortality-components","title":"Explore the vital dynamics mortality components\u00b6","text":""},{"location":"tutorials/notebooks/mortality/#mortalitybycdr","title":"MortalityByCDR\u00b6","text":"<p>First, we will look at <code>MortalityByCDR</code>.</p>"},{"location":"tutorials/notebooks/mortality/#single-single-node-simulation","title":"Single Single Node Simulation\u00b6","text":""},{"location":"tutorials/notebooks/mortality/#plot-population-over-time","title":"Plot population over time\u00b6","text":""},{"location":"tutorials/notebooks/mortality/#check-statistics","title":"Check statistics\u00b6","text":""},{"location":"tutorials/notebooks/mortality/#multiple-single-node-simulations-with-varying-cdr","title":"Multiple single node simulations with varying CDR\u00b6","text":"<p>Let's run the model several times over different CDR values and plot the results.</p> <p>We'll run 11 times each with 100_000 population and CDR values in [2, 10, 20, 40] and plot the histogram of CDR and mean for each CDR.</p>"},{"location":"tutorials/notebooks/mortality/#plot-results","title":"Plot results\u00b6","text":""},{"location":"tutorials/notebooks/mortality/#mortalitybyestimator","title":"MortalityByEstimator\u00b6","text":"<p>Next, we will look at <code>MortalityByEstimator</code> which draws date-of-death (<code>dod</code>) from an estimator and expires agents at that DOD.</p> <p>We will need a population pyramid (<code>AliasedDistribution</code>) to initialize the population ages (<code>dob</code>). We will also need a survival curve (<code>KaplanMeierEstimator</code>) to estimate the DOD.</p> <p>The data for the <code>AliasedDistribution</code> is simple the number of samples in each implied bucket. E.g., the values [125, 500, 125, 250] imply four buckets with 1/8<sup>th</sup> of the population in the first, 1/2 in the second, 1/8<sup>th</sup> in the third, and the remainder, 1/4<sup>th</sup>, in the last.</p> <p>The data for the <code>KaplanMeierEstimator</code> is the cumulative number of deaths up to and including each implied age bin/bucket. E.g., the values [7470, 1059, 1003, 950, 892] for ages 0 ... 4 in the Nigeria 2020 survival information indicate the number of deaths at each age. The input to the estimator would be [7470, 8529, 9532, 10482, 892].</p>"},{"location":"tutorials/notebooks/mortality/#plot-population-over-time","title":"Plot population over time\u00b6","text":""},{"location":"tutorials/notebooks/ri_exploration/","title":"Explore RoutineImmunization","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nimport numpy as np\n\nfrom laser.generic import SEIR\nfrom laser.generic import Model\nfrom laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator\nfrom laser.core.utils import grid\nfrom laser.core import PropertySet\nfrom laser.core import distributions\nfrom laser.generic.utils import ValuesMap\nfrom laser.core.demographics import load_pyramid_csv\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\n\nimport laser.core\nimport laser.generic\n\nPOPULATION = 200_000\nINITIAL_INFECTIONS = 100\nROWS = 1\nCOLS = 1\nNNODES = ROWS * COLS\n\nscenario = grid(M=ROWS, N=COLS, population_fn=lambda x, y: POPULATION // NNODES)\nscenario[\"S\"] = scenario.population - INITIAL_INFECTIONS\nscenario[\"E\"] = 0\nscenario[\"I\"] = INITIAL_INFECTIONS\nscenario[\"R\"] = 0\n\nR0 = 7 # 1.125\nexposure_mean = 7.0\nexposure_scale = 1.0\ninfectious_mean = 10.0\ninfectious_scale = 1.5\nbeta = R0 / infectious_mean\n\nNTICKS = 730\nparameters = PropertySet({\"nticks\": NTICKS, \"beta\": beta})\nbirthrates = ValuesMap.from_scalar(35.0, NTICKS, NNODES)\n\nexpdurdist = distributions.normal(loc=exposure_mean, scale=exposure_scale)\ninfdurdist = distributions.normal(loc=infectious_mean, scale=infectious_scale)\n\n# https://population.un.org/wpp/downloads?folder=Standard%20Projections&amp;group=Population WPP2024_POP_F01_1_POPULATION_SINGLE_AGE_BOTH_SEXES.xlsx\nage_data = np.loadtxt(Path.cwd() / \"data\" / \"Nigeria-Distribution-2020.csv\", delimiter=\",\", usecols=0)[0:89]  # Up to age 89 (largest value int16 can hold.)\npyramid = AliasedDistribution(age_data)\n\n# https://population.un.org/wpp/downloads?folder=Standard%20Projections&amp;group=Mortality WPP2024_MORT_F04_1_LIFE_TABLE_SURVIVORS_BOTH_SEXES.xlsx\nsurvival_data = np.loadtxt(Path.cwd() / \"data\" / \"Nigeria-Survival-2020.csv\", delimiter=\",\", usecols=1)[0:89].cumsum() # Up to age 89 (largest value int16 can hold.)\nsurvival = KaplanMeierEstimator(survival_data)\n\nprint(f\"laser-core version: {laser.core.__version__}\")\nprint(f\"laser-generic version: {laser.generic.__version__}\")\n</pre> from pathlib import Path  import numpy as np  from laser.generic import SEIR from laser.generic import Model from laser.generic.vitaldynamics import BirthsByCBR, MortalityByEstimator from laser.core.utils import grid from laser.core import PropertySet from laser.core import distributions from laser.generic.utils import ValuesMap from laser.core.demographics import load_pyramid_csv from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator  import laser.core import laser.generic  POPULATION = 200_000 INITIAL_INFECTIONS = 100 ROWS = 1 COLS = 1 NNODES = ROWS * COLS  scenario = grid(M=ROWS, N=COLS, population_fn=lambda x, y: POPULATION // NNODES) scenario[\"S\"] = scenario.population - INITIAL_INFECTIONS scenario[\"E\"] = 0 scenario[\"I\"] = INITIAL_INFECTIONS scenario[\"R\"] = 0  R0 = 7 # 1.125 exposure_mean = 7.0 exposure_scale = 1.0 infectious_mean = 10.0 infectious_scale = 1.5 beta = R0 / infectious_mean  NTICKS = 730 parameters = PropertySet({\"nticks\": NTICKS, \"beta\": beta}) birthrates = ValuesMap.from_scalar(35.0, NTICKS, NNODES)  expdurdist = distributions.normal(loc=exposure_mean, scale=exposure_scale) infdurdist = distributions.normal(loc=infectious_mean, scale=infectious_scale)  # https://population.un.org/wpp/downloads?folder=Standard%20Projections&amp;group=Population WPP2024_POP_F01_1_POPULATION_SINGLE_AGE_BOTH_SEXES.xlsx age_data = np.loadtxt(Path.cwd() / \"data\" / \"Nigeria-Distribution-2020.csv\", delimiter=\",\", usecols=0)[0:89]  # Up to age 89 (largest value int16 can hold.) pyramid = AliasedDistribution(age_data)  # https://population.un.org/wpp/downloads?folder=Standard%20Projections&amp;group=Mortality WPP2024_MORT_F04_1_LIFE_TABLE_SURVIVORS_BOTH_SEXES.xlsx survival_data = np.loadtxt(Path.cwd() / \"data\" / \"Nigeria-Survival-2020.csv\", delimiter=\",\", usecols=1)[0:89].cumsum() # Up to age 89 (largest value int16 can hold.) survival = KaplanMeierEstimator(survival_data)  print(f\"laser-core version: {laser.core.__version__}\") print(f\"laser-generic version: {laser.generic.__version__}\") <pre>laser-core version: 0.9.1\nlaser-generic version: 0.0.0\n</pre> In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\n\ndef plot_traces(model, zoom=1.0, style=[\"-\", \"--\"]):\n    figure = plt.figure(figsize=(zoom*6, zoom*4.5))\n    axes = [figure.add_subplot(1, 1, 1)]\n    axes.append(axes[0].twinx())\n\n    for channel, axis, color in [('S', 0, \"blue\"), ('E', 1, \"orange\"), ('I', 1, \"red\"), ('R', 0, \"green\")]:\n        for node in range(model.nodes.count):\n            data = getattr(model.nodes, channel)[:,node]\n            label = f\"Node {node} - {channel}\"\n            axes[axis].plot(data, label=label, color=color, linestyle=style[node % len(style)])\n\n    axes[0].set_xlabel(\"Time (days)\")\n    axes[0].set_ylabel(\"Population\")\n    axes[1].set_ylabel(\"Population\")\n    axes[0].legend(loc=\"upper left\")\n    axes[1].legend(loc=\"upper right\")\n    axes[0].grid(True, which=\"both\", axis=\"both\", linestyle=\":\", linewidth=0.7, alpha=0.7, color=\"purple\")\n    axes[1].grid(True, which=\"both\", axis=\"y\", linestyle=\"--\", linewidth=0.7, alpha=0.7, color=\"orange\")\n    plt.tight_layout()\n    plt.show()\n\n    return\n\ndef print_summary(model):\n    final_S = model.nodes.S[-1,:].sum()\n    final_R = model.nodes.R[-1,:].sum()\n    cumulative_infected = model.nodes.newly_infected.sum()\n    print(f\"Final Susceptible:   {final_S:7,}\")\n    print(f\"Final Recovered:     {final_R:7,}\")\n    print(f\"Cumulative Infected: {cumulative_infected:7,}\")\n\nprint(\"done\")\n</pre> import matplotlib.pyplot as plt  def plot_traces(model, zoom=1.0, style=[\"-\", \"--\"]):     figure = plt.figure(figsize=(zoom*6, zoom*4.5))     axes = [figure.add_subplot(1, 1, 1)]     axes.append(axes[0].twinx())      for channel, axis, color in [('S', 0, \"blue\"), ('E', 1, \"orange\"), ('I', 1, \"red\"), ('R', 0, \"green\")]:         for node in range(model.nodes.count):             data = getattr(model.nodes, channel)[:,node]             label = f\"Node {node} - {channel}\"             axes[axis].plot(data, label=label, color=color, linestyle=style[node % len(style)])      axes[0].set_xlabel(\"Time (days)\")     axes[0].set_ylabel(\"Population\")     axes[1].set_ylabel(\"Population\")     axes[0].legend(loc=\"upper left\")     axes[1].legend(loc=\"upper right\")     axes[0].grid(True, which=\"both\", axis=\"both\", linestyle=\":\", linewidth=0.7, alpha=0.7, color=\"purple\")     axes[1].grid(True, which=\"both\", axis=\"y\", linestyle=\"--\", linewidth=0.7, alpha=0.7, color=\"orange\")     plt.tight_layout()     plt.show()      return  def print_summary(model):     final_S = model.nodes.S[-1,:].sum()     final_R = model.nodes.R[-1,:].sum()     cumulative_infected = model.nodes.newly_infected.sum()     print(f\"Final Susceptible:   {final_S:7,}\")     print(f\"Final Recovered:     {final_R:7,}\")     print(f\"Cumulative Infected: {cumulative_infected:7,}\")  print(\"done\")  <pre>done\n</pre> In\u00a0[3]: Copied! <pre>from laser.generic import State\n\nbaseline = Model(scenario, parameters, birthrates=birthrates, name=\"SEIR 2 Node 2 Year No RI\")\nbaseline.components = [\n    SEIR.Susceptible(baseline),\n    SEIR.Recovered(baseline),\n    SEIR.Infectious(baseline, infdurdist, infdurmin=1),\n    SEIR.Exposed(baseline, expdurdist, infdurdist, expdurmin=1, infdurmin=1),\n    SEIR.Transmission(baseline, expdurdist=expdurdist, expdurmin=1),\n    BirthsByCBR(baseline, birthrates, pyramid),\n    MortalityByEstimator(baseline, survival),\n]\n\nprint(f\"{baseline.people.count    =:8,}\")\nprint(f\"{baseline.people.capacity =:8,}\")\n\ndef initialize_susceptibility(model, output: bool = False, plot: bool = False) -&gt; None:\n\n    # Mark everyone over age 5 and susceptible as recovered (not susceptible)\n    now = 0\n    ages = now - model.people.dob\n\n    ##### ======== #####\n    if plot:\n        nbins = (ages.max() + 1) // 365\n        plt.hist(ages, bins=nbins, color=\"lightgreen\", edgecolor=\"black\")\n        plt.xlabel(\"Age (days)\")\n        plt.ylabel(\"Count\")\n        plt.title(\"Histogram of Ages at Baseline\")\n        plt.show()\n        print(f\"Ages range from {ages.min()} to {ages.max()} days\")\n    ##### ======== #####\n\n    susceptible = model.people.state == State.SUSCEPTIBLE.value\n    over_five = ages &gt;= 5*365\n    susceptible_over_five = susceptible &amp; over_five\n    model.people.state[susceptible_over_five] = State.RECOVERED.value\n    model.nodes.S[now,:] -= susceptible_over_five.sum()\n    model.nodes.R[now,:] += susceptible_over_five.sum()\n    remaining_susceptible = model.people.state == State.SUSCEPTIBLE.value\n    if output:\n        print(f\"Initially susceptible:           {susceptible.sum():7,}\")\n        print(f\"Initially over five:             {over_five.sum():7,}\")\n        print(f\"Initially susceptible over five: {susceptible_over_five.sum():7,}\")\n        print(f\"Remaining susceptible:           {remaining_susceptible.sum():7,} ({model.nodes.S[now,:].sum():7,})\")\n\n    return\n\ninitialize_susceptibility(baseline, output=True, plot=False)\n\nbaseline.run(f\"SEIR {NNODES} Node(s) 2 Year No RI\")\n\nplot_traces(baseline)\nprint_summary(baseline)\n</pre> from laser.generic import State  baseline = Model(scenario, parameters, birthrates=birthrates, name=\"SEIR 2 Node 2 Year No RI\") baseline.components = [     SEIR.Susceptible(baseline),     SEIR.Recovered(baseline),     SEIR.Infectious(baseline, infdurdist, infdurmin=1),     SEIR.Exposed(baseline, expdurdist, infdurdist, expdurmin=1, infdurmin=1),     SEIR.Transmission(baseline, expdurdist=expdurdist, expdurmin=1),     BirthsByCBR(baseline, birthrates, pyramid),     MortalityByEstimator(baseline, survival), ]  print(f\"{baseline.people.count    =:8,}\") print(f\"{baseline.people.capacity =:8,}\")  def initialize_susceptibility(model, output: bool = False, plot: bool = False) -&gt; None:      # Mark everyone over age 5 and susceptible as recovered (not susceptible)     now = 0     ages = now - model.people.dob      ##### ======== #####     if plot:         nbins = (ages.max() + 1) // 365         plt.hist(ages, bins=nbins, color=\"lightgreen\", edgecolor=\"black\")         plt.xlabel(\"Age (days)\")         plt.ylabel(\"Count\")         plt.title(\"Histogram of Ages at Baseline\")         plt.show()         print(f\"Ages range from {ages.min()} to {ages.max()} days\")     ##### ======== #####      susceptible = model.people.state == State.SUSCEPTIBLE.value     over_five = ages &gt;= 5*365     susceptible_over_five = susceptible &amp; over_five     model.people.state[susceptible_over_five] = State.RECOVERED.value     model.nodes.S[now,:] -= susceptible_over_five.sum()     model.nodes.R[now,:] += susceptible_over_five.sum()     remaining_susceptible = model.people.state == State.SUSCEPTIBLE.value     if output:         print(f\"Initially susceptible:           {susceptible.sum():7,}\")         print(f\"Initially over five:             {over_five.sum():7,}\")         print(f\"Initially susceptible over five: {susceptible_over_five.sum():7,}\")         print(f\"Remaining susceptible:           {remaining_susceptible.sum():7,} ({model.nodes.S[now,:].sum():7,})\")      return  initialize_susceptibility(baseline, output=True, plot=False)  baseline.run(f\"SEIR {NNODES} Node(s) 2 Year No RI\")  plot_traces(baseline) print_summary(baseline) <pre>baseline.people.count    = 200,000\nbaseline.people.capacity = 221,754\nInitially susceptible:           199,900\nInitially over five:             168,992\nInitially susceptible over five: 168,905\nRemaining susceptible:            30,995 ( 30,995)\n</pre> <pre>SEIR 1 Node(s) 2 Year No RI: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:01&lt;00:00, 609.40it/s]\n</pre> <pre>Final Susceptible:    28,859\nFinal Recovered:     178,334\nCumulative Infected:  14,170\n</pre> <p>Note that we have bumped $R_0$ up to a value which will cause an outbreak in the reduced susceptible population. $R_0 \\approx N / S(0) \\approx 6.5$</p> In\u00a0[4]: Copied! <pre>from laser.generic.immunization import RoutineImmunizationEx\n\ndef run_with_ri(coverage_fn, dose_timing_dist=None, dose_timing_min=None, plot=True):\n    with_ri = Model(scenario, parameters, birthrates=birthrates, name=\"SEIR 2 Node 2 Year 70% RI\")\n\n    if dose_timing_dist is None:\n        dose_timing_dist = distributions.normal(loc=274, scale=15)  # Around 9 months\n    if dose_timing_min is None:\n        dose_timing_min = 183  # Minimum 6 months\n\n    with_ri.components = [\n        SEIR.Susceptible(with_ri),\n        SEIR.Recovered(with_ri),\n        SEIR.Infectious(with_ri, infdurdist, infdurmin=1),\n        SEIR.Exposed(with_ri, expdurdist, infdurdist, expdurmin=1, infdurmin=1),\n        SEIR.Transmission(with_ri, expdurdist=expdurdist, expdurmin=1),\n        BirthsByCBR(with_ri, birthrates, pyramid),\n        MortalityByEstimator(with_ri, survival),\n        RoutineImmunizationEx(with_ri, coverage_fn=coverage_fn, dose_timing_dist=dose_timing_dist, dose_timing_min=dose_timing_min, track=True),\n    ]\n\n    initialize_susceptibility(with_ri, output=False)\n\n    with_ri.run()\n    if plot:\n        plot_traces(with_ri)\n        print_summary(with_ri)\n\n    return with_ri\n\ncoverage_constant = distributions.constant_float(value=0.7) # 70% coverage\nwith_ri = run_with_ri(coverage_constant)\n</pre> from laser.generic.immunization import RoutineImmunizationEx  def run_with_ri(coverage_fn, dose_timing_dist=None, dose_timing_min=None, plot=True):     with_ri = Model(scenario, parameters, birthrates=birthrates, name=\"SEIR 2 Node 2 Year 70% RI\")      if dose_timing_dist is None:         dose_timing_dist = distributions.normal(loc=274, scale=15)  # Around 9 months     if dose_timing_min is None:         dose_timing_min = 183  # Minimum 6 months      with_ri.components = [         SEIR.Susceptible(with_ri),         SEIR.Recovered(with_ri),         SEIR.Infectious(with_ri, infdurdist, infdurmin=1),         SEIR.Exposed(with_ri, expdurdist, infdurdist, expdurmin=1, infdurmin=1),         SEIR.Transmission(with_ri, expdurdist=expdurdist, expdurmin=1),         BirthsByCBR(with_ri, birthrates, pyramid),         MortalityByEstimator(with_ri, survival),         RoutineImmunizationEx(with_ri, coverage_fn=coverage_fn, dose_timing_dist=dose_timing_dist, dose_timing_min=dose_timing_min, track=True),     ]      initialize_susceptibility(with_ri, output=False)      with_ri.run()     if plot:         plot_traces(with_ri)         print_summary(with_ri)      return with_ri  coverage_constant = distributions.constant_float(value=0.7) # 70% coverage with_ri = run_with_ri(coverage_constant)  <pre>200,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:01&lt;00:00, 723.43it/s]\n</pre> <pre>Final Susceptible:    36,869\nFinal Recovered:     170,451\nCumulative Infected:   6,464\n</pre> <p>Note that although the shape of the outbreak resembles the shape without RI, the cumulative infected is much lower.</p> In\u00a0[5]: Copied! <pre>plt.figure(figsize=(10, 6))\nplt.plot(baseline.nodes.I[:, 0], color='red', label='No RI (baseline)')\nplt.plot(with_ri.nodes.I[:, 0], color='blue', label='With RI')\nplt.xlabel('Time (days)')\nplt.ylabel('Infectious Individuals')\nplt.title('Comparison of Infectious Individuals: Baseline vs With RI')\nplt.legend()\nplt.grid(True, linestyle=':', alpha=0.7)\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) plt.plot(baseline.nodes.I[:, 0], color='red', label='No RI (baseline)') plt.plot(with_ri.nodes.I[:, 0], color='blue', label='With RI') plt.xlabel('Time (days)') plt.ylabel('Infectious Individuals') plt.title('Comparison of Infectious Individuals: Baseline vs With RI') plt.legend() plt.grid(True, linestyle=':', alpha=0.7) plt.show() <p>We initialized the <code>RoutineImmunization</code> component with <code>track=True</code> which means we can look at the values drawn for the time-to-vaccination and plot them to verify that we are getting the values we wanted.</p> In\u00a0[6]: Copied! <pre>from scipy.stats import norm\nimport numpy as np\n\nnonzero_initial_ri = with_ri.people.initial_ri[with_ri.people.initial_ri &gt; 0]\n\ncounts, bins, _ = plt.hist(nonzero_initial_ri, bins=30, color=\"skyblue\", edgecolor=\"black\")\n\n# Mark the mean initial RI value\nplt.axvline(nonzero_initial_ri.mean(), color=\"red\", linestyle=\"--\", linewidth=2, label=f\"Mean {nonzero_initial_ri.mean():.1f}\")\n\nx = np.linspace(bins[0], bins[-1], len(bins)*5) # *5 for smoothness\npdf = norm.pdf(x, loc=274, scale=15)\n# Scale the PDF so that its maximum matches the maximum of the histogram\nbin_width = bins[1] - bins[0]\npdf_scaled = pdf * nonzero_initial_ri.size * bin_width\nplt.plot(x, pdf_scaled, color=\"darkblue\", linewidth=2, label=\"Normal(274, 15) PDF\")\n\nplt.legend()\nplt.xlabel('Initial RI Value')\nplt.ylabel('Count')\nplt.title('Histogram of Non-zero Initial RI Values')\nplt.show()\n</pre> from scipy.stats import norm import numpy as np  nonzero_initial_ri = with_ri.people.initial_ri[with_ri.people.initial_ri &gt; 0]  counts, bins, _ = plt.hist(nonzero_initial_ri, bins=30, color=\"skyblue\", edgecolor=\"black\")  # Mark the mean initial RI value plt.axvline(nonzero_initial_ri.mean(), color=\"red\", linestyle=\"--\", linewidth=2, label=f\"Mean {nonzero_initial_ri.mean():.1f}\")  x = np.linspace(bins[0], bins[-1], len(bins)*5) # *5 for smoothness pdf = norm.pdf(x, loc=274, scale=15) # Scale the PDF so that its maximum matches the maximum of the histogram bin_width = bins[1] - bins[0] pdf_scaled = pdf * nonzero_initial_ri.size * bin_width plt.plot(x, pdf_scaled, color=\"darkblue\", linewidth=2, label=\"Normal(274, 15) PDF\")  plt.legend() plt.xlabel('Initial RI Value') plt.ylabel('Count') plt.title('Histogram of Non-zero Initial RI Values') plt.show()"},{"location":"tutorials/notebooks/ri_exploration/#explore-routineimmunization","title":"Explore RoutineImmunization\u00b6","text":""},{"location":"tutorials/notebooks/ri_exploration/#routine-ri-70-coverage-mean-time-to-vaccination-9-months-274-days","title":"Routine RI - 70% coverage, mean time to vaccination 9 months (274) days\u00b6","text":""},{"location":"tutorials/notebooks/seasonality/","title":"Seasonality in transmission","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n\nfrom laser.core.utils import grid\nfrom laser.core import PropertySet\nimport laser.core.distributions as dists\n\nfrom laser.generic import Model\nfrom laser.generic import SI\nfrom laser.generic import SIR\nfrom laser.generic import SEIR\nfrom laser.generic.vitaldynamics import ConstantPopVitalDynamics\nfrom laser.generic.utils import ValuesMap\n</pre> import numpy as np  from laser.core.utils import grid from laser.core import PropertySet import laser.core.distributions as dists  from laser.generic import Model from laser.generic import SI from laser.generic import SIR from laser.generic import SEIR from laser.generic.vitaldynamics import ConstantPopVitalDynamics from laser.generic.utils import ValuesMap  In\u00a0[2]: Copied! <pre>NTICKS = 365 * 10\ninfectious_duration_mean = 14.0\ninfectious_duration_scale = 1.5\nR0 = 15.0\nbeta = R0 / infectious_duration_mean\nCBR = 33\nmu = (1 + (CBR / 1000))**(1/365) - 1\n    \nscenario = grid(1, 1, population_fn=lambda row, col: 1_000_000)\nscenario[\"S\"] = np.round(scenario.population / R0).astype(np.int32)\nscenario[\"I\"] = (scenario.population * mu * (R0 - 1) / beta).astype(np.int32)\nscenario[\"R\"] = scenario.population - (scenario.S + scenario.I)\n\nparameters = PropertySet({\"nticks\": NTICKS, \"beta\": beta})\n\nno_seasonality = Model(scenario, parameters, birthrates=None)\n\ninfdurdist = dists.normal(loc=infectious_duration_mean, scale=infectious_duration_scale)\n\nno_seasonality.components = [\n    SIR.Susceptible(no_seasonality),\n    SIR.Infectious(no_seasonality, infdurdist, infdurmin=1.0),\n    SIR.Recovered(no_seasonality),\n    SIR.Transmission(no_seasonality, infdurdist, infdurmin=1.0, seasonality=None),\n    ConstantPopVitalDynamics(no_seasonality, recycle_rates=ValuesMap.from_scalar(CBR, NTICKS, 1)),\n]\n\nno_seasonality.run()\n</pre> NTICKS = 365 * 10 infectious_duration_mean = 14.0 infectious_duration_scale = 1.5 R0 = 15.0 beta = R0 / infectious_duration_mean CBR = 33 mu = (1 + (CBR / 1000))**(1/365) - 1      scenario = grid(1, 1, population_fn=lambda row, col: 1_000_000) scenario[\"S\"] = np.round(scenario.population / R0).astype(np.int32) scenario[\"I\"] = (scenario.population * mu * (R0 - 1) / beta).astype(np.int32) scenario[\"R\"] = scenario.population - (scenario.S + scenario.I)  parameters = PropertySet({\"nticks\": NTICKS, \"beta\": beta})  no_seasonality = Model(scenario, parameters, birthrates=None)  infdurdist = dists.normal(loc=infectious_duration_mean, scale=infectious_duration_scale)  no_seasonality.components = [     SIR.Susceptible(no_seasonality),     SIR.Infectious(no_seasonality, infdurdist, infdurmin=1.0),     SIR.Recovered(no_seasonality),     SIR.Transmission(no_seasonality, infdurdist, infdurmin=1.0, seasonality=None),     ConstantPopVitalDynamics(no_seasonality, recycle_rates=ValuesMap.from_scalar(CBR, NTICKS, 1)), ]  no_seasonality.run() <pre>1,000,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:03&lt;00:00, 1119.55it/s]\n</pre> In\u00a0[3]: Copied! <pre>import matplotlib.pyplot as plt\n\ndef plot_model(model):\n    history = model.nodes\n\n    _fig, ax1 = plt.subplots(figsize=(10, 6))\n\n    styles = ['-', '--', '-.', ':']\n\n    # Primary axis: S and R\n    for node in range(model.nodes.count):\n        ax1.plot(history.S[:, node], label=f'Susceptible (S) - Node {node}', color='tab:blue', linestyle=styles[node % len(styles)])\n        ax1.plot(history.R[:, node], label=f'Recovered (R) - Node {node}', color='tab:green', linestyle=styles[node % len(styles)])\n    ax1.set_xlabel('Time (days)')\n    ax1.set_ylabel('Population (S, R)')\n\n    N = (history.S + history.I + history.R)\n    ax1.set_ylim(-N.max() / 10, N.max())\n\n    ax1.legend(loc='upper left')\n    ax1.grid()\n\n    # Secondary axis: I\n    ax2 = ax1.twinx()\n    for node in range(model.nodes.count):\n        ax2.plot(history.I[:, node], label=f'Infectious (I) - Node {node}', color='tab:red', linestyle=styles[node % len(styles)])\n    ax2.set_ylabel('Population (I)')\n\n    maximum = ((int(history.I.max()) // 500) + 1) * 500\n    ax2.set_ylim(-maximum / 10, maximum)\n\n    # If there is a seasonal component, plot it overlaid on ax2\n    transmission = next((comp for comp in model.components if isinstance(comp, (SI.Transmission, SIR.Transmission, SEIR.Transmission))), None)\n    if transmission and hasattr(transmission, 'seasonality'):\n        seasonality = transmission.seasonality.values\n        scaled = seasonality * maximum / 2\n        for node in range(model.nodes.count):\n            ax2.plot(scaled[:,node], label='Seasonality (scaled)', color='tab:gray', linestyle=styles[node % len(styles)], alpha=0.5)\n\n    ax2.legend(loc='upper right')\n\n    plt.title('SIR Model: S, I, and R over Time')\n    plt.show()\n\nplot_model(no_seasonality)\n</pre> import matplotlib.pyplot as plt  def plot_model(model):     history = model.nodes      _fig, ax1 = plt.subplots(figsize=(10, 6))      styles = ['-', '--', '-.', ':']      # Primary axis: S and R     for node in range(model.nodes.count):         ax1.plot(history.S[:, node], label=f'Susceptible (S) - Node {node}', color='tab:blue', linestyle=styles[node % len(styles)])         ax1.plot(history.R[:, node], label=f'Recovered (R) - Node {node}', color='tab:green', linestyle=styles[node % len(styles)])     ax1.set_xlabel('Time (days)')     ax1.set_ylabel('Population (S, R)')      N = (history.S + history.I + history.R)     ax1.set_ylim(-N.max() / 10, N.max())      ax1.legend(loc='upper left')     ax1.grid()      # Secondary axis: I     ax2 = ax1.twinx()     for node in range(model.nodes.count):         ax2.plot(history.I[:, node], label=f'Infectious (I) - Node {node}', color='tab:red', linestyle=styles[node % len(styles)])     ax2.set_ylabel('Population (I)')      maximum = ((int(history.I.max()) // 500) + 1) * 500     ax2.set_ylim(-maximum / 10, maximum)      # If there is a seasonal component, plot it overlaid on ax2     transmission = next((comp for comp in model.components if isinstance(comp, (SI.Transmission, SIR.Transmission, SEIR.Transmission))), None)     if transmission and hasattr(transmission, 'seasonality'):         seasonality = transmission.seasonality.values         scaled = seasonality * maximum / 2         for node in range(model.nodes.count):             ax2.plot(scaled[:,node], label='Seasonality (scaled)', color='tab:gray', linestyle=styles[node % len(styles)], alpha=0.5)      ax2.legend(loc='upper right')      plt.title('SIR Model: S, I, and R over Time')     plt.show()  plot_model(no_seasonality) In\u00a0[4]: Copied! <pre>sinusoidal = Model(scenario, parameters, birthrates=None)\n\n# We will use a seasonal factor +/- 20% around a mean of 1.0 anchored to day 214 (beginning of school)\nseasonality = ValuesMap.from_timeseries(\n    1.0 + 0.2 * np.sin((np.arange(NTICKS) - 214) * (2 * np.pi / 365)),\n    sinusoidal.nodes.count,\n)\n\nsinusoidal.components = [\n    SIR.Susceptible(sinusoidal),\n    SIR.Infectious(sinusoidal, infdurdist, infdurmin=1.0),\n    SIR.Recovered(sinusoidal),\n    SIR.Transmission(sinusoidal, infdurdist, infdurmin=1.0, seasonality=seasonality),\n    ConstantPopVitalDynamics(sinusoidal, recycle_rates=ValuesMap.from_scalar(CBR, NTICKS, 1)),\n]\n\nsinusoidal.run()\n</pre> sinusoidal = Model(scenario, parameters, birthrates=None)  # We will use a seasonal factor +/- 20% around a mean of 1.0 anchored to day 214 (beginning of school) seasonality = ValuesMap.from_timeseries(     1.0 + 0.2 * np.sin((np.arange(NTICKS) - 214) * (2 * np.pi / 365)),     sinusoidal.nodes.count, )  sinusoidal.components = [     SIR.Susceptible(sinusoidal),     SIR.Infectious(sinusoidal, infdurdist, infdurmin=1.0),     SIR.Recovered(sinusoidal),     SIR.Transmission(sinusoidal, infdurdist, infdurmin=1.0, seasonality=seasonality),     ConstantPopVitalDynamics(sinusoidal, recycle_rates=ValuesMap.from_scalar(CBR, NTICKS, 1)), ]  sinusoidal.run()  <pre>1,000,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:03&lt;00:00, 1193.18it/s]\n</pre> In\u00a0[5]: Copied! <pre>plot_model(sinusoidal)\n</pre> plot_model(sinusoidal)  In\u00a0[6]: Copied! <pre>from laser.generic import State\n\nclass Importation:\n    def __init__(self, model, period, cases, infdurdist, infdurmin=1.0):\n        self.model = model\n        self.period = period\n        self.cases = cases\n        self.infdurdist = infdurdist\n        self.infdurmin = infdurmin\n\n        return\n    \n    def step(self, tick):\n        if tick % self.period != 0:\n            return\n\n        susceptible_indices = np.nonzero(self.model.people.state == State.SUSCEPTIBLE.value)[0]\n        imports = np.random.choice(susceptible_indices, size=self.cases, replace=False)\n        self.model.people.state[imports] = State.INFECTIOUS.value\n        self.model.people.itimer[imports] = np.maximum(np.round(dists.sample_floats(self.infdurdist, np.zeros_like(imports, dtype=np.float32), 0, 0)), self.infdurmin)\n\n        # print(f\"Importing {len(imports):3} cases at tick {tick:4}\")\n\n        self.model.nodes.S[tick+1] -= len(imports)\n        self.model.nodes.I[tick+1] += len(imports)\n\n        return\n</pre> from laser.generic import State  class Importation:     def __init__(self, model, period, cases, infdurdist, infdurmin=1.0):         self.model = model         self.period = period         self.cases = cases         self.infdurdist = infdurdist         self.infdurmin = infdurmin          return          def step(self, tick):         if tick % self.period != 0:             return          susceptible_indices = np.nonzero(self.model.people.state == State.SUSCEPTIBLE.value)[0]         imports = np.random.choice(susceptible_indices, size=self.cases, replace=False)         self.model.people.state[imports] = State.INFECTIOUS.value         self.model.people.itimer[imports] = np.maximum(np.round(dists.sample_floats(self.infdurdist, np.zeros_like(imports, dtype=np.float32), 0, 0)), self.infdurmin)          # print(f\"Importing {len(imports):3} cases at tick {tick:4}\")          self.model.nodes.S[tick+1] -= len(imports)         self.model.nodes.I[tick+1] += len(imports)          return In\u00a0[7]: Copied! <pre>with_importation = Model(scenario, parameters, birthrates=None)\n\nwith_importation.components = [\n    SIR.Susceptible(with_importation),\n    SIR.Infectious(with_importation, infdurdist, infdurmin=1.0),\n    SIR.Recovered(with_importation),\n    SIR.Transmission(with_importation, infdurdist, infdurmin=1.0, seasonality=seasonality),\n    ConstantPopVitalDynamics(with_importation, recycle_rates=ValuesMap.from_scalar(CBR, NTICKS, 1)),\n    Importation(with_importation, period=30, cases=3, infdurdist=infdurdist, infdurmin=1.0),\n]\n\nwith_importation.run()\n</pre> with_importation = Model(scenario, parameters, birthrates=None)  with_importation.components = [     SIR.Susceptible(with_importation),     SIR.Infectious(with_importation, infdurdist, infdurmin=1.0),     SIR.Recovered(with_importation),     SIR.Transmission(with_importation, infdurdist, infdurmin=1.0, seasonality=seasonality),     ConstantPopVitalDynamics(with_importation, recycle_rates=ValuesMap.from_scalar(CBR, NTICKS, 1)),     Importation(with_importation, period=30, cases=3, infdurdist=infdurdist, infdurmin=1.0), ]  with_importation.run() <pre>1,000,000 agents in 1 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:03&lt;00:00, 1145.80it/s]\n</pre> In\u00a0[8]: Copied! <pre>plot_model(with_importation)\n</pre> plot_model(with_importation)  <p>So, a few cases coming in every 30 days along with seasonal forcing gives us a very nice periodic outbreak every two years.</p> <p>It might be interesting to see how seasonal forcing interacts with critical community size for endemicity. We will leave that as an exercise for the reader.</p> In\u00a0[9]: Copied! <pre>## Coupled locations with out of phase seasonality.\n\ntwo_node_scenario = grid(1, 2, population_fn=lambda row, col: 500_000)\ntwo_node_scenario[\"S\"] = np.round(two_node_scenario.population / R0).astype(np.int32)\ntwo_node_scenario[\"I\"] = (two_node_scenario.population * mu * (R0 - 1) / beta).astype(np.int32)\ntwo_node_scenario[\"R\"] = two_node_scenario.population - (two_node_scenario.S + two_node_scenario.I)\n\ntwo_node_model = Model(two_node_scenario, parameters, birthrates=None)\n\ntwo_node_seasonality = np.zeros((NTICKS, two_node_model.nodes.count), np.float32)\ntwo_node_seasonality[:, 0] = 1.0 + 0.2 * np.sin((np.arange(NTICKS) - 214) * (2 * np.pi / 365))\ntwo_node_seasonality[:, 1] = 1.0 + 0.2 * np.sin((np.arange(NTICKS) - 214 + 183) * (2 * np.pi / 365))\n\ntwo_node_model.components = [\n    SIR.Susceptible(two_node_model),\n    SIR.Infectious(two_node_model, infdurdist, infdurmin=1.0),\n    SIR.Recovered(two_node_model),\n    SIR.Transmission(two_node_model, infdurdist, infdurmin=1.0, seasonality=ValuesMap.from_array(two_node_seasonality)),\n    ConstantPopVitalDynamics(two_node_model, recycle_rates=ValuesMap.from_scalar(CBR, NTICKS, 1)),\n    Importation(two_node_model, period=365, cases=3, infdurdist=infdurdist, infdurmin=1.0),\n]\n\ntwo_node_model.network /= 500.0  # Reduce coupling for clearer dynamics.\n\ntwo_node_model.run()\n</pre> ## Coupled locations with out of phase seasonality.  two_node_scenario = grid(1, 2, population_fn=lambda row, col: 500_000) two_node_scenario[\"S\"] = np.round(two_node_scenario.population / R0).astype(np.int32) two_node_scenario[\"I\"] = (two_node_scenario.population * mu * (R0 - 1) / beta).astype(np.int32) two_node_scenario[\"R\"] = two_node_scenario.population - (two_node_scenario.S + two_node_scenario.I)  two_node_model = Model(two_node_scenario, parameters, birthrates=None)  two_node_seasonality = np.zeros((NTICKS, two_node_model.nodes.count), np.float32) two_node_seasonality[:, 0] = 1.0 + 0.2 * np.sin((np.arange(NTICKS) - 214) * (2 * np.pi / 365)) two_node_seasonality[:, 1] = 1.0 + 0.2 * np.sin((np.arange(NTICKS) - 214 + 183) * (2 * np.pi / 365))  two_node_model.components = [     SIR.Susceptible(two_node_model),     SIR.Infectious(two_node_model, infdurdist, infdurmin=1.0),     SIR.Recovered(two_node_model),     SIR.Transmission(two_node_model, infdurdist, infdurmin=1.0, seasonality=ValuesMap.from_array(two_node_seasonality)),     ConstantPopVitalDynamics(two_node_model, recycle_rates=ValuesMap.from_scalar(CBR, NTICKS, 1)),     Importation(two_node_model, period=365, cases=3, infdurdist=infdurdist, infdurmin=1.0), ]  two_node_model.network /= 500.0  # Reduce coupling for clearer dynamics.  two_node_model.run()  <pre>1,000,000 agents in 2 node(s): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:02&lt;00:00, 1315.51it/s]\n</pre> In\u00a0[10]: Copied! <pre>plot_model(two_node_model)\n</pre> plot_model(two_node_model)  <p>Note: Our two model network transfers ~0.02% of local contagion to the other node on each timestep.</p> In\u00a0[11]: Copied! <pre>two_node_model.network\n</pre> two_node_model.network  Out[11]: <pre>array([[0.       , 0.0001875],\n       [0.0001875, 0.       ]], dtype=float32)</pre> In\u00a0[12]: Copied! <pre>from laser.generic import SI\n\nscenario = grid(1, 1, population_fn=lambda row, col: 1_000_000)\nscenario[\"S\"] = scenario.population - 10\nscenario[\"I\"] = 10\n\n# 1, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625\nparameters = PropertySet({\"nticks\": 730, \"beta\": 0.03125})\n\nsi_wout_seasonality = Model(scenario, parameters, birthrates=None)\nsi_wout_seasonality.components = [\n    SI.Susceptible(si_wout_seasonality),\n    SI.Infectious(si_wout_seasonality),\n    SI.Transmission(si_wout_seasonality, seasonality=None),\n]\n\nsi_wout_seasonality.run(\"SI model without seasonality\")\n\ndef plot_si_model(model):\n    history = model.nodes\n\n    plt.figure(figsize=(10, 6))\n    plt.plot(history.S[:, 0], label='Susceptible (S)', color='tab:blue')\n    plt.plot(history.I[:, 0], label='Infectious (I)', color='tab:red')\n    plt.xlabel('Time (days)')\n    plt.ylabel('Population')\n    plt.title('SI Model: S and I over Time')\n    plt.ylim(-model.scenario.population[0] / 10, model.scenario.population[0] * 1.1)\n    plt.legend()\n    plt.grid()\n    plt.show()\n\n    return\n\nplot_si_model(si_wout_seasonality)\n</pre> from laser.generic import SI  scenario = grid(1, 1, population_fn=lambda row, col: 1_000_000) scenario[\"S\"] = scenario.population - 10 scenario[\"I\"] = 10  # 1, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625 parameters = PropertySet({\"nticks\": 730, \"beta\": 0.03125})  si_wout_seasonality = Model(scenario, parameters, birthrates=None) si_wout_seasonality.components = [     SI.Susceptible(si_wout_seasonality),     SI.Infectious(si_wout_seasonality),     SI.Transmission(si_wout_seasonality, seasonality=None), ]  si_wout_seasonality.run(\"SI model without seasonality\")  def plot_si_model(model):     history = model.nodes      plt.figure(figsize=(10, 6))     plt.plot(history.S[:, 0], label='Susceptible (S)', color='tab:blue')     plt.plot(history.I[:, 0], label='Infectious (I)', color='tab:red')     plt.xlabel('Time (days)')     plt.ylabel('Population')     plt.title('SI Model: S and I over Time')     plt.ylim(-model.scenario.population[0] / 10, model.scenario.population[0] * 1.1)     plt.legend()     plt.grid()     plt.show()      return  plot_si_model(si_wout_seasonality)  <pre>SI model without seasonality: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 2193.14it/s]\n</pre> In\u00a0[13]: Copied! <pre>si_with_seasonality = Model(scenario, parameters, birthrates=None)\n\nseasonality = np.ones((parameters.nticks, si_with_seasonality.nodes.count), np.float32)\n# Phase out transmission between days 300 and 400\nseasonality[300:400,:] = np.linspace(1.0, 0.0, 100)[:, None]\nseasonality[400:,:] = 0.0\nseasonality = ValuesMap.from_array(seasonality)\n\nsi_with_seasonality.components = [\n    SI.Susceptible(si_with_seasonality),\n    SI.Infectious(si_with_seasonality),\n    SI.Transmission(si_with_seasonality, seasonality=seasonality),\n]\n\nsi_with_seasonality.run(\"SI model with seasonality\")\n</pre> si_with_seasonality = Model(scenario, parameters, birthrates=None)  seasonality = np.ones((parameters.nticks, si_with_seasonality.nodes.count), np.float32) # Phase out transmission between days 300 and 400 seasonality[300:400,:] = np.linspace(1.0, 0.0, 100)[:, None] seasonality[400:,:] = 0.0 seasonality = ValuesMap.from_array(seasonality)  si_with_seasonality.components = [     SI.Susceptible(si_with_seasonality),     SI.Infectious(si_with_seasonality),     SI.Transmission(si_with_seasonality, seasonality=seasonality), ]  si_with_seasonality.run(\"SI model with seasonality\")  <pre>SI model with seasonality: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1780.15it/s]\n</pre> In\u00a0[14]: Copied! <pre>plot_si_model(si_with_seasonality)\n</pre> plot_si_model(si_with_seasonality)"},{"location":"tutorials/notebooks/seasonality/#seasonality-in-transmission","title":"Seasonality in transmission\u00b6","text":"<p>Let's look at seasonal transmission in the SIR model.</p>"},{"location":"tutorials/notebooks/seasonality/#baseline-no-seasonality","title":"Baseline - no seasonality\u00b6","text":"<p>First, let's run a model with no seasonal forcing of transmission. Transmission is always driven by $\\beta$ with no temporal or spatial variation.</p> <p>The shortcut for this is to omit the <code>seasonality</code> parameter to the <code>Transmission</code> component or explicitly set it to <code>None</code>. The <code>Transmission</code> component will use 1.0 at all times in this case.</p>"},{"location":"tutorials/notebooks/seasonality/#baseline-results","title":"Baseline results\u00b6","text":"<p>Let's plot the S, I, and R traces for the baseline scenario. Even without seasonal forcing we see a natural periodicity.</p>"},{"location":"tutorials/notebooks/seasonality/#seasonality","title":"Seasonality\u00b6","text":"<p>Let's introduce some seasonal forcing on a yearly basis: $1 + 0.2 * sin((t - 214)/365)$ where <code>t = tick % 365</code>.</p> <p>We will offset <code>t</code> by 214 to anchor the increase in transmission around the start of school.</p>"},{"location":"tutorials/notebooks/seasonality/#seasonality-results","title":"Seasonality results\u00b6","text":"<p>Interestingly, with the annual forcing we see the start of more regular outbreaks before a low point in transmission leads to local elimination. Note the magnitude of the outbreaks is quite a bit higher than the baseline scenario.</p>"},{"location":"tutorials/notebooks/seasonality/#importation","title":"Importation\u00b6","text":"<p>Looks like we are going to need some periodic importation to keep from seeing extinction.</p>"},{"location":"tutorials/notebooks/seasonality/#seasonality-with-importation","title":"Seasonality with importation\u00b6","text":"<p>Now we see outbreaks even higher but sharper as outbreaks synchronize with the seasonal forcing and transmission is attenuated shortly after the outbreak peak. Note the timing of the outbreaks after day 1500 and their alignment with the seasonality factor.</p>"},{"location":"tutorials/notebooks/seasonality/#coupled-locations-with-out-of-phase-seasonality","title":"Coupled locations with out of phase seasonality\u00b6","text":"<p>Out of curiosity, let's use spatial heterogeneity and build a two node model where the seasonality factors are out of phase between the two nodes.</p>"},{"location":"tutorials/notebooks/seasonality/#two-node-out-of-phase-model","title":"Two node out of phase model\u00b6","text":"<p>Interesting results. The second node, out of phase, provides a reservoir of infection which causes smaller outbreaks between the peaks we saw in the previous model. Also, the magnitude of the outbreaks in the primary node is quite a bit smaller.</p>"},{"location":"tutorials/notebooks/seasonality/#test-the-si-model","title":"Test the SI model\u00b6","text":"<p>Let's a) make sure the TransmissionSIx component's seasonality is working and b) let's use a crazy \"seasonality\" to make the effect obvious.</p> <p>Again, let's start with a baseline of no seasonality.</p>"},{"location":"tutorials/notebooks/seasonality/#radical-seasonality","title":"Radical \"seasonality\"\u00b6","text":"<p>Now, let's set up \"seasonality\" which attenuates transmission from 100% to 0% over the course of 100 days. We can imagine that this is a hypothetical intervention that is triggered shortly after detection of the outbreak.</p> <p>Note this scenario demonstrates that the spatio-temporal \"seasonality\" factor does not have to be cyclical and can be used to model the effects of interventions.</p>"},{"location":"tutorials/notebooks/seasonality/#si-with-seasonality","title":"SI with \"seasonality\"\u00b6","text":"<p>We see that the effect of our hypothetical intervention is to initially attenuate and then halt the outbreak.</p>"}]}